var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"AYON Launcher - Desktop application","text":""},{"location":"index.html#introduction","title":"Introduction","text":"<p>Desktop application launcher for AYON pipeline. You need AYON launcher to be able to interact with any of the integrated applications. It acts as the main entry point into the pipeline for all artists publishing and loading data with AYON. Even though AYON launcher is a standalone desktop application, it doesn't do anything until it's connected to an AYON server instance.</p> <p>The main purpose of application is to distribute updates based on current server state and to start main logic of core addon. At this moment core addon is <code>ayon_core</code>.</p> <p>Desktop application also deploys AYON shim, which acts as bridge for different versions of AYON launcher. More information here.</p> <p>To get all the information about the project, go to AYON.io</p>"},{"location":"index.html#shim","title":"Shim","text":"<p>AYON shim is a small executable that knows where to find \"real\" executable of AYON launcher.</p> <p>Usage of shim: 1. Handle custom uri protocol scheme <code>ayon-launcher://</code> which is used for running web actions. 2. Path to shim executable can be used for shortcuts and automations, so you don't need to worry about updating the path on AYON launcher update. This might be useful e.g. for Deadline plugin.</p> <p>Shim is installed with AYON launcher, or on first run of AYON launcher. It is installed to app data which is based on OS, or to <code>{AYON_LAUNCHER_LOCAL_DIR}/shim/</code> directory if <code>AYON_LAUNCHER_LOCAL_DIR</code> environment variable is set.</p> <p>[!CAUTION] Shim on macOs is installed to <code>/Applications/AYON.app</code>. To be able to use it in automation which waits for AYON launcher to finish then you have to use full path to executable <code>/Applications/AYON.app/Contents/MacOS/ayon</code>.</p>"},{"location":"index.html#building-ayon-desktop-application","title":"Building AYON Desktop application","text":"<p>We aim to closely follow VFX Reference Platform</p> <p>AYON is written in Python 3 with specific elements still running in Python2 until all DCCs are fully updated. To see the list of those, that are not quite there yet, go to VFX Python3 tracker</p> <p>CX_Freeze is used to freeze the Python code and all of its dependencies, and Poetry for virtual environment management.</p> <p>We provide comprehensive build steps: * Windows * macOS * Linux - needs distribution specific steps</p>"},{"location":"index.html#linux-build","title":"Linux build","text":"<p>We do recommend to use docker build options for linux distributions. Prepared dockerfiles do all necessary steps for you.</p> <p>NOTE: There might be cases when linux installer should use PySide2 instead of PySide6 (which is default). You can change this by using <code>--use-pyside2</code> in docker build command. Or you can use env variable <code>QT_BINDING=pyside2</code> for local build. We do handle that case for Centos 7 build, but all other variants are using PySide6 by default.</p> <p>Output of the build process is installer with metadata file that can be distributed to workstations.</p>"},{"location":"index.html#upload-installer-to-server","title":"Upload installer to server","text":"<p>Create installer information from json file on server and upload the installer file to be downloaded by users.</p>"},{"location":"index.html#windows","title":"Windows","text":"<p>Run <code>./tools/manage.ps1 upload --server &lt;your server&gt; --api-key &lt;your api key&gt;</code></p> <p>Or, run <code>./tools/manage.ps1 upload --server &lt;your server&gt; --username &lt;your admin username&gt; --password  &lt;your pasword&gt;</code></p>"},{"location":"index.html#linux-macos","title":"Linux &amp; macOS","text":"<p>Run <code>./tools/make.sh upload --server &lt;your server&gt; --api-key &lt;your api key&gt;</code></p> <p>Or, run <code>./tools/make.sh upload --server &lt;your server&gt; --username &lt;your admin username&gt; --password  &lt;your pasword&gt;</code></p> <p>Upload command has more options, use <code>--help</code> to investigate them. For example, it is possible to use username &amp; password instead of api key.</p>"},{"location":"index.html#running-ayon-desktop-application","title":"Running AYON Desktop application","text":"<p>AYON can be executed either from live sources (this repository) or from \"frozen code\" - executables that can be build using steps described above.</p>"},{"location":"index.html#from-sources","title":"From sources","text":"<p>You need to create env and install dependencies first.</p> <p>Ideally, this step should be re-run with each new version.</p>"},{"location":"index.html#windows_1","title":"Windows","text":"<pre><code>./tools/manage.ps1 create-env\n./tools/manage.ps1 install-runtime-dependencies\n</code></pre>"},{"location":"index.html#linux-macos_1","title":"Linux &amp; macOS","text":"<pre><code>./tools/make.sh create-env\n./tools/make.sh install-runtime-dependencies\n</code></pre>"},{"location":"index.html#run","title":"Run","text":"<p>AYON can be run directly from sources by activating virtual environment:</p>"},{"location":"index.html#windows_2","title":"Windows","text":"<pre><code>./tools/manage.ps1 run\n</code></pre>"},{"location":"index.html#linux-macos_2","title":"Linux &amp; macOS","text":"<pre><code>./tools/make.sh run\n</code></pre>"},{"location":"index.html#from-frozen-code","title":"From frozen code","text":"<p>You need to build AYON first. This will produce executable - <code>ayon.exe</code> and <code>ayon_console.exe</code> on Windows, <code>ayon</code> on Linux and <code>AYON {version}.app</code> for macOS.</p>"},{"location":"index.html#windows_3","title":"Windows","text":"<p>Executable <code>ayon_console.exe</code> creates console with output - useful for debugging, <code>ayon.exe</code> does not create console, but does not have any stdout or stderr output.</p>"},{"location":"index.html#startup","title":"Startup","text":"<p>Once AYON launcher is installed and launched there are few ways how to affect what will happen. Default behavior will ask for login to server, if user did not log in yet, then starts distribution of updates, and last step is to start the main logic.</p> <p>Main logic is now using command line handling from <code>ayon_core</code> addon. If path to python script is passed it will start the python script as main logic instead.</p>"},{"location":"index.html#arguments","title":"Arguments","text":"<p>There are reserver global arguments that cannot be used in any cli handling: - <code>init-ayon-launcher</code> - Initialize launcher. Register executable path to known AYON launcher locations, and install shim executable. - <code>--bundle &lt;BUNDLE NAME&gt;</code> - Force AYON to use specific bundle instead of the one that is set in the config file. This is useful for testing new bundles before they are released. - <code>--verbose &lt;LOG LEVEL&gt;</code> - Change logging level to one of the following: DEBUG, INFO, WARNING, ERROR, CRITICAL. - <code>--debug</code> - Simplified way how to change verbose to DEBUG. Also sets <code>AYON_DEBUG</code> environment variable to <code>1</code>. - <code>--skip-headers</code> - Skip headers in the console output. - <code>--use-dev</code> - Use dev bundle and settings, if bundle is not explicitly defined. - <code>--use-staging</code> - Use staging settings, and use staging bundle, if bundle is not explicitly defined. Cannot be combined with staging. - <code>--headless</code> - Tell AYON to run in headless mode. No UIs are shown during bootstrap. Affects <code>AYON_HEADLESS_MODE</code> environment variable. Custom logic must handle headless mode on own. - <code>--ayon-login</code> - Show login dialog on startup. - <code>--skip-bootstrap</code> - Skip bootstrap process. Used for inner logic of distribution.</p>"},{"location":"index.html#environment-variables","title":"Environment variables","text":"<p>Environment variables that are set during startup: - AYON_VERSION - Version of AYON launcher. - AYON_BUNDLE_NAME - Name of bundle that is used. - AYON_LOG_LEVEL - Log level that is used. - AYON_DEBUG - Debug flag enabled when set to '1'. - AYON_USE_STAGING - Use staging settings when set to '1'. - AYON_USE_DEV - Use dev mode settings when set to '1'. - AYON_HEADLESS_MODE - Headless mode flag enabled when set to '1'. - AYON_EXECUTABLE - Path to executable that is used to run AYON. - AYON_ROOT - Root to AYON launcher content. - AYON_LAUNCHER_STORAGE_DIR - Directory where are stored dependency packages, addons and files related to addons. At own risk can be shared (NOT TESTED). - AYON_LAUNCHER_LOCAL_DIR - Directory where are stored user/machine specific files. This MUST NOT be shared. - AYON_ADDONS_DIR - Path to AYON addons directory - Still used but considered as deprecated. Please rather use 'AYON_LAUNCHER_STORAGE_DIR' to change location. - AYON_DEPENDENCIES_DIR - Path to AYON dependencies directory - Still used but considered as deprecated. Please rather use 'AYON_LAUNCHER_STORAGE_DIR' to change location. - AYON_AUTO_UPDATE - Modify auto-update behavior which might be useful for shared distribution location. Missing AYON launcher, addon or dependency package won't be updated if is set to 'skip', instead will try to continue. And won't allow user to launch if is set to 'block' with brief explanation in a dialog.</p> <p>[!NOTE] Environment variables AYON_LAUNCHER_STORAGE_DIR and AYON_LAUNCHER_LOCAL_DIR are by default set to the same folder. Path is based on OS. - Windows: <code>%LOCALAPPDATA%\\Ynput\\AYON</code> - Linux: <code>~/.local/share/AYON</code> - macOS: <code>~/Library/Application Support/AYON</code> It is required to set the environment variables before AYON launcher is started as it is required for bootstrap.</p> <p>[!TIP] Environment variables AYON_ADDONS_DIR and AYON_DEPENDENCIES_DIR by default lead relative to AYON_LAUNCHER_STORAGE_DIR. - AYON_ADDONS_DIR -&gt; <code>{AYON_LAUNCHER_STORAGE_DIR}/addons</code> - AYON_DEPENDENCIES_DIR -&gt; <code>{AYON_LAUNCHER_STORAGE_DIR}/dependency_packages</code> Changing their values will change where addons and dependency packages are stored even if you change AYON_LAUNCHER_STORAGE_DIR!</p> <ul> <li> <p>AYON_MENU_LABEL - Label for AYON menu -&gt; TODO move to ayon_core addon.</p> </li> <li> <p>SSL_CERT_FILE - Use certificates from 'certifi' if 'SSL_CERT_FILE' is not set.</p> </li> </ul>"},{"location":"index.html#developer-mode","title":"Developer mode","text":"<p>Developer mode enables to skip standard distribution process and use local sources of addon code. This is useful for development of addon. Developer mode must be enabled and configured on AYON server. To use it in AYON launcher create dev bundle and use <code>--use-dev</code> argument, or define bundle name <code>--bundle &lt;dev bundle name&gt;</code> in cli arguments.</p>"},{"location":"index.html#links","title":"Links","text":"<ul> <li>Launcher Dev | AYON Docs</li> <li>AYON Developer Mode \u2013 Guide | AYON Forums</li> <li>How to keep up with AYON updates? | AYON Forums</li> </ul>"},{"location":"index.html#todos","title":"TODOs","text":"<ul> <li>[ ] Use 'platformdirs' instead of 'appdirs'.</li> <li>[ ] Remove unused 'acre' dependency. Now has to be kept for ayon-core compatibility.</li> </ul>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/app_launcher.html","title":"app_launcher","text":"<p>Launch process that is not child process of python or AYON launcher.</p> <p>This is written for linux distributions where process tree may affect what is when closed or blocked to be closed.</p>"},{"location":"autoapi/app_launcher.html#app_launcher.main","title":"<code>main(input_json_path)</code>","text":"<p>Read launch arguments from json file and launch the process.</p> <p>Expected that json contains \"args\" key with string or list of strings.</p> <p>Arguments are converted to string using <code>list2cmdline</code>. At the end is added <code>&amp;</code> which will cause that launched process is detached and running as \"background\" process.</p>"},{"location":"autoapi/app_launcher.html#app_launcher.main--notes","title":"Notes","text":"<p>@iLLiCiT: This should be possible to do with 'disown' or double forking but     I didn't find a way how to do it properly. Disown didn't work as     expected for me and double forking killed parent process which is     unexpected too.</p> Source code in <code>app_launcher.py</code> <pre><code>def main(input_json_path):\n    \"\"\"Read launch arguments from json file and launch the process.\n\n    Expected that json contains \"args\" key with string or list of strings.\n\n    Arguments are converted to string using `list2cmdline`. At the end is added\n    `&amp;` which will cause that launched process is detached and running as\n    \"background\" process.\n\n    ## Notes\n    @iLLiCiT: This should be possible to do with 'disown' or double forking but\n        I didn't find a way how to do it properly. Disown didn't work as\n        expected for me and double forking killed parent process which is\n        unexpected too.\n    \"\"\"\n    with open(input_json_path, \"r\") as stream:\n        data = json.load(stream)\n\n    # Change environment variables\n    env = data.get(\"env\") or {}\n\n    # Add AYON_PID_FILE environment variable if pid_file is specified\n    pid_file_path = data.get(\"pid_file\")\n    if pid_file_path:\n        env[\"AYON_PID_FILE\"] = pid_file_path\n\n    for key, value in env.items():\n        os.environ[key] = value\n\n    # Prepare launch arguments\n    args = data[\"args\"]\n    if isinstance(args, list):\n        args = shlex.join(args)\n\n    # Run the command as background process and echo the pid to tempfile\n    with tempfile.NamedTemporaryFile(delete=False) as tmpfile:\n        pid_path = tmpfile.name\n\n    stdout_path = stderr_path = \"/dev/null\"\n    if \"stdout\" in data:\n        stdout_path = data[\"stdout\"]\n\n    if \"stderr\" in data:\n        stderr_path = data[\"stderr\"]\n\n    post_args = []\n    if stdout_path:\n        stdout = f\"&gt;{stdout_path}\"\n        post_args.append(stdout)\n\n    if stderr_path:\n        if stdout_path == stderr_path:\n            stderr_path = \"&amp;1\"\n        stderr = f\"2&gt;{stderr_path}\"\n        post_args.append(stderr)\n\n    post_args_s = \"\"\n    if post_args:\n        joined_args = \" \".join(post_args)\n        post_args_s = f\" {joined_args}\"\n\n    shell_cmd = f\"{args}{post_args_s} &amp; echo $! &gt; {pid_path}\"\n    os.system(shell_cmd)\n\n    with open(pid_path, \"r\") as stream:\n        content = stream.read()\n    os.remove(pid_path)\n\n    try:\n        initial_pid = int(content)\n    except Exception:\n        initial_pid = None\n\n    # Check if shell script provided actual application PID via PID file\n    final_pid = initial_pid\n    if pid_file_path and final_pid is not None:\n        # Wait a short time for shell script to potentially write actual PID\n        time.sleep(0.5)  # Give shell script time to launch app and write PID\n\n        with contextlib.suppress(OSError, ValueError):\n            with open(pid_file_path, \"r\") as pid_file:\n                script_pid_content = pid_file.read().strip()\n                if script_pid_content.isdigit():\n                    script_pid = int(script_pid_content)\n                    # Only use if different from shell PID\n                    if script_pid != final_pid:\n                        final_pid = script_pid\n    data[\"pid\"] = final_pid\n    with open(input_json_path, \"w\") as stream:\n        json.dump(data, stream)\n    sys.exit(0)\n</code></pre>"},{"location":"autoapi/setup.html","title":"setup","text":"<p>Setup info for building AYON Desktop application.</p>"},{"location":"autoapi/start.html","title":"start","text":"<p>Main entry point for AYON command.</p> <p>Bootstrapping process of AYON.</p> <p>This script is responsible for setting up the environment and bootstrapping AYON. It is also responsible for updating AYON from AYON server.</p> Arguments that are always handled by AYON launcher <p>--verbose  - set log level --debug - enable debug mode --skip-headers - skip printing headers --skip-bootstrap - skip bootstrap process - use only for bootstrap logic --use-staging - use staging server --use-dev - use dev server --bundle  - specify bundle name to use --headless - enable headless mode - bootstrap won't show any UI <p>AYON launcher can be running in multiple different states. The top layer of states is 'production', 'staging' and 'dev'.</p> To start in dev mode use one of following options <ul> <li>by passing '--use-dev' argument</li> <li>by setting 'AYON_USE_DEV' environment variable to '1'</li> <li>by passing '--bundle ' <li>by setting 'AYON_BUNDLE_NAME' environment variable to dev bundle name</li> <li>by passing '--studio-bundle ' <li>by setting 'AYON_STUDIO_BUNDLE_NAME' environment variable to dev bundle name</li> By using bundle name you can start any dev bundle, even if is not <p>assigned to current user.</p> <p>To start in staging mode make sure none of develop options are used and then use one of following options:     - by passing '--use-staging' argument     - by setting 'AYON_USE_STAGING' environment variable to '1'</p> <p>Staging mode must be defined explicitly cannot be determined by bundle name. In all other cases AYON launcher will start in 'production' mode.</p> <p>Headless mode is not guaranteed after bootstrap process. It is possible that some addon won't handle headless mode and will try to use UIs.</p> <p>After bootstrap process AYON launcher will start 'ayon_core' addon. This addon is responsible for handling all other addons and their logic.</p> Environment variables set during bootstrap <ul> <li>AYON_VERSION - version of AYON launcher</li> <li>AYON_BUNDLE_NAME - name of bundle to use</li> <li>AYON_USE_STAGING - set to '1' if staging mode is enabled</li> <li>AYON_USE_DEV - set to '1' if dev mode is enabled</li> <li>AYON_DEBUG - set to '1' if debug mode is enabled</li> <li>AYON_HEADLESS_MODE - set to '1' if headless mode is enabled</li> <li>AYON_SERVER_URL - URL of AYON server</li> <li>AYON_API_KEY - API key for AYON server</li> <li>AYON_SERVER_TIMEOUT - timeout for AYON server</li> <li>AYON_SERVER_RETRIES - number of retries for AYON server</li> <li>AYON_EXECUTABLE - path to AYON executable</li> <li>AYON_ROOT - path to AYON root directory</li> <li>AYON_MENU_LABEL - label for AYON integrations menu</li> <li>AYON_LAUNCHER_STORAGE_DIR - dir where addons, dependency packages,     shim etc. are stored</li> <li>AYON_LAUNCHER_LOCAL_DIR - dir where machine specific files are stored</li> <li>AYON_ADDONS_DIR - path to AYON addons directory</li> <li>AYON_DEPENDENCIES_DIR - path to AYON dependencies directory</li> </ul> <p>Some of the environment variables are not in this script but in 'ayon_common' module. - Function 'create_global_connection' can change 'AYON_USE_DEV' and     'AYON_USE_STAGING'. - Bootstrap will set 'AYON_LAUNCHER_STORAGE_DIR' and 'AYON_LAUNCHER_LOCAL_DIR'     if are not set yet. - Distribution logic can set 'AYON_ADDONS_DIR' and 'AYON_DEPENDENCIES_DIR'     if are not set yet.</p>"},{"location":"autoapi/start.html#start.StartArgScript","title":"<code>StartArgScript</code>","text":"Source code in <code>start.py</code> <pre><code>class StartArgScript:\n    def __init__(self, argument, script_path):\n        self.argument = argument\n        self.script_path = script_path\n\n    @property\n    def is_valid(self):\n        return self.script_path is not None\n\n    @property\n    def is_dir(self):\n        if self.argument:\n            return os.path.isdir(self.argument)\n        return False\n\n    @classmethod\n    def from_args(cls, args):\n        \"\"\"Get path argument from args and check if they can be started.\n\n        Args:\n            args (Iterable[str]): Arguments passed to AYON.\n\n        Returns:\n            StartArgScript: Object containing argument and script path.\n        \"\"\"\n\n        if len(args) &lt; 2:\n            return cls(None, None)\n        path = args[1]\n        if os.path.exists(path):\n            if os.path.isdir(path):\n                new_path = os.path.join(path, \"__main__.py\")\n                if os.path.exists(new_path):\n                    return cls(path, new_path)\n            else:\n                path_ext = os.path.splitext(path)[1].lower()\n                if path_ext in (\".py\", \".pyd\", \".pyw\", \".pyc\"):\n                    return cls(path, path)\n        return cls(path, None)\n</code></pre>"},{"location":"autoapi/start.html#start.StartArgScript.from_args","title":"<code>from_args(args)</code>  <code>classmethod</code>","text":"<p>Get path argument from args and check if they can be started.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Iterable[str]</code> <p>Arguments passed to AYON.</p> required <p>Returns:</p> Name Type Description <code>StartArgScript</code> <p>Object containing argument and script path.</p> Source code in <code>start.py</code> <pre><code>@classmethod\ndef from_args(cls, args):\n    \"\"\"Get path argument from args and check if they can be started.\n\n    Args:\n        args (Iterable[str]): Arguments passed to AYON.\n\n    Returns:\n        StartArgScript: Object containing argument and script path.\n    \"\"\"\n\n    if len(args) &lt; 2:\n        return cls(None, None)\n    path = args[1]\n    if os.path.exists(path):\n        if os.path.isdir(path):\n            new_path = os.path.join(path, \"__main__.py\")\n            if os.path.exists(new_path):\n                return cls(path, new_path)\n        else:\n            path_ext = os.path.splitext(path)[1].lower()\n            if path_ext in (\".py\", \".pyd\", \".pyw\", \".pyc\"):\n                return cls(path, path)\n    return cls(path, None)\n</code></pre>"},{"location":"autoapi/start.html#start.boot","title":"<code>boot()</code>","text":"<p>Bootstrap AYON launcher.</p> Source code in <code>start.py</code> <pre><code>def boot():\n    \"\"\"Bootstrap AYON launcher.\"\"\"\n    init_launcher_executable()\n\n    # Setup site id in environment variable for all possible subprocesses\n    if SITE_ID_ENV_KEY not in os.environ:\n        os.environ[SITE_ID_ENV_KEY] = get_local_site_id()\n\n    _connect_to_ayon_server()\n    create_global_connection()\n    _start_distribution()\n    fill_pythonpath()\n\n    # Call launcher storage dir getters to make sure their\n    #   env variables are set\n    get_launcher_local_dir()\n    get_launcher_storage_dir()\n</code></pre>"},{"location":"autoapi/start.html#start.fill_pythonpath","title":"<code>fill_pythonpath()</code>","text":"<p>Fill 'sys.path' with paths from PYTHONPATH environment variable.</p> Source code in <code>start.py</code> <pre><code>def fill_pythonpath():\n    \"\"\"Fill 'sys.path' with paths from PYTHONPATH environment variable.\"\"\"\n    lookup_set = set(sys.path)\n    for path in (os.getenv(\"PYTHONPATH\") or \"\").split(os.pathsep):\n        if path not in lookup_set:\n            sys.path.append(path)\n            lookup_set.add(path)\n</code></pre>"},{"location":"autoapi/start.html#start.get_info","title":"<code>get_info(use_staging=None, use_dev=None)</code>","text":"<p>Print additional information to console.</p> Source code in <code>start.py</code> <pre><code>def get_info(use_staging=None, use_dev=None) -&gt; list:\n    \"\"\"Print additional information to console.\"\"\"\n\n    inf = []\n    studio_bundle_name = os.getenv(\"AYON_STUDIO_BUNDLE_NAME\")\n    project_bundle_name = os.getenv(\"AYON_BUNDLE_NAME\")\n\n    variant = \"production\"\n    if use_dev:\n        variant = f\"dev ({project_bundle_name})\"\n    elif use_staging:\n        variant = \"staging\"\n    inf.append((\"AYON variant\", variant))\n    inf.append((\"AYON studio bundle\", studio_bundle_name))\n    if project_bundle_name == studio_bundle_name:\n        project_bundle_name = \"None\"\n    inf.append((\"AYON project bundle\", project_bundle_name))\n\n    # NOTE add addons information\n\n    maximum = max(len(i[0]) for i in inf)\n    formatted = []\n    for info in inf:\n        padding = (maximum - len(info[0])) + 1\n        formatted.append(f'... {info[0]}:{\" \" * padding}[ {info[1]} ]')\n    return formatted\n</code></pre>"},{"location":"autoapi/start.html#start.init_launcher_executable","title":"<code>init_launcher_executable(ensure_protocol_is_registered=False)</code>","text":"<p>Initialize AYON launcher executable.</p> <p>Make sure current AYON launcher executable is stored to known executables     and shim is deployed.</p> Source code in <code>start.py</code> <pre><code>def init_launcher_executable(ensure_protocol_is_registered=False):\n    \"\"\"Initialize AYON launcher executable.\n\n    Make sure current AYON launcher executable is stored to known executables\n        and shim is deployed.\n\n    \"\"\"\n    create_desktop_icons = \"--create-desktop-icons\" in sys.argv\n    store_current_executable_info()\n    deploy_ayon_launcher_shims(\n        ensure_protocol_is_registered=ensure_protocol_is_registered,\n        create_desktop_icons=create_desktop_icons,\n    )\n</code></pre>"},{"location":"autoapi/start.html#start.main_cli","title":"<code>main_cli()</code>","text":"<p>Main startup logic.</p> <p>This is the main entry point for the AYON launcher. At this moment is fully dependent on 'ayon_core' addon. Which means it contains more logic than it should.</p> Source code in <code>start.py</code> <pre><code>def main_cli():\n    \"\"\"Main startup logic.\n\n    This is the main entry point for the AYON launcher. At this\n    moment is fully dependent on 'ayon_core' addon. Which means it\n    contains more logic than it should.\n    \"\"\"\n    try:\n        import ayon_core  # noqa F401\n    except ModuleNotFoundError:\n        _on_main_addon_missing()\n\n    try:\n        from ayon_core import cli\n    except ImportError as exc:\n        traceback.print_exception(*sys.exc_info())\n        _on_main_addon_import_error(exc)\n\n    # print info when not running scripts defined in 'silent commands'\n    if not SKIP_HEADERS:\n        info = get_info(is_staging_enabled(), is_dev_mode_enabled())\n        info.insert(0, f\"&gt;&gt;&gt; Using AYON from [ {AYON_ROOT} ]\")\n\n        try:\n            t_width = os.get_terminal_size().columns - 2\n        except (ValueError, OSError):\n            t_width = 20\n\n        _header = f\"*** AYON [{__version__}] \"\n        info.insert(0, _header + \"-\" * (t_width - len(_header)))\n\n        for i in info:\n            _print(i)\n\n    try:\n        cli.main()\n    except Exception:  # noqa\n        exc_info = sys.exc_info()\n        _print(\"!!! AYON crashed:\")\n        traceback.print_exception(*exc_info)\n        sys.exit(1)\n</code></pre>"},{"location":"autoapi/start.html#start.script_cli","title":"<code>script_cli(start_arg=None)</code>","text":"<p>Run and execute script.</p> Source code in <code>start.py</code> <pre><code>def script_cli(start_arg=None):\n    \"\"\"Run and execute script.\"\"\"\n\n    if start_arg is None:\n        start_arg = StartArgScript.from_args(sys.argv)\n\n    # Remove first argument from sys.argv\n    # - start.py when running from code\n    # - ayon executable when running from build\n    sys.argv.pop(0)\n\n    # Find '__main__.py' in directory\n    if not start_arg.is_valid:\n        if not start_arg.argument:\n            raise RuntimeError(\"No script to run\")\n\n        if start_arg.is_dir:\n            raise RuntimeError(\n                f\"Can't find '__main__' module in '{start_arg.argument}'\")\n        raise RuntimeError(f\"Can't find script to run '{start_arg.argument}'\")\n    filepath = start_arg.script_path\n\n    # Add parent dir to sys path\n    sys.path.insert(0, os.path.dirname(filepath))\n\n    # Read content and execute\n    with open(filepath, \"r\") as stream:\n        content = stream.read()\n\n    script_globals = dict(globals())\n    script_globals[\"__file__\"] = filepath\n    exec(compile(content, filepath, \"exec\"), script_globals)\n</code></pre>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>app_launcher</li> <li>common<ul> <li>ayon_common<ul> <li>_windows_register_scheme</li> <li>connection<ul> <li>credentials</li> <li>ui<ul> <li>__main__</li> <li>invalid_window</li> <li>login_window</li> <li>server</li> <li>widgets</li> </ul> </li> </ul> </li> <li>distribution<ul> <li>control</li> <li>data_structures</li> <li>downloaders</li> <li>exceptions</li> <li>file_handler</li> <li>ui<ul> <li>distribution_error</li> <li>missing_bundle_window</li> <li>update_window</li> </ul> </li> <li>utils</li> </ul> </li> <li>resources</li> <li>startup<ul> <li>ui<ul> <li>startup_error</li> </ul> </li> </ul> </li> <li>ui_utils</li> <li>utils</li> </ul> </li> </ul> </li> <li>setup</li> <li>shim<ul> <li>macos_start</li> <li>setup</li> <li>shim_start</li> </ul> </li> <li>start</li> <li>version</li> </ul>"},{"location":"autoapi/version.html","title":"version","text":""},{"location":"autoapi/common/ayon_common/index.html","title":"ayon_common","text":""},{"location":"autoapi/common/ayon_common/index.html#common.ayon_common.calculate_file_checksum","title":"<code>calculate_file_checksum(filepath, checksum_algorithm, chunk_size=10000)</code>","text":"<p>Calculate file checksum for given algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to a file.</p> required <code>checksum_algorithm</code> <code>str</code> <p>Algorithm to use. ('md5', 'sha1', 'sha256')</p> required <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size to read file. Defaults to 10000.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Calculated checksum.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>File not found or unknown checksum algorithm.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def calculate_file_checksum(\n    filepath: str, checksum_algorithm: str, chunk_size: Optional[int]=10000\n):\n    \"\"\"Calculate file checksum for given algorithm.\n\n    Args:\n        filepath (str): Path to a file.\n        checksum_algorithm (str): Algorithm to use. ('md5', 'sha1', 'sha256')\n        chunk_size (Optional[int]): Chunk size to read file.\n            Defaults to 10000.\n\n    Returns:\n        str: Calculated checksum.\n\n    Raises:\n        ValueError: File not found or unknown checksum algorithm.\n\n    \"\"\"\n    import hashlib\n\n    if not filepath:\n        raise ValueError(\"Filepath is empty.\")\n\n    if not os.path.exists(filepath):\n        raise ValueError(\"{} doesn't exist.\".format(filepath))\n\n    if not os.path.isfile(filepath):\n        raise ValueError(\"{} is not a file.\".format(filepath))\n\n    func = getattr(hashlib, checksum_algorithm, None)\n    if func is None:\n        raise ValueError(\n            \"Unknown checksum algorithm '{}'\".format(checksum_algorithm))\n\n    hash_obj = func()\n    with open(filepath, \"rb\") as f:\n        for chunk in iter(lambda: f.read(chunk_size), b\"\"):\n            hash_obj.update(chunk)\n    return hash_obj.hexdigest()\n</code></pre>"},{"location":"autoapi/common/ayon_common/index.html#common.ayon_common.extract_archive_file","title":"<code>extract_archive_file(archive_file, dst_folder=None)</code>","text":"<p>Extract archived file to a directory.</p> <p>Parameters:</p> Name Type Description Default <code>archive_file</code> <code>str</code> <p>Path to a archive file.</p> required <code>dst_folder</code> <code>Optional[str]</code> <p>Directory where content will be extracted. By default, same folder where archive file is.</p> <code>None</code> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def extract_archive_file(archive_file: str, dst_folder: Optional[str] = None):\n    \"\"\"Extract archived file to a directory.\n\n    Args:\n        archive_file (str): Path to a archive file.\n        dst_folder (Optional[str]): Directory where content will be extracted.\n            By default, same folder where archive file is.\n\n    \"\"\"\n    if not dst_folder:\n        dst_folder = os.path.dirname(archive_file)\n\n    archive_ext, archive_type = get_archive_ext_and_type(archive_file)\n\n    print(\"Extracting {} -&gt; {}\".format(archive_file, dst_folder))\n    if archive_type is None:\n        _, ext = os.path.splitext(archive_file)\n        raise ValueError((\n            f\"Invalid file extension \\\"{ext}\\\".\"\n            f\" Expected {', '.join(IMPLEMENTED_ARCHIVE_FORMATS)}\"\n        ))\n\n    if archive_type == \"zip\":\n        zip_file = ZipFileLongPaths(archive_file)\n        try:\n            zip_file.extractall(dst_folder)\n        finally:\n            zip_file.close()\n\n    elif archive_type == \"tar\":\n        if archive_ext == \".tar\":\n            tar_type = \"r:\"\n        elif archive_ext.endswith(\".xz\"):\n            tar_type = \"r:xz\"\n        elif archive_ext.endswith(\".gz\"):\n            tar_type = \"r:gz\"\n        elif archive_ext.endswith(\".bz2\"):\n            tar_type = \"r:bz2\"\n        else:\n            tar_type = \"r:*\"\n\n        try:\n            tar_file = tarfile.open(archive_file, tar_type)\n        except tarfile.ReadError:\n            raise SystemExit(\"corrupted archive\")\n\n        try:\n            tar_file.extractall(dst_folder)\n        finally:\n            tar_file.close()\n</code></pre>"},{"location":"autoapi/common/ayon_common/index.html#common.ayon_common.get_archive_ext_and_type","title":"<code>get_archive_ext_and_type(archive_file)</code>","text":"<p>Get archive extension and type.</p> <p>Parameters:</p> Name Type Description Default <code>archive_file</code> <code>str</code> <p>Path to archive file.</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[str]]</code> <p>Tuple[str, str]: Archive extension and type.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_archive_ext_and_type(\n    archive_file: str\n) -&gt; Tuple[Optional[str], Optional[str]]:\n    \"\"\"Get archive extension and type.\n\n    Args:\n        archive_file (str): Path to archive file.\n\n    Returns:\n        Tuple[str, str]: Archive extension and type.\n\n    \"\"\"\n    tmp_name = archive_file.lower()\n    if tmp_name.endswith(\".zip\"):\n        return \".zip\", \"zip\"\n\n    for ext in (\n        \".tar\",\n        \".tgz\",\n        \".tar.gz\",\n        \".tar.xz\",\n        \".tar.bz2\",\n    ):\n        if tmp_name.endswith(ext):\n            return ext, \"tar\"\n\n    return None, None\n</code></pre>"},{"location":"autoapi/common/ayon_common/index.html#common.ayon_common.get_ayon_appdirs","title":"<code>get_ayon_appdirs(*args)</code>","text":"<p>Local app data directory of AYON launcher.</p> Deprecated <p>The function was replaced with 'get_launcher_local_dir'     or 'get_launcher_storage_dir' based on usage. Deprecated since 1.1.0 .</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Iterable[str]</code> <p>Subdirectories/files in local app data dir.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Path to directory/file in local app data dir.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_ayon_appdirs(*args):\n    \"\"\"Local app data directory of AYON launcher.\n\n    Deprecated:\n        The function was replaced with 'get_launcher_local_dir'\n            or 'get_launcher_storage_dir' based on usage.\n        Deprecated since 1.1.0 .\n\n    Args:\n        *args (Iterable[str]): Subdirectories/files in local app data dir.\n\n    Returns:\n        str: Path to directory/file in local app data dir.\n\n    \"\"\"\n    warnings.warn(\n        (\n            \"Function 'get_ayon_appdirs' is deprecated. Should be replaced\"\n            \" with 'get_launcher_local_dir' or 'get_launcher_storage_dir'\"\n            \" based on use-case.\"\n        ),\n        DeprecationWarning\n    )\n    return _get_ayon_appdirs(*args)\n</code></pre>"},{"location":"autoapi/common/ayon_common/index.html#common.ayon_common.get_ayon_launch_args","title":"<code>get_ayon_launch_args(*args)</code>","text":"<p>Launch arguments that can be used to launch ayon process.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>str</code> <p>Additional arguments.</p> <code>()</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str]: Launch arguments.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_ayon_launch_args(*args: str) -&gt; List[str]:\n    \"\"\"Launch arguments that can be used to launch ayon process.\n\n    Args:\n        *args (str): Additional arguments.\n\n    Returns:\n        list[str]: Launch arguments.\n\n    \"\"\"\n    output = [sys.executable]\n    if not IS_BUILT_APPLICATION:\n        output.append(os.path.join(os.environ[\"AYON_ROOT\"], \"start.py\"))\n    output.extend(args)\n    return output\n</code></pre>"},{"location":"autoapi/common/ayon_common/index.html#common.ayon_common.get_downloads_dir","title":"<code>get_downloads_dir()</code>","text":"<p>Downloads directory path.</p> <p>Each platform may use different approach how the downloads directory is received. This function will try to find the directory and return it.</p> <p>Returns:</p> Type Description <code>str</code> <p>Union[str, None]: Path to downloads directory or None if not found.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_downloads_dir() -&gt; str:\n    \"\"\"Downloads directory path.\n\n    Each platform may use different approach how the downloads directory is\n    received. This function will try to find the directory and return it.\n\n    Returns:\n        Union[str, None]: Path to downloads directory or None if not found.\n\n    \"\"\"\n    if _Cache.downloads_dir != 0:\n        return _Cache.downloads_dir\n\n    path = None\n    try:\n        platform_name = platform.system().lower()\n        if platform_name == \"linux\":\n            path = _get_linux_downloads_dir()\n        elif platform_name == \"windows\":\n            path = _get_windows_downloads_dir()\n        elif platform_name == \"darwin\":\n            path = _get_macos_downloads_dir()\n\n    except Exception:\n        pass\n\n    if path is None:\n        default = os.path.expanduser(\"~/Downloads\")\n        if os.path.exists(default):\n            path = default\n\n    _Cache.downloads_dir = path\n    return path\n</code></pre>"},{"location":"autoapi/common/ayon_common/index.html#common.ayon_common.get_launcher_local_dir","title":"<code>get_launcher_local_dir(*subdirs, create=False)</code>","text":"<p>Get local directory for launcher.</p> <p>Local directory is used for storing machine or user specific data.</p> <p>The location is user specific.</p> Note <p>This function should be called at least once on bootstrap.</p> <p>Parameters:</p> Name Type Description Default <code>*subdirs</code> <code>str</code> <p>Subdirectories relative to local dir.</p> <code>()</code> <code>create</code> <code>Optional[bool]</code> <p>Create the folder if it does not exist.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to local directory.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_launcher_local_dir(\n    *subdirs: str,\n    create: Optional[bool] = False\n) -&gt; str:\n    \"\"\"Get local directory for launcher.\n\n    Local directory is used for storing machine or user specific data.\n\n    The location is user specific.\n\n    Note:\n        This function should be called at least once on bootstrap.\n\n    Args:\n        *subdirs (str): Subdirectories relative to local dir.\n        create (Optional[bool]): Create the folder if it does not exist.\n\n    Returns:\n        str: Path to local directory.\n\n    \"\"\"\n    storage_dir = os.getenv(\"AYON_LAUNCHER_LOCAL_DIR\")\n    if not storage_dir:\n        storage_dir = _get_ayon_appdirs()\n        os.environ[\"AYON_LAUNCHER_LOCAL_DIR\"] = storage_dir\n\n    path = os.path.join(storage_dir, *subdirs)\n    if create:\n        os.makedirs(path, exist_ok=True)\n    return path\n</code></pre>"},{"location":"autoapi/common/ayon_common/index.html#common.ayon_common.get_launcher_storage_dir","title":"<code>get_launcher_storage_dir(*subdirs, create=False)</code>","text":"<p>Get storage directory for launcher.</p> <p>Storage directory is used for storing shims, addons, dependencies, etc.</p> <p>It is not recommended, but the location can be shared across     multiple machines.</p> Note <p>This function should be called at least once on bootstrap.</p> <p>Parameters:</p> Name Type Description Default <code>*subdirs</code> <code>str</code> <p>Subdirectories relative to storage dir.</p> <code>()</code> <code>create</code> <code>Optional[bool]</code> <p>Create the folder if it does not exist.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to storage directory.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_launcher_storage_dir(\n    *subdirs: str,\n    create: Optional[bool] = False\n) -&gt; str:\n    \"\"\"Get storage directory for launcher.\n\n    Storage directory is used for storing shims, addons, dependencies, etc.\n\n    It is not recommended, but the location can be shared across\n        multiple machines.\n\n    Note:\n        This function should be called at least once on bootstrap.\n\n    Args:\n        *subdirs (str): Subdirectories relative to storage dir.\n        create (Optional[bool]): Create the folder if it does not exist.\n\n    Returns:\n        str: Path to storage directory.\n\n    \"\"\"\n    storage_dir = os.getenv(\"AYON_LAUNCHER_STORAGE_DIR\")\n    if not storage_dir:\n        storage_dir = _get_ayon_appdirs()\n        os.environ[\"AYON_LAUNCHER_STORAGE_DIR\"] = storage_dir\n\n    path = os.path.join(storage_dir, *subdirs)\n    if create and not os.path.exists(path):\n        os.makedirs(path, exist_ok=True)\n    return path\n</code></pre>"},{"location":"autoapi/common/ayon_common/index.html#common.ayon_common.get_local_site_id","title":"<code>get_local_site_id()</code>","text":"<p>Get local site identifier.</p> <p>Site id is created if does not exist yet.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Site id.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_local_site_id() -&gt; str:\n    \"\"\"Get local site identifier.\n\n    Site id is created if does not exist yet.\n\n    Returns:\n        str: Site id.\n\n    \"\"\"\n    # used for background syncing\n    site_id = os.environ.get(SITE_ID_ENV_KEY)\n    if site_id:\n        return site_id\n\n    site_id_path = get_launcher_local_dir(\"site_id\")\n    if os.path.exists(site_id_path):\n        with open(site_id_path, \"r\") as stream:\n            site_id = stream.read()\n\n    if not site_id:\n        os.makedirs(os.path.dirname(site_id_path), exist_ok=True)\n        site_id = _create_local_site_id()\n        with open(site_id_path, \"w\") as stream:\n            stream.write(site_id)\n    return site_id\n</code></pre>"},{"location":"autoapi/common/ayon_common/index.html#common.ayon_common.is_dev_mode_enabled","title":"<code>is_dev_mode_enabled()</code>","text":"<p>Check if dev is enabled.</p> <p>A dev bundle is used when dev is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Dev is enabled.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def is_dev_mode_enabled() -&gt; bool:\n    \"\"\"Check if dev is enabled.\n\n    A dev bundle is used when dev is enabled.\n\n    Returns:\n        bool: Dev is enabled.\n\n    \"\"\"\n    return os.getenv(\"AYON_USE_DEV\") == \"1\"\n</code></pre>"},{"location":"autoapi/common/ayon_common/index.html#common.ayon_common.is_staging_enabled","title":"<code>is_staging_enabled()</code>","text":"<p>Check if staging is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if staging is enabled.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def is_staging_enabled() -&gt; bool:\n    \"\"\"Check if staging is enabled.\n\n    Returns:\n        bool: True if staging is enabled.\n\n    \"\"\"\n    return os.getenv(\"AYON_USE_STAGING\") == \"1\"\n</code></pre>"},{"location":"autoapi/common/ayon_common/index.html#common.ayon_common.validate_file_checksum","title":"<code>validate_file_checksum(filepath, checksum, checksum_algorithm)</code>","text":"<p>Validate file checksum.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to file.</p> required <code>checksum</code> <code>str</code> <p>Hash of file.</p> required <code>checksum_algorithm</code> <code>str</code> <p>Type of checksum.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Hash is valid/invalid.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>File not found or unknown checksum algorithm.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def validate_file_checksum(\n    filepath: str, checksum: str, checksum_algorithm: str\n) -&gt; bool:\n    \"\"\"Validate file checksum.\n\n    Args:\n        filepath (str): Path to file.\n        checksum (str): Hash of file.\n        checksum_algorithm (str): Type of checksum.\n\n    Returns:\n        bool: Hash is valid/invalid.\n\n    Raises:\n        ValueError: File not found or unknown checksum algorithm.\n\n    \"\"\"\n    return checksum == calculate_file_checksum(filepath, checksum_algorithm)\n</code></pre>"},{"location":"autoapi/common/ayon_common/_windows_register_scheme.html","title":"_windows_register_scheme","text":""},{"location":"autoapi/common/ayon_common/ui_utils.html","title":"ui_utils","text":""},{"location":"autoapi/common/ayon_common/ui_utils.html#common.ayon_common.ui_utils.set_style_property","title":"<code>set_style_property(widget, property_name, property_value)</code>","text":"<p>Set widget's property that may affect style.</p> <p>Style of widget is polished if current property value is different.</p> Source code in <code>common/ayon_common/ui_utils.py</code> <pre><code>def set_style_property(widget, property_name, property_value):\n    \"\"\"Set widget's property that may affect style.\n\n    Style of widget is polished if current property value is different.\n    \"\"\"\n\n    cur_value = widget.property(property_name)\n    if cur_value == property_value:\n        return\n    widget.setProperty(property_name, property_value)\n    widget.style().polish(widget)\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html","title":"utils","text":""},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.ZipFileLongPaths","title":"<code>ZipFileLongPaths</code>","text":"<p>               Bases: <code>ZipFile</code></p> <p>Allows longer paths in zip files.</p> <p>Regular DOS paths are limited to MAX_PATH (260) characters, including the string's terminating NUL character. That limit can be exceeded by using an extended-length path that starts with the '\\?' prefix.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>class ZipFileLongPaths(zipfile.ZipFile):\n    \"\"\"Allows longer paths in zip files.\n\n    Regular DOS paths are limited to MAX_PATH (260) characters, including\n    the string's terminating NUL character.\n    That limit can be exceeded by using an extended-length path that\n    starts with the '\\\\?\\' prefix.\n    \"\"\"\n    _is_windows = platform.system().lower() == \"windows\"\n\n    def _extract_member(self, member, tpath, pwd):\n        if self._is_windows:\n            tpath = os.path.abspath(tpath)\n            if tpath.startswith(\"\\\\\\\\\"):\n                tpath = \"\\\\\\\\?\\\\UNC\\\\\" + tpath[2:]\n            else:\n                tpath = \"\\\\\\\\?\\\\\" + tpath\n\n        return super()._extract_member(member, tpath, pwd)\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.calculate_file_checksum","title":"<code>calculate_file_checksum(filepath, checksum_algorithm, chunk_size=10000)</code>","text":"<p>Calculate file checksum for given algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to a file.</p> required <code>checksum_algorithm</code> <code>str</code> <p>Algorithm to use. ('md5', 'sha1', 'sha256')</p> required <code>chunk_size</code> <code>Optional[int]</code> <p>Chunk size to read file. Defaults to 10000.</p> <code>10000</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Calculated checksum.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>File not found or unknown checksum algorithm.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def calculate_file_checksum(\n    filepath: str, checksum_algorithm: str, chunk_size: Optional[int]=10000\n):\n    \"\"\"Calculate file checksum for given algorithm.\n\n    Args:\n        filepath (str): Path to a file.\n        checksum_algorithm (str): Algorithm to use. ('md5', 'sha1', 'sha256')\n        chunk_size (Optional[int]): Chunk size to read file.\n            Defaults to 10000.\n\n    Returns:\n        str: Calculated checksum.\n\n    Raises:\n        ValueError: File not found or unknown checksum algorithm.\n\n    \"\"\"\n    import hashlib\n\n    if not filepath:\n        raise ValueError(\"Filepath is empty.\")\n\n    if not os.path.exists(filepath):\n        raise ValueError(\"{} doesn't exist.\".format(filepath))\n\n    if not os.path.isfile(filepath):\n        raise ValueError(\"{} is not a file.\".format(filepath))\n\n    func = getattr(hashlib, checksum_algorithm, None)\n    if func is None:\n        raise ValueError(\n            \"Unknown checksum algorithm '{}'\".format(checksum_algorithm))\n\n    hash_obj = func()\n    with open(filepath, \"rb\") as f:\n        for chunk in iter(lambda: f.read(chunk_size), b\"\"):\n            hash_obj.update(chunk)\n    return hash_obj.hexdigest()\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.cleanup_executables_info","title":"<code>cleanup_executables_info()</code>","text":"<p>Remove executables that do not exist anymore.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def cleanup_executables_info():\n    \"\"\"Remove executables that do not exist anymore.\"\"\"\n\n    info = get_executables_info(check_cleanup=False)\n    available_versions = info.setdefault(\"available_versions\", [])\n\n    new_executables = []\n    for item in available_versions:\n        executable = item.get(\"executable\")\n        if not executable or not os.path.exists(executable):\n            continue\n\n        version = load_executable_version(executable)\n        if version and item.get(\"version\") != version:\n            item[\"version\"] = version\n        new_executables.append(item)\n\n    info[\"available_versions\"] = new_executables\n    info[\"last_cleanup\"] = {\n        \"value\": datetime.datetime.now().strftime(DATE_FMT),\n        \"fmt\": DATE_FMT,\n    }\n    store_executables_info(info)\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.deploy_ayon_launcher_shims","title":"<code>deploy_ayon_launcher_shims(ensure_protocol_is_registered=False, create_desktop_icons=False)</code>","text":"<p>Deploy shim executables for AYON launcher.</p> <p>Argument 'validate_registers' is to fix registered protocol on Windows,     issue caused in v1.1.0, since 1.1.1 is used different registry path.</p> <p>Parameters:</p> Name Type Description Default <code>ensure_protocol_is_registered</code> <code>bool</code> <p>Validate if protocol is registered on windows.</p> <code>False</code> <code>create_desktop_icons</code> <code>bool</code> <p>Create desktop shortcuts. Used only on windows.</p> <code>False</code> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def deploy_ayon_launcher_shims(\n    ensure_protocol_is_registered: bool = False,\n    create_desktop_icons: bool = False,\n):\n    \"\"\"Deploy shim executables for AYON launcher.\n\n    Argument 'validate_registers' is to fix registered protocol on Windows,\n        issue caused in v1.1.0, since 1.1.1 is used different registry path.\n\n    Args:\n        ensure_protocol_is_registered (bool): Validate if protocol is\n            registered on windows.\n        create_desktop_icons (bool): Create desktop shortcuts. Used\n            only on windows.\n\n    \"\"\"\n    if not IS_BUILT_APPLICATION:\n        return\n\n    # Validate platform name\n    platform_name = platform.system().lower()\n    if platform_name not in (\"windows\", \"linux\", \"darwin\"):\n        raise ValueError(\"Unsupported platform {}\".format(platform_name))\n\n    executable_root = os.path.dirname(sys.executable)\n    installer_shim_root = os.path.join(executable_root, \"shim\")\n\n    with open(os.path.join(installer_shim_root, \"shim.json\"), \"r\") as stream:\n        shim_data = json.load(stream)\n\n    src_shim_version = semver.VersionInfo.parse(shim_data[\"version\"])\n\n    # Read existing shim version (if there is any)\n    dst_shim_version = _get_installed_shim_version()\n\n    # Skip if shim is same or lower\n    if src_shim_version &lt;= semver.VersionInfo.parse(dst_shim_version):\n        # Make sure windows registers are correctly set for each user\n        if ensure_protocol_is_registered:\n            register_ayon_launcher_protocol()\n        if platform_name == \"windows\" and create_desktop_icons:\n            _create_windows_shortcut()\n        return\n\n    platform_name = platform.system().lower()\n    if platform_name == \"windows\":\n        _deploy_shim_windows(\n            installer_shim_root,\n            create_desktop_icons,\n        )\n\n    elif platform_name == \"linux\":\n        _deploy_shim_linux(installer_shim_root)\n\n    elif platform_name == \"darwin\":\n        _deploy_shim_macos(installer_shim_root)\n    register_ayon_launcher_protocol()\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.extract_archive_file","title":"<code>extract_archive_file(archive_file, dst_folder=None)</code>","text":"<p>Extract archived file to a directory.</p> <p>Parameters:</p> Name Type Description Default <code>archive_file</code> <code>str</code> <p>Path to a archive file.</p> required <code>dst_folder</code> <code>Optional[str]</code> <p>Directory where content will be extracted. By default, same folder where archive file is.</p> <code>None</code> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def extract_archive_file(archive_file: str, dst_folder: Optional[str] = None):\n    \"\"\"Extract archived file to a directory.\n\n    Args:\n        archive_file (str): Path to a archive file.\n        dst_folder (Optional[str]): Directory where content will be extracted.\n            By default, same folder where archive file is.\n\n    \"\"\"\n    if not dst_folder:\n        dst_folder = os.path.dirname(archive_file)\n\n    archive_ext, archive_type = get_archive_ext_and_type(archive_file)\n\n    print(\"Extracting {} -&gt; {}\".format(archive_file, dst_folder))\n    if archive_type is None:\n        _, ext = os.path.splitext(archive_file)\n        raise ValueError((\n            f\"Invalid file extension \\\"{ext}\\\".\"\n            f\" Expected {', '.join(IMPLEMENTED_ARCHIVE_FORMATS)}\"\n        ))\n\n    if archive_type == \"zip\":\n        zip_file = ZipFileLongPaths(archive_file)\n        try:\n            zip_file.extractall(dst_folder)\n        finally:\n            zip_file.close()\n\n    elif archive_type == \"tar\":\n        if archive_ext == \".tar\":\n            tar_type = \"r:\"\n        elif archive_ext.endswith(\".xz\"):\n            tar_type = \"r:xz\"\n        elif archive_ext.endswith(\".gz\"):\n            tar_type = \"r:gz\"\n        elif archive_ext.endswith(\".bz2\"):\n            tar_type = \"r:bz2\"\n        else:\n            tar_type = \"r:*\"\n\n        try:\n            tar_file = tarfile.open(archive_file, tar_type)\n        except tarfile.ReadError:\n            raise SystemExit(\"corrupted archive\")\n\n        try:\n            tar_file.extractall(dst_folder)\n        finally:\n            tar_file.close()\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.get_archive_ext_and_type","title":"<code>get_archive_ext_and_type(archive_file)</code>","text":"<p>Get archive extension and type.</p> <p>Parameters:</p> Name Type Description Default <code>archive_file</code> <code>str</code> <p>Path to archive file.</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[str], Optional[str]]</code> <p>Tuple[str, str]: Archive extension and type.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_archive_ext_and_type(\n    archive_file: str\n) -&gt; Tuple[Optional[str], Optional[str]]:\n    \"\"\"Get archive extension and type.\n\n    Args:\n        archive_file (str): Path to archive file.\n\n    Returns:\n        Tuple[str, str]: Archive extension and type.\n\n    \"\"\"\n    tmp_name = archive_file.lower()\n    if tmp_name.endswith(\".zip\"):\n        return \".zip\", \"zip\"\n\n    for ext in (\n        \".tar\",\n        \".tgz\",\n        \".tar.gz\",\n        \".tar.xz\",\n        \".tar.bz2\",\n    ):\n        if tmp_name.endswith(ext):\n            return ext, \"tar\"\n\n    return None, None\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.get_ayon_appdirs","title":"<code>get_ayon_appdirs(*args)</code>","text":"<p>Local app data directory of AYON launcher.</p> Deprecated <p>The function was replaced with 'get_launcher_local_dir'     or 'get_launcher_storage_dir' based on usage. Deprecated since 1.1.0 .</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Iterable[str]</code> <p>Subdirectories/files in local app data dir.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Path to directory/file in local app data dir.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_ayon_appdirs(*args):\n    \"\"\"Local app data directory of AYON launcher.\n\n    Deprecated:\n        The function was replaced with 'get_launcher_local_dir'\n            or 'get_launcher_storage_dir' based on usage.\n        Deprecated since 1.1.0 .\n\n    Args:\n        *args (Iterable[str]): Subdirectories/files in local app data dir.\n\n    Returns:\n        str: Path to directory/file in local app data dir.\n\n    \"\"\"\n    warnings.warn(\n        (\n            \"Function 'get_ayon_appdirs' is deprecated. Should be replaced\"\n            \" with 'get_launcher_local_dir' or 'get_launcher_storage_dir'\"\n            \" based on use-case.\"\n        ),\n        DeprecationWarning\n    )\n    return _get_ayon_appdirs(*args)\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.get_ayon_launch_args","title":"<code>get_ayon_launch_args(*args)</code>","text":"<p>Launch arguments that can be used to launch ayon process.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>str</code> <p>Additional arguments.</p> <code>()</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str]: Launch arguments.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_ayon_launch_args(*args: str) -&gt; List[str]:\n    \"\"\"Launch arguments that can be used to launch ayon process.\n\n    Args:\n        *args (str): Additional arguments.\n\n    Returns:\n        list[str]: Launch arguments.\n\n    \"\"\"\n    output = [sys.executable]\n    if not IS_BUILT_APPLICATION:\n        output.append(os.path.join(os.environ[\"AYON_ROOT\"], \"start.py\"))\n    output.extend(args)\n    return output\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.get_downloads_dir","title":"<code>get_downloads_dir()</code>","text":"<p>Downloads directory path.</p> <p>Each platform may use different approach how the downloads directory is received. This function will try to find the directory and return it.</p> <p>Returns:</p> Type Description <code>str</code> <p>Union[str, None]: Path to downloads directory or None if not found.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_downloads_dir() -&gt; str:\n    \"\"\"Downloads directory path.\n\n    Each platform may use different approach how the downloads directory is\n    received. This function will try to find the directory and return it.\n\n    Returns:\n        Union[str, None]: Path to downloads directory or None if not found.\n\n    \"\"\"\n    if _Cache.downloads_dir != 0:\n        return _Cache.downloads_dir\n\n    path = None\n    try:\n        platform_name = platform.system().lower()\n        if platform_name == \"linux\":\n            path = _get_linux_downloads_dir()\n        elif platform_name == \"windows\":\n            path = _get_windows_downloads_dir()\n        elif platform_name == \"darwin\":\n            path = _get_macos_downloads_dir()\n\n    except Exception:\n        pass\n\n    if path is None:\n        default = os.path.expanduser(\"~/Downloads\")\n        if os.path.exists(default):\n            path = default\n\n    _Cache.downloads_dir = path\n    return path\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.get_executable_paths_by_version","title":"<code>get_executable_paths_by_version(version)</code>","text":"<p>Get executable paths by version.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>list[str]: Paths to executables.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_executable_paths_by_version(version: str) -&gt; List[str]:\n    \"\"\"Get executable paths by version.\n\n    Returns:\n        list[str]: Paths to executables.\n\n    \"\"\"\n    return [\n        item[\"executable\"]\n        for item in get_executables_info_by_version(version, validate=True)\n    ]\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.get_executables_info_by_version","title":"<code>get_executables_info_by_version(version, validate=True)</code>","text":"<p>Get available executable info by version.</p> <p>Parameters:</p> Name Type Description Default <code>version</code> <code>str</code> <p>Version of executable.</p> required <code>validate</code> <code>bool</code> <p>Validate if 'version.py' contains same version.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>list[dict[str, Any]]: Executable info matching version.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_executables_info_by_version(\n    version: str, validate: Optional[bool] = True\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get available executable info by version.\n\n    Args:\n        version (str): Version of executable.\n        validate (bool): Validate if 'version.py' contains same version.\n\n    Returns:\n        list[dict[str, Any]]: Executable info matching version.\n\n    \"\"\"\n    info = get_executables_info()\n    available_versions = info.setdefault(\"available_versions\", [])\n    if validate:\n        _available_versions = []\n        for item in available_versions:\n            executable = item.get(\"executable\")\n            if not executable or not os.path.exists(executable):\n                continue\n\n            executable_version = load_executable_version(executable)\n            if executable_version == version:\n                _available_versions.append(item)\n        available_versions = _available_versions\n    return [\n        item\n        for item in available_versions\n        if item.get(\"version\") == version\n    ]\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.get_executables_info_filepath","title":"<code>get_executables_info_filepath()</code>","text":"<p>Get path to file where information about executables is stored.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to json file where executables info are stored.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_executables_info_filepath() -&gt; str:\n    \"\"\"Get path to file where information about executables is stored.\n\n    Returns:\n        str: Path to json file where executables info are stored.\n\n    \"\"\"\n    return get_launcher_local_dir(\"executables.json\")\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.get_launcher_local_dir","title":"<code>get_launcher_local_dir(*subdirs, create=False)</code>","text":"<p>Get local directory for launcher.</p> <p>Local directory is used for storing machine or user specific data.</p> <p>The location is user specific.</p> Note <p>This function should be called at least once on bootstrap.</p> <p>Parameters:</p> Name Type Description Default <code>*subdirs</code> <code>str</code> <p>Subdirectories relative to local dir.</p> <code>()</code> <code>create</code> <code>Optional[bool]</code> <p>Create the folder if it does not exist.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to local directory.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_launcher_local_dir(\n    *subdirs: str,\n    create: Optional[bool] = False\n) -&gt; str:\n    \"\"\"Get local directory for launcher.\n\n    Local directory is used for storing machine or user specific data.\n\n    The location is user specific.\n\n    Note:\n        This function should be called at least once on bootstrap.\n\n    Args:\n        *subdirs (str): Subdirectories relative to local dir.\n        create (Optional[bool]): Create the folder if it does not exist.\n\n    Returns:\n        str: Path to local directory.\n\n    \"\"\"\n    storage_dir = os.getenv(\"AYON_LAUNCHER_LOCAL_DIR\")\n    if not storage_dir:\n        storage_dir = _get_ayon_appdirs()\n        os.environ[\"AYON_LAUNCHER_LOCAL_DIR\"] = storage_dir\n\n    path = os.path.join(storage_dir, *subdirs)\n    if create:\n        os.makedirs(path, exist_ok=True)\n    return path\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.get_launcher_storage_dir","title":"<code>get_launcher_storage_dir(*subdirs, create=False)</code>","text":"<p>Get storage directory for launcher.</p> <p>Storage directory is used for storing shims, addons, dependencies, etc.</p> <p>It is not recommended, but the location can be shared across     multiple machines.</p> Note <p>This function should be called at least once on bootstrap.</p> <p>Parameters:</p> Name Type Description Default <code>*subdirs</code> <code>str</code> <p>Subdirectories relative to storage dir.</p> <code>()</code> <code>create</code> <code>Optional[bool]</code> <p>Create the folder if it does not exist.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to storage directory.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_launcher_storage_dir(\n    *subdirs: str,\n    create: Optional[bool] = False\n) -&gt; str:\n    \"\"\"Get storage directory for launcher.\n\n    Storage directory is used for storing shims, addons, dependencies, etc.\n\n    It is not recommended, but the location can be shared across\n        multiple machines.\n\n    Note:\n        This function should be called at least once on bootstrap.\n\n    Args:\n        *subdirs (str): Subdirectories relative to storage dir.\n        create (Optional[bool]): Create the folder if it does not exist.\n\n    Returns:\n        str: Path to storage directory.\n\n    \"\"\"\n    storage_dir = os.getenv(\"AYON_LAUNCHER_STORAGE_DIR\")\n    if not storage_dir:\n        storage_dir = _get_ayon_appdirs()\n        os.environ[\"AYON_LAUNCHER_STORAGE_DIR\"] = storage_dir\n\n    path = os.path.join(storage_dir, *subdirs)\n    if create and not os.path.exists(path):\n        os.makedirs(path, exist_ok=True)\n    return path\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.get_local_site_id","title":"<code>get_local_site_id()</code>","text":"<p>Get local site identifier.</p> <p>Site id is created if does not exist yet.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Site id.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_local_site_id() -&gt; str:\n    \"\"\"Get local site identifier.\n\n    Site id is created if does not exist yet.\n\n    Returns:\n        str: Site id.\n\n    \"\"\"\n    # used for background syncing\n    site_id = os.environ.get(SITE_ID_ENV_KEY)\n    if site_id:\n        return site_id\n\n    site_id_path = get_launcher_local_dir(\"site_id\")\n    if os.path.exists(site_id_path):\n        with open(site_id_path, \"r\") as stream:\n            site_id = stream.read()\n\n    if not site_id:\n        os.makedirs(os.path.dirname(site_id_path), exist_ok=True)\n        site_id = _create_local_site_id()\n        with open(site_id_path, \"w\") as stream:\n            stream.write(site_id)\n    return site_id\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.get_shim_executable_path","title":"<code>get_shim_executable_path()</code>","text":"<p>Path to shim executable.</p> <p>It is not validated if shim exists.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path where shim executable should be found.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def get_shim_executable_path() -&gt; str:\n    \"\"\"Path to shim executable.\n\n    It is not validated if shim exists.\n\n    Returns:\n        str: Path where shim executable should be found.\n\n    \"\"\"\n    filename = \"ayon\"\n    if platform.system().lower() == \"windows\":\n        filename += \".exe\"\n    return os.path.join(_get_shim_executable_root(), filename)\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.is_dev_mode_enabled","title":"<code>is_dev_mode_enabled()</code>","text":"<p>Check if dev is enabled.</p> <p>A dev bundle is used when dev is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Dev is enabled.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def is_dev_mode_enabled() -&gt; bool:\n    \"\"\"Check if dev is enabled.\n\n    A dev bundle is used when dev is enabled.\n\n    Returns:\n        bool: Dev is enabled.\n\n    \"\"\"\n    return os.getenv(\"AYON_USE_DEV\") == \"1\"\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.is_staging_enabled","title":"<code>is_staging_enabled()</code>","text":"<p>Check if staging is enabled.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if staging is enabled.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def is_staging_enabled() -&gt; bool:\n    \"\"\"Check if staging is enabled.\n\n    Returns:\n        bool: True if staging is enabled.\n\n    \"\"\"\n    return os.getenv(\"AYON_USE_STAGING\") == \"1\"\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.load_executable_version","title":"<code>load_executable_version(executable)</code>","text":"<p>Get version of executable.</p> <p>Parameters:</p> Name Type Description Default <code>executable</code> <code>str</code> <p>Path to executable.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Union[str, None]: Version of executable.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def load_executable_version(executable: str) -&gt; Optional[str]:\n    \"\"\"Get version of executable.\n\n    Args:\n        executable (str): Path to executable.\n\n    Returns:\n        Union[str, None]: Version of executable.\n\n    \"\"\"\n    if not executable:\n        return None\n    return load_version_from_root(os.path.dirname(executable))\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.load_version_from_file","title":"<code>load_version_from_file(filepath)</code>","text":"<p>Execute python file and return 'version' variable.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def load_version_from_file(filepath: str) -&gt; str:\n    \"\"\"Execute python file and return '__version__' variable.\"\"\"\n\n    with open(filepath, \"r\") as stream:\n        version_content = stream.read()\n    version_globals = {}\n    exec(version_content, version_globals)\n    return version_globals[\"__version__\"]\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.load_version_from_root","title":"<code>load_version_from_root(root)</code>","text":"<p>Get version of executable.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>Path to executable.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Union[str, None]: Version of executable.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def load_version_from_root(root: str) -&gt; Optional[str]:\n    \"\"\"Get version of executable.\n\n    Args:\n        root (str): Path to executable.\n\n    Returns:\n        Union[str, None]: Version of executable.\n\n    \"\"\"\n    version = None\n    if not root or not os.path.exists(root):\n        return version\n\n    version_filepath = os.path.join(root, \"version.py\")\n    if os.path.exists(version_filepath):\n        try:\n            version = load_version_from_file(version_filepath)\n        except Exception as exc:\n            print(\"Failed lo load version file {}. {}\".format(\n                version_filepath, exc))\n\n    return version\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.store_current_executable_info","title":"<code>store_current_executable_info()</code>","text":"<p>Store information about current executable to a file for future usage.</p> <p>Use information about current executable and version of executable and add it to a list of available executables.</p> <p>The function won't do anything if the application is not built or if version is not set or the executable is already available.</p> Todos <p>Don't store executable if is located inside 'ayon-launcher' codebase?</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def store_current_executable_info():\n    \"\"\"Store information about current executable to a file for future usage.\n\n    Use information about current executable and version of executable and\n    add it to a list of available executables.\n\n    The function won't do anything if the application is not built or if\n    version is not set or the executable is already available.\n\n    Todos:\n        Don't store executable if is located inside 'ayon-launcher' codebase?\n\n    \"\"\"\n    if not IS_BUILT_APPLICATION:\n        return\n\n    store_executables([sys.executable])\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.store_executables","title":"<code>store_executables(executables)</code>","text":"<p>Store information about executables.</p> <p>Parameters:</p> Name Type Description Default <code>executables</code> <code>Iterable[str]</code> <p>Paths to executables.</p> required Source code in <code>common/ayon_common/utils.py</code> <pre><code>def store_executables(executables: Iterable[str]):\n    \"\"\"Store information about executables.\n\n    Args:\n        executables (Iterable[str]): Paths to executables.\n\n    \"\"\"\n    info = get_executables_info(check_cleanup=False)\n    info.setdefault(\"available_versions\", [])\n\n    for executable in executables:\n        if not executable or not os.path.exists(executable):\n            continue\n\n        root, filename = os.path.split(executable)\n        # Store only 'ayon.exe' executable\n        if filename == \"ayon_console.exe\":\n            filename = \"ayon.exe\"\n            executable = os.path.join(root, filename)\n\n        version = load_version_from_root(root)\n\n        match_item = None\n        item_is_new = True\n        for item in info[\"available_versions\"]:\n            # 'executable' is unique identifier if available versions\n            item_executable = item.get(\"executable\")\n            if not item_executable or item_executable != executable:\n                continue\n\n            # Version has changed, update it\n            if item.get(\"version\") != version:\n                match_item = item\n            item_is_new = False\n            break\n\n        if match_item is None:\n            if not item_is_new:\n                continue\n            match_item = {}\n            info[\"available_versions\"].append(match_item)\n\n        match_item.update({\n            \"version\": version,\n            \"executable\": executable,\n            \"added\": datetime.datetime.now().strftime(\"%y-%m-%d-%H%M\"),\n        })\n    store_executables_info(info)\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.store_executables_info","title":"<code>store_executables_info(info)</code>","text":"<p>Store information about executables.</p> <p>This will override existing information so use it wisely.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def store_executables_info(info: ExecutablesInfo):\n    \"\"\"Store information about executables.\n\n    This will override existing information so use it wisely.\n\n    \"\"\"\n    filepath = get_executables_info_filepath()\n    os.makedirs(os.path.dirname(filepath), exist_ok=True)\n\n    with open(filepath, \"w\") as stream:\n        json.dump(info, stream, indent=4)\n</code></pre>"},{"location":"autoapi/common/ayon_common/utils.html#common.ayon_common.utils.validate_file_checksum","title":"<code>validate_file_checksum(filepath, checksum, checksum_algorithm)</code>","text":"<p>Validate file checksum.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to file.</p> required <code>checksum</code> <code>str</code> <p>Hash of file.</p> required <code>checksum_algorithm</code> <code>str</code> <p>Type of checksum.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Hash is valid/invalid.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>File not found or unknown checksum algorithm.</p> Source code in <code>common/ayon_common/utils.py</code> <pre><code>def validate_file_checksum(\n    filepath: str, checksum: str, checksum_algorithm: str\n) -&gt; bool:\n    \"\"\"Validate file checksum.\n\n    Args:\n        filepath (str): Path to file.\n        checksum (str): Hash of file.\n        checksum_algorithm (str): Type of checksum.\n\n    Returns:\n        bool: Hash is valid/invalid.\n\n    Raises:\n        ValueError: File not found or unknown checksum algorithm.\n\n    \"\"\"\n    return checksum == calculate_file_checksum(filepath, checksum_algorithm)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/index.html","title":"connection","text":""},{"location":"autoapi/common/ayon_common/connection/credentials.html","title":"credentials","text":"<p>Handle credentials and connection to server for AYON launcher.</p> <p>Cache and store used server urls. Store/load API keys to/from keyring if needed. Store metadata about used urls, usernames for the urls and when was the connection with the username established.</p> <p>On bootstrap is created global connection with information about site and AYON launcher version. The connection object lives in 'ayon_api'.</p>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.add_server","title":"<code>add_server(url, username)</code>","text":"<p>Add server to server info metadata.</p> <p>This function will also mark the url as last used url on the machine so on next launch will be used.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server url.</p> required <code>username</code> <code>str</code> <p>Name of user used to log in.</p> required Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def add_server(url: str, username: str):\n    \"\"\"Add server to server info metadata.\n\n    This function will also mark the url as last used url on the machine so on\n    next launch will be used.\n\n    Args:\n        url (str): Server url.\n        username (str): Name of user used to log in.\n    \"\"\"\n\n    servers_info_path = _get_servers_path()\n    data = get_servers_info_data()\n    data[\"last_server\"] = url\n    if \"urls\" not in data:\n        data[\"urls\"] = {}\n    data[\"urls\"][url] = {\n        \"updated_dt\": datetime.datetime.now().strftime(\"%Y/%m/%d %H:%M:%S\"),\n        \"username\": username,\n    }\n\n    with open(servers_info_path, \"w\") as stream:\n        json.dump(data, stream)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.ask_to_login_ui","title":"<code>ask_to_login_ui(url=None, always_on_top=False, username=None, force_username=False)</code>","text":"<p>Ask user to login using UI.</p> <p>This should be used only when user is not yet logged in at all or available credentials are invalid. To change credentials use 'change_user_ui' function.</p> <p>Use a subprocess to show UI.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>Server url that could be prefilled in UI.</p> <code>None</code> <code>always_on_top</code> <code>Optional[bool]</code> <p>Window will be drawn on top of other windows.</p> <code>False</code> <code>username</code> <code>Optional[str]</code> <p>Username that will be prefilled in UI.</p> <code>None</code> <code>force_username</code> <code>Optional[bool]</code> <p>Username will be locked.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[str, str, str]</code> <p>tuple[str, str, str]: Url, user's token and username.</p> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def ask_to_login_ui(\n    url: Optional[str] = None,\n    always_on_top: Optional[bool] = False,\n    username: Optional[str] = None,\n    force_username: Optional[bool] = False\n) -&gt; tuple[str, str, str]:\n    \"\"\"Ask user to login using UI.\n\n    This should be used only when user is not yet logged in at all or available\n    credentials are invalid. To change credentials use 'change_user_ui'\n    function.\n\n    Use a subprocess to show UI.\n\n    Args:\n        url (Optional[str]): Server url that could be prefilled in UI.\n        always_on_top (Optional[bool]): Window will be drawn on top of\n            other windows.\n        username (Optional[str]): Username that will be prefilled in UI.\n        force_username (Optional[bool]): Username will be locked.\n\n    Returns:\n        tuple[str, str, str]: Url, user's token and username.\n    \"\"\"\n\n    ui_dir = _get_ui_dir_path()\n    if url is None:\n        url = get_last_server()\n\n    if not username:\n        username = get_last_username_by_url(url)\n\n    data = {\n        \"url\": url,\n        \"username\": username,\n        \"always_on_top\": always_on_top,\n        \"force_username\": force_username,\n    }\n\n    with tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"ayon_login\", suffix=\".json\", delete=False\n    ) as tmp:\n        output = tmp.name\n        json.dump(data, tmp)\n\n    code = subprocess.call(\n        get_ayon_launch_args(ui_dir, \"--skip-bootstrap\", output))\n    if code != 0:\n        raise RuntimeError(\"Failed to show login UI\")\n\n    with open(output, \"r\") as stream:\n        data = json.load(stream)\n    os.remove(output)\n    return data[\"output\"]\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.change_token","title":"<code>change_token(url, token, username=None, old_url=None)</code>","text":"<p>Change url and token in currently running session.</p> <p>Function can also change server url, in that case are previous credentials NOT removed from cache.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Url to server.</p> required <code>token</code> <code>str</code> <p>New token to be used for url connection.</p> required <code>username</code> <code>Optional[str]</code> <p>Username of logged user.</p> <code>None</code> <code>old_url</code> <code>Optional[str]</code> <p>Previous url. Value from 'get_last_server' is used if not entered.</p> <code>None</code> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def change_token(\n    url: str,\n    token: str,\n    username: Optional[str] = None,\n    old_url: Optional[str] = None\n):\n    \"\"\"Change url and token in currently running session.\n\n    Function can also change server url, in that case are previous credentials\n    NOT removed from cache.\n\n    Args:\n        url (str): Url to server.\n        token (str): New token to be used for url connection.\n        username (Optional[str]): Username of logged user.\n        old_url (Optional[str]): Previous url. Value from 'get_last_server'\n            is used if not entered.\n    \"\"\"\n\n    if old_url is None:\n        old_url = get_last_server()\n    if old_url and old_url == url:\n        remove_url_cache(old_url)\n\n    # TODO check if ayon_api is already connected\n    add_server(url, username)\n    store_token(url, token)\n    ayon_api.change_token(url, token)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.change_user_ui","title":"<code>change_user_ui()</code>","text":"<p>Change user using UI.</p> <p>Show UI to user where he can change credentials or url. Output will contain all information about old/new values of url, username, api key. If user confirmed or declined values.</p> <p>Returns:</p> Name Type Description <code>ChangeUserResult</code> <code>ChangeUserResult</code> <p>Information about user change.</p> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def change_user_ui() -&gt; ChangeUserResult:\n    \"\"\"Change user using UI.\n\n    Show UI to user where he can change credentials or url. Output will contain\n    all information about old/new values of url, username, api key. If user\n    confirmed or declined values.\n\n    Returns:\n         ChangeUserResult: Information about user change.\n    \"\"\"\n\n    # For backwards compatibility show dialog that current session does not\n    #   allow credentials change\n    if os.getenv(\"AYON_IN_LOGIN_MODE\") == \"0\":\n        show_invalid_credentials_ui(in_subprocess=False)\n        return ChangeUserResult(\n            False,\n            os.getenv(SERVER_URL_ENV_KEY),\n            os.getenv(SERVER_API_ENV_KEY),\n            None,\n            None,\n            None,\n            None\n        )\n\n    url, username = get_last_server_with_username()\n    token = load_token(url)\n    output = show_login_ui(url, username, token)\n    if output.logged_out:\n        logout(url, token)\n\n    elif output.token_changed:\n        change_token(\n            output.new_url,\n            output.new_token,\n            output.new_username,\n            output.old_url\n        )\n    return output\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.confirm_server_login","title":"<code>confirm_server_login(url, token, username)</code>","text":"<p>Confirm login of user and do necessary stepts to apply changes.</p> <p>This should not be used on \"change\" of user but on first login.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server url where user authenticated.</p> required <code>token</code> <code>str</code> <p>API token used for authentication to server.</p> required <code>username</code> <code>Union[str, None]</code> <p>Username related to API token.</p> required Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def confirm_server_login(url: str, token: str, username: Union[str, None]):\n    \"\"\"Confirm login of user and do necessary stepts to apply changes.\n\n    This should not be used on \"change\" of user but on first login.\n\n    Args:\n        url (str): Server url where user authenticated.\n        token (str): API token used for authentication to server.\n        username (Union[str, None]): Username related to API token.\n    \"\"\"\n\n    add_server(url, username)\n    store_token(url, token)\n    set_environments(url, token)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.create_global_connection","title":"<code>create_global_connection()</code>","text":"<p>Create global connection with site id and AYON launcher version.</p> <p>Make sure this function is called once during process runtime.</p> <p>The global connection in 'ayon_api' have entered site id and     AYON launcher version.</p> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def create_global_connection():\n    \"\"\"Create global connection with site id and AYON launcher version.\n\n    Make sure this function is called once during process runtime.\n\n    The global connection in 'ayon_api' have entered site id and\n        AYON launcher version.\n    \"\"\"\n\n    ayon_api.create_connection(\n        get_local_site_id(), os.environ.get(\"AYON_VERSION\")\n    )\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.get_last_server","title":"<code>get_last_server(data=None)</code>","text":"<p>Last server used to log in on this machine.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Optional[dict[str, Any]]</code> <p>Prepared server information data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>Union[str, None]: Last used server url.</p> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def get_last_server(\n    data: Optional[dict[str, Any]] = None\n) -&gt; Union[str, None]:\n    \"\"\"Last server used to log in on this machine.\n\n    Args:\n        data (Optional[dict[str, Any]]): Prepared server information data.\n\n    Returns:\n        Union[str, None]: Last used server url.\n    \"\"\"\n\n    if data is None:\n        data = get_servers_info_data()\n    return data.get(\"last_server\")\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.get_last_server_with_username","title":"<code>get_last_server_with_username()</code>","text":"<p>Receive last server and username used in last connection.</p> <p>Returns:</p> Type Description <p>tuple[Union[str, None], Union[str, None]]: Url and username.</p> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def get_last_server_with_username():\n    \"\"\"Receive last server and username used in last connection.\n\n    Returns:\n        tuple[Union[str, None], Union[str, None]]: Url and username.\n    \"\"\"\n\n    data = get_servers_info_data()\n    url = get_last_server(data)\n    username = get_last_username_by_url(url)\n    return url, username\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.get_last_username_by_url","title":"<code>get_last_username_by_url(url, data=None)</code>","text":"<p>Get last username which was used for passed url.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server url.</p> required <code>data</code> <code>Optional[dict[str, Any]]</code> <p>Servers info.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>Union[str, None]: Username.</p> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def get_last_username_by_url(\n    url: str,\n    data: Optional[dict[str, Any]] = None\n) -&gt; Union[str, None]:\n    \"\"\"Get last username which was used for passed url.\n\n    Args:\n        url (str): Server url.\n        data (Optional[dict[str, Any]]): Servers info.\n\n    Returns:\n         Union[str, None]: Username.\n    \"\"\"\n\n    if not url:\n        return None\n\n    if data is None:\n        data = get_servers_info_data()\n\n    if urls := data.get(\"urls\"):\n        if url_info := urls.get(url):\n            return url_info.get(\"username\")\n    return None\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.get_servers_info_data","title":"<code>get_servers_info_data()</code>","text":"<p>Metadata about used server on this machine.</p> <p>Store data about all used server urls, last used url and user username for the url. Using this metadata we can remember which username was used per url if token stored in keyring loose lifetime.</p> <p>Returns:</p> Type Description <p>dict[str, Any]: Information about servers.</p> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def get_servers_info_data():\n    \"\"\"Metadata about used server on this machine.\n\n    Store data about all used server urls, last used url and user username for\n    the url. Using this metadata we can remember which username was used per\n    url if token stored in keyring loose lifetime.\n\n    Returns:\n        dict[str, Any]: Information about servers.\n    \"\"\"\n\n    data = {}\n    servers_info_path = _get_servers_path()\n    if not os.path.exists(servers_info_path):\n        dirpath = os.path.dirname(servers_info_path)\n        os.makedirs(dirpath, exist_ok=True)\n\n        return data\n\n    with open(servers_info_path, \"r\") as stream:\n        with contextlib.suppress(BaseException):\n            data = json.load(stream)\n    return data\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.is_token_valid","title":"<code>is_token_valid(url, token, expected_username=None)</code>","text":"<p>Check if token is valid.</p> Note <p>This function is available in 'ayon_api', but does not support to     validate service api key, only user's token. The support will be     added in future PRs of 'ayon_api'. The function also did not support timeout which could cause     'ayon_api.is_token_valid' to hang.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server url.</p> required <code>token</code> <code>str</code> <p>User's token.</p> required <code>expected_username</code> <code>Optional[str]</code> <p>Token must belong to user with this username. Ignored if is 'None'.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if token is valid.</p> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def is_token_valid(\n    url: str, token: str, expected_username: Optional[str] = None\n) -&gt; bool:\n    \"\"\"Check if token is valid.\n\n    Note:\n        This function is available in 'ayon_api', but does not support to\n            validate service api key, only user's token. The support will be\n            added in future PRs of 'ayon_api'.\n        The function also did not support timeout which could cause\n            'ayon_api.is_token_valid' to hang.\n\n    Args:\n        url (str): Server url.\n        token (str): User's token.\n        expected_username (Optional[str]): Token must belong to user with\n            this username. Ignored if is 'None'.\n\n    Returns:\n        bool: True if token is valid.\n    \"\"\"\n\n    api = ayon_api.ServerAPI(url, token)\n    if not api.has_valid_token:\n        return False\n    if expected_username:\n        return expected_username == api.get_user()[\"name\"]\n    return True\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.load_environments","title":"<code>load_environments()</code>","text":"<p>Load environments on startup.</p> <p>Handle environments needed for connection with server. Environments are 'AYON_SERVER_URL' and 'AYON_API_KEY'.</p> <p>Server is looked up from environment. Already set environent is not changed. If environemnt is not filled then last server stored in appdirs is used.</p> <p>Token is skipped if url is not available. Otherwise, is also checked from env and if is not available then uses 'load_token' to try to get token based on server url.</p> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def load_environments():\n    \"\"\"Load environments on startup.\n\n    Handle environments needed for connection with server. Environments are\n    'AYON_SERVER_URL' and 'AYON_API_KEY'.\n\n    Server is looked up from environment. Already set environent is not\n    changed. If environemnt is not filled then last server stored in appdirs\n    is used.\n\n    Token is skipped if url is not available. Otherwise, is also checked from\n    env and if is not available then uses 'load_token' to try to get token\n    based on server url.\n    \"\"\"\n\n    server_url = os.environ.get(SERVER_URL_ENV_KEY)\n    if not server_url:\n        server_url = get_last_server()\n        if not server_url:\n            return\n        os.environ[SERVER_URL_ENV_KEY] = server_url\n\n    if not os.environ.get(SERVER_API_ENV_KEY):\n        if token := load_token(server_url):\n            os.environ[SERVER_API_ENV_KEY] = token\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.load_token","title":"<code>load_token(url)</code>","text":"<p>Get token for url from keyring.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server url.</p> required <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>Union[str, None]: Token for passed url available in keyring.</p> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def load_token(url: str) -&gt; Union[str, None]:\n    \"\"\"Get token for url from keyring.\n\n    Args:\n        url (str): Server url.\n\n    Returns:\n        Union[str, None]: Token for passed url available in keyring.\n    \"\"\"\n\n    return TokenKeyring(url).get_value()\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.logout","title":"<code>logout(url, token)</code>","text":"<p>Logout from server and throw token away.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Url from which should be logged out.</p> required <code>token</code> <code>str</code> <p>Token which should be used to log out.</p> required Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def logout(url: str, token: str):\n    \"\"\"Logout from server and throw token away.\n\n    Args:\n        url (str): Url from which should be logged out.\n        token (str): Token which should be used to log out.\n    \"\"\"\n\n    remove_server(url)\n    ayon_api.close_connection()\n    ayon_api.set_environments(None, None)\n    remove_token_cache(url, token)\n    logout_from_server(url, token)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.need_server_or_login","title":"<code>need_server_or_login(username=None)</code>","text":"<p>Check if server url or login to the server are needed.</p> <p>It is recommended to call 'load_environments' on startup before this check. But in some cases this function could be called after startup.</p> <p>Returns:</p> Type Description <code>tuple[bool, bool]</code> <p>tuple[bool, bool]: Server or api key needed. Both are 'True' if are available and valid.</p> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def need_server_or_login(username: Optional[str] = None) -&gt; tuple[bool, bool]:\n    \"\"\"Check if server url or login to the server are needed.\n\n    It is recommended to call 'load_environments' on startup before this check.\n    But in some cases this function could be called after startup.\n\n    Returns:\n        tuple[bool, bool]: Server or api key needed. Both are 'True' if\n            are available and valid.\n    \"\"\"\n\n    server_url = os.environ.get(SERVER_URL_ENV_KEY)\n    if not server_url:\n        return True, True\n\n    try:\n        server_url = validate_url(server_url)\n    except UrlError:\n        return True, True\n\n    token = os.environ.get(SERVER_API_ENV_KEY)\n    if token:\n        return False, not is_token_valid(server_url, token, username)\n\n    token = load_token(server_url)\n    if token:\n        return False, not is_token_valid(server_url, token, username)\n    return False, True\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.remove_server","title":"<code>remove_server(url)</code>","text":"<p>Remove server url from servers information.</p> <p>This should be used on logout to completelly loose information about server on the machine.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server url.</p> required Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def remove_server(url: str):\n    \"\"\"Remove server url from servers information.\n\n    This should be used on logout to completelly loose information about server\n    on the machine.\n\n    Args:\n        url (str): Server url.\n    \"\"\"\n\n    if not url:\n        return\n\n    servers_info_path = _get_servers_path()\n    data = get_servers_info_data()\n    if data.get(\"last_server\") == url:\n        data[\"last_server\"] = None\n\n    if \"urls\" in data:\n        data[\"urls\"].pop(url, None)\n\n    with open(servers_info_path, \"w\") as stream:\n        json.dump(data, stream)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.remove_token_cache","title":"<code>remove_token_cache(url, token)</code>","text":"<p>Remove token from local cache of url.</p> <p>Is skipped if cached token under the passed url is not the same as passed token.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Url to server.</p> required <code>token</code> <code>str</code> <p>Token to be removed from url cache.</p> required Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def remove_token_cache(url: str, token: str):\n    \"\"\"Remove token from local cache of url.\n\n    Is skipped if cached token under the passed url is not the same\n    as passed token.\n\n    Args:\n        url (str): Url to server.\n        token (str): Token to be removed from url cache.\n    \"\"\"\n\n    if load_token(url) == token:\n        remove_url_cache(url)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.remove_url_cache","title":"<code>remove_url_cache(url)</code>","text":"<p>Clear cache for server url.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server url which is removed from cache.</p> required Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def remove_url_cache(url: str):\n    \"\"\"Clear cache for server url.\n\n    Args:\n        url (str): Server url which is removed from cache.\n    \"\"\"\n\n    store_token(url, None)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.set_environments","title":"<code>set_environments(url, token)</code>","text":"<p>Change url and token environemnts in currently running process.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>New server url.</p> required <code>token</code> <code>str</code> <p>User's token.</p> required Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def set_environments(url: str, token: str):\n    \"\"\"Change url and token environemnts in currently running process.\n\n    Args:\n        url (str): New server url.\n        token (str): User's token.\n    \"\"\"\n\n    ayon_api.set_environments(url, token)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.show_invalid_credentials_ui","title":"<code>show_invalid_credentials_ui(message=None, in_subprocess=False, always_on_top=False)</code>","text":"<p>Show UI with information about invalid credentials.</p> <p>This can be used when AYON launcher is in bypass login mode. In that case 'change_user_ui' cannot be used to change credentials.</p> <p>Parameters:</p> Name Type Description Default <code>in_subprocess</code> <code>bool</code> <p>Show UI in subprocess.</p> <code>False</code> <code>message</code> <code>Optional[str]</code> <p>Message to be shown to user.</p> <code>None</code> <code>always_on_top</code> <code>Optional[bool]</code> <p>Window will be drawn on top of other windows.</p> <code>False</code> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def show_invalid_credentials_ui(\n    message: Optional[str] = None,\n    in_subprocess: bool = False,\n    always_on_top: bool = False,\n):\n    \"\"\"Show UI with information about invalid credentials.\n\n    This can be used when AYON launcher is in bypass login mode. In that case\n    'change_user_ui' cannot be used to change credentials.\n\n    Args:\n        in_subprocess (bool): Show UI in subprocess.\n        message (Optional[str]): Message to be shown to user.\n        always_on_top (Optional[bool]): Window will be drawn on top of\n            other windows.\n    \"\"\"\n\n    if in_subprocess:\n        return _show_invalid_credentials_subprocess(message, always_on_top)\n\n    from .ui import invalid_credentials\n\n    invalid_credentials(message)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.show_login_ui","title":"<code>show_login_ui(url, username, token)</code>","text":"<p>Show login UI and process inputs.</p> Todos <p>Add more arguments to function to be able to prefill UI with     information, like server is unreachable, url is invalid, token is     unauthorized, etc.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Union[str, None]</code> <p>Server url that could be prefilled in UI.</p> required <code>username</code> <code>Union[str, None]</code> <p>Username that could be prefilled in UI.</p> required <code>token</code> <code>Union[str, None]</code> <p>User's token that could be prefilled in UI.</p> required <p>Returns:</p> Name Type Description <code>ChangeUserResult</code> <code>ChangeUserResult</code> <p>Information about user change.</p> Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def show_login_ui(\n    url: Union[str, None],\n    username: Union[str, None],\n    token: Union[str, None],\n) -&gt; ChangeUserResult:\n    \"\"\"Show login UI and process inputs.\n\n    Todos:\n        Add more arguments to function to be able to prefill UI with\n            information, like server is unreachable, url is invalid, token is\n            unauthorized, etc.\n\n    Args:\n        url (Union[str, None]): Server url that could be prefilled in UI.\n        username (Union[str, None]): Username that could be prefilled in UI.\n        token (Union[str, None]): User's token that could be prefilled in UI.\n\n    Returns:\n        ChangeUserResult: Information about user change.\n    \"\"\"\n\n    from .ui import change_user\n\n    result = change_user(url, username, token)\n    new_url, new_token, new_username, logged_out = result\n\n    return ChangeUserResult(\n        logged_out, url, token, username,\n        new_url, new_token, new_username\n    )\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/credentials.html#common.ayon_common.connection.credentials.store_token","title":"<code>store_token(url, token)</code>","text":"<p>Store token by url to keyring.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server url.</p> required <code>token</code> <code>str</code> <p>User token to server.</p> required Source code in <code>common/ayon_common/connection/credentials.py</code> <pre><code>def store_token(url: str, token: str):\n    \"\"\"Store token by url to keyring.\n\n    Args:\n        url (str): Server url.\n        token (str): User token to server.\n    \"\"\"\n\n    TokenKeyring(url).set_value(token)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/index.html","title":"ui","text":""},{"location":"autoapi/common/ayon_common/connection/ui/index.html#common.ayon_common.connection.ui.InvalidCredentialsWindow","title":"<code>InvalidCredentialsWindow</code>","text":"<p>               Bases: <code>QDialog</code></p> Source code in <code>common/ayon_common/connection/ui/invalid_window.py</code> <pre><code>class InvalidCredentialsWindow(QtWidgets.QDialog):\n    default_width = 420\n    default_height = 170\n\n    def __init__(self, message, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        icon_path = get_icon_path()\n        icon = QtGui.QIcon(icon_path)\n        self.setWindowIcon(icon)\n        self.setWindowTitle(\"Invalid credentials\")\n\n        info_widget = QtWidgets.QWidget(self)\n\n        message_label = url_cred_sep = None\n        if message:\n            # --- Custom message ---\n            message_label = QtWidgets.QLabel(message, info_widget)\n            message_label.setWordWrap(True)\n            message_label.setTextInteractionFlags(\n                QtCore.Qt.TextBrowserInteraction\n            )\n\n            # --- URL separator ---\n            url_cred_sep = QtWidgets.QFrame(info_widget)\n            url_cred_sep.setObjectName(\"Separator\")\n            url_cred_sep.setMinimumHeight(2)\n            url_cred_sep.setMaximumHeight(2)\n\n        common_label = QtWidgets.QLabel(\n            (\n                \" You are running AYON launcher in &lt;b&gt;'bypass login'&lt;/b&gt;\"\n                \" mode. Meaning your AYON connection information is\"\n                \" defined by environment variables.\"\n                \"&lt;br/&gt;&lt;br/&gt;Please contact your administrator or use valid\"\n                \" credentials.\"\n            ),\n            info_widget\n        )\n        common_label.setWordWrap(True)\n        common_label.setTextInteractionFlags(QtCore.Qt.TextBrowserInteraction)\n\n        info_layout = QtWidgets.QVBoxLayout(info_widget)\n        info_layout.setContentsMargins(0, 0, 0, 0)\n        if message_label is not None:\n            info_layout.addWidget(message_label, 0)\n            info_layout.addWidget(url_cred_sep, 0)\n        info_layout.addWidget(common_label, 0)\n\n        footer_widget = QtWidgets.QWidget(self)\n        close_btn = QtWidgets.QPushButton(\"Close\", footer_widget)\n\n        footer_layout = QtWidgets.QHBoxLayout(footer_widget)\n        footer_layout.setContentsMargins(0, 0, 0, 0)\n        footer_layout.addStretch(1)\n        footer_layout.addWidget(close_btn, 0)\n\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.addWidget(info_widget, 0)\n        main_layout.addStretch(1)\n        main_layout.addWidget(footer_widget, 0)\n\n        close_btn.clicked.connect(self._on_close_click)\n\n        self._first_show = True\n        self._message_label = message_label\n        self._common_label = common_label\n\n    def resizeEvent(self, event):\n        super().resizeEvent(event)\n        print(self.size())\n\n    def showEvent(self, event):\n        super().showEvent(event)\n        if self._first_show:\n            self._first_show = False\n            self._on_first_show()\n\n    def _on_first_show(self):\n        self.setStyleSheet(load_stylesheet())\n        self.resize(self.default_width, self.default_height)\n        self._center_window()\n\n    def _center_window(self):\n        \"\"\"Move window to center of screen.\"\"\"\n\n        if hasattr(QtWidgets.QApplication, \"desktop\"):\n            desktop = QtWidgets.QApplication.desktop()\n            screen_idx = desktop.screenNumber(self)\n            screen_geo = desktop.screenGeometry(screen_idx)\n        else:\n            screen = self.screen()\n            screen_geo = screen.geometry()\n\n        geo = self.frameGeometry()\n        geo.moveCenter(screen_geo.center())\n        if geo.y() &lt; screen_geo.y():\n            geo.setY(screen_geo.y())\n        self.move(geo.topLeft())\n\n    def _on_close_click(self):\n        self.close()\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/index.html#common.ayon_common.connection.ui.ServerLoginWindow","title":"<code>ServerLoginWindow</code>","text":"<p>               Bases: <code>QDialog</code></p> Source code in <code>common/ayon_common/connection/ui/login_window.py</code> <pre><code>class ServerLoginWindow(QtWidgets.QDialog):\n    default_width = 410\n    default_height = 170\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        icon_path = get_icon_path()\n        icon = QtGui.QIcon(icon_path)\n        self.setWindowIcon(icon)\n        self.setWindowTitle(\"Login to server\")\n\n        edit_icon_path = get_resource_path(\"edit.png\")\n        edit_icon = QtGui.QIcon(edit_icon_path)\n\n        # --- URL page ---\n        login_bg_widget = QtWidgets.QWidget(self)\n\n        login_widget = QtWidgets.QWidget(login_bg_widget)\n\n        user_cred_widget = QtWidgets.QWidget(login_widget)\n\n        url_label = QtWidgets.QLabel(\"URL:\", user_cred_widget)\n\n        url_widget = QtWidgets.QWidget(user_cred_widget)\n\n        url_input = PlaceholderLineEdit(url_widget)\n        url_input.setPlaceholderText(\"&lt; https://ayon.server.com &gt;\")\n\n        url_preview = QtWidgets.QLineEdit(url_widget)\n        url_preview.setReadOnly(True)\n        url_preview.setObjectName(\"LikeDisabledInput\")\n\n        url_edit_btn = PressHoverButton(user_cred_widget)\n        url_edit_btn.setIcon(edit_icon)\n        url_edit_btn.setObjectName(\"PasswordBtn\")\n\n        url_layout = QtWidgets.QHBoxLayout(url_widget)\n        url_layout.setContentsMargins(0, 0, 0, 0)\n        url_layout.addWidget(url_input, 1)\n        url_layout.addWidget(url_preview, 1)\n\n        # --- URL separator ---\n        url_cred_sep = QtWidgets.QFrame(login_bg_widget)\n        url_cred_sep.setObjectName(\"Separator\")\n        url_cred_sep.setMinimumHeight(2)\n        url_cred_sep.setMaximumHeight(2)\n\n        # --- Login page ---\n        login_ayon_btn = QtWidgets.QPushButton(\n            \"Login with AYON server\", login_widget\n        )\n        login_ayon_btn.setIcon(QtGui.QIcon(get_ayon_default_icon_path()))\n        login_ayon_btn.setObjectName(\"AYONLoginButton\")\n\n        login_or_sep = OrSeparator(login_bg_widget)\n\n        username_label = QtWidgets.QLabel(\"Username:\", user_cred_widget)\n\n        username_widget = QtWidgets.QWidget(user_cred_widget)\n\n        username_input = PlaceholderLineEdit(username_widget)\n        username_input.setPlaceholderText(\"&lt; Artist &gt;\")\n\n        username_preview = QtWidgets.QLineEdit(username_widget)\n        username_preview.setReadOnly(True)\n        username_preview.setObjectName(\"LikeDisabledInput\")\n\n        username_edit_btn = PressHoverButton(user_cred_widget)\n        username_edit_btn.setIcon(edit_icon)\n        username_edit_btn.setObjectName(\"PasswordBtn\")\n\n        username_layout = QtWidgets.QHBoxLayout(username_widget)\n        username_layout.setContentsMargins(0, 0, 0, 0)\n        username_layout.addWidget(username_input, 1)\n        username_layout.addWidget(username_preview, 1)\n\n        password_label = QtWidgets.QLabel(\"Password:\", user_cred_widget)\n        password_input = PlaceholderLineEdit(user_cred_widget)\n        password_input.setPlaceholderText(\"&lt; *********** &gt;\")\n        password_input.setEchoMode(PlaceholderLineEdit.Password)\n\n        api_label = QtWidgets.QLabel(\"API key:\", user_cred_widget)\n        api_preview = QtWidgets.QLineEdit(user_cred_widget)\n        api_preview.setReadOnly(True)\n        api_preview.setObjectName(\"LikeDisabledInput\")\n\n        show_password_btn = ShowPasswordButton(user_cred_widget)\n        # Cannot be focused, user has to click with mouse\n        show_password_btn.setFocusPolicy(QtCore.Qt.NoFocus)\n\n        cred_msg_sep = QtWidgets.QFrame(login_bg_widget)\n        cred_msg_sep.setObjectName(\"Separator\")\n        cred_msg_sep.setMinimumHeight(2)\n        cred_msg_sep.setMaximumHeight(2)\n\n        # --- Credentials inputs ---\n        user_cred_layout = QtWidgets.QGridLayout(user_cred_widget)\n        user_cred_layout.setContentsMargins(0, 0, 0, 0)\n        user_cred_layout.setSpacing(6)\n        row = 0\n\n        user_cred_layout.addWidget(url_label, row, 0, 1, 1)\n        user_cred_layout.addWidget(url_widget, row, 1, 1, 1)\n        user_cred_layout.addWidget(url_edit_btn, row, 2, 1, 1)\n        row += 1\n\n        user_cred_layout.addWidget(url_cred_sep, row, 0, 1, 3)\n        row += 1\n\n        user_cred_layout.addWidget(login_ayon_btn, row, 0, 1, 3)\n        row += 1\n\n        user_cred_layout.addWidget(login_or_sep, row, 0, 1, 3)\n        row += 1\n\n        user_cred_layout.addWidget(username_label, row, 0, 1, 1)\n        user_cred_layout.addWidget(username_widget, row, 1, 1, 1)\n        user_cred_layout.addWidget(username_edit_btn, row, 2, 2, 1)\n        row += 1\n\n        user_cred_layout.addWidget(api_label, row, 0, 1, 1)\n        user_cred_layout.addWidget(api_preview, row, 1, 1, 1)\n        row += 1\n\n        user_cred_layout.addWidget(password_label, row, 0, 1, 1)\n        user_cred_layout.addWidget(password_input, row, 1, 1, 1)\n        user_cred_layout.addWidget(show_password_btn, row, 2, 1, 1)\n        row += 1\n\n        user_cred_layout.addWidget(cred_msg_sep, row, 0, 1, 3)\n        row += 1\n\n        user_cred_layout.setColumnStretch(0, 0)\n        user_cred_layout.setColumnStretch(1, 1)\n        user_cred_layout.setColumnStretch(2, 0)\n\n        login_layout = QtWidgets.QVBoxLayout(login_widget)\n        login_layout.setContentsMargins(0, 0, 0, 0)\n        login_layout.addWidget(user_cred_widget, 1)\n\n        # --- Messages ---\n        # Messages for users (e.g. invalid url etc.)\n        message_label = QtWidgets.QLabel(login_bg_widget)\n        message_label.setWordWrap(True)\n        message_label.setTextInteractionFlags(QtCore.Qt.TextBrowserInteraction)\n\n        footer_widget = QtWidgets.QWidget(login_bg_widget)\n        logout_btn = QtWidgets.QPushButton(\"Logout\", footer_widget)\n        user_message = QtWidgets.QLabel(footer_widget)\n        login_btn = QtWidgets.QPushButton(\"Login\", footer_widget)\n        confirm_btn = QtWidgets.QPushButton(\"Confirm\", footer_widget)\n\n        # Disable default button behavior\n        # - it is handled based on current input state\n        for btn in (\n            show_password_btn,\n            login_ayon_btn,\n            logout_btn,\n            login_btn,\n            confirm_btn,\n        ):\n            btn.setDefault(False)\n            btn.setAutoDefault(False)\n\n        footer_layout = QtWidgets.QHBoxLayout(footer_widget)\n        footer_layout.setContentsMargins(0, 0, 0, 0)\n        footer_layout.setSpacing(6)\n        footer_layout.addWidget(logout_btn, 0)\n        footer_layout.addWidget(user_message, 1)\n        footer_layout.addWidget(login_btn, 0)\n        footer_layout.addWidget(confirm_btn, 0)\n\n        login_bg_layout = QtWidgets.QVBoxLayout(login_bg_widget)\n        login_bg_layout.setContentsMargins(0, 0, 0, 0)\n        login_bg_layout.setSpacing(6)\n        login_bg_layout.addWidget(login_widget, 0)\n        login_bg_layout.addWidget(message_label, 0)\n        login_bg_layout.addStretch(1)\n        login_bg_layout.addWidget(footer_widget, 0)\n\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.setContentsMargins(10, 10, 10, 10)\n        main_layout.setSpacing(6)\n        main_layout.addWidget(login_bg_widget, 1)\n\n        # --- Overlay ---\n        overlay_frame = OverlayWidget(self)\n        overlay_frame.set_visible(False)\n\n        server_timer = QtCore.QTimer()\n        server_timer.setInterval(100)\n\n        server_timer.timeout.connect(self._on_server_timer)\n        overlay_frame.cancelled.connect(self._on_server_cancel)\n        url_input.textChanged.connect(self._on_url_change)\n        url_input.returnPressed.connect(self._on_url_enter_press)\n        login_ayon_btn.clicked.connect(self._login_with_ayon_server)\n        username_input.textChanged.connect(self._on_user_change)\n        username_input.returnPressed.connect(self._on_username_enter_press)\n        password_input.returnPressed.connect(self._on_password_enter_press)\n        show_password_btn.state_changed.connect(self._on_password_state_change)\n        url_edit_btn.clicked.connect(self._on_url_edit_click)\n        username_edit_btn.clicked.connect(self._on_username_edit_click)\n        logout_btn.clicked.connect(self._on_logout_click)\n        login_btn.clicked.connect(self._on_login_click)\n        confirm_btn.clicked.connect(self._on_login_click)\n\n        self._overlay_visible = False\n        self._overlay_frame = overlay_frame\n\n        self._login_bg_widget = login_bg_widget\n\n        self._login_widget = login_widget\n\n        self._login_or_sep = login_or_sep\n        self._login_ayon_btn = login_ayon_btn\n\n        self._url_widget = url_widget\n        self._url_input = url_input\n        self._url_preview = url_preview\n        self._url_edit_btn = url_edit_btn\n\n        self._user_cred_widget = user_cred_widget\n        self._username_input = username_input\n        self._username_preview = username_preview\n        self._username_edit_btn = username_edit_btn\n\n        self._password_label = password_label\n        self._password_input = password_input\n        self._show_password_btn = show_password_btn\n        self._api_label = api_label\n        self._api_preview = api_preview\n\n        self._message_label = message_label\n\n        self._logout_btn = logout_btn\n        self._user_message = user_message\n        self._login_btn = login_btn\n        self._confirm_btn = confirm_btn\n\n        self._url_is_valid = None\n        self._credentials_are_valid = None\n        self._result = (None, None, None, False)\n        self._first_show = True\n        self._force_username = False\n\n        self._allow_logout = False\n        self._logged_in = False\n        self._url_edit_mode = False\n        self._username_edit_mode = False\n\n        self._server_timer_counter = 0\n        self._server_timer = server_timer\n        self._server_handler = None\n\n    def set_allow_logout(self, allow_logout):\n        if allow_logout is self._allow_logout:\n            return\n        self._allow_logout = allow_logout\n\n        self._update_states_by_edit_mode()\n\n    def set_url(self, url):\n        self._url_preview.setText(url)\n        self._url_input.setText(url)\n        self._validate_url()\n\n    def set_username(self, username):\n        self._username_preview.setText(username)\n        self._username_input.setText(username)\n\n    def set_force_username(self, force_username: bool):\n        \"\"\"Force filled username.\n\n        User cannot change username if enabled.\n\n        Args:\n            force_username (bool): If True, username will be forced.\n\n        \"\"\"\n        self._force_username = force_username\n        self._username_input.setEnabled(not force_username)\n        self._url_input.setEnabled(not force_username)\n\n    def set_logged_in(\n        self,\n        logged_in,\n        url=None,\n        username=None,\n        api_key=None,\n        allow_logout=None\n    ):\n        if url is not None:\n            self.set_url(url)\n\n        if username is not None:\n            self.set_username(username)\n\n        if api_key:\n            self._set_api_key(api_key)\n\n        if logged_in and allow_logout is None:\n            allow_logout = True\n\n        self._set_logged_in(logged_in)\n\n        if allow_logout:\n            self.set_allow_logout(True)\n        elif allow_logout is False:\n            self.set_allow_logout(False)\n\n    def showEvent(self, event):\n        super().showEvent(event)\n        if self._first_show:\n            self._first_show = False\n            self._on_first_show()\n\n        self._update_overlay_position()\n\n    def resizeEvent(self, event):\n        super().resizeEvent(event)\n        self._update_overlay_position()\n\n    def closeEvent(self, event):\n        self._on_server_cancel()\n        super().closeEvent(event)\n\n    def result(self):\n        \"\"\"Result url and token or login.\n\n        Returns:\n            Union[Tuple[str, str], Tuple[None, None]]: Url and token used for\n                login if was successful otherwise are both set to None.\n        \"\"\"\n        return self._result\n\n    def _set_logged_in(self, logged_in):\n        if logged_in is self._logged_in:\n            return\n        self._logged_in = logged_in\n\n        self._update_states_by_edit_mode()\n\n    def _set_url_edit_mode(self, edit_mode):\n        if self._url_edit_mode is not edit_mode:\n            self._url_edit_mode = edit_mode\n            self._update_states_by_edit_mode()\n\n    def _set_username_edit_mode(self, edit_mode):\n        if self._username_edit_mode is not edit_mode:\n            self._username_edit_mode = edit_mode\n            self._update_states_by_edit_mode()\n\n    def _get_url_user_edit(self):\n        url_edit = True\n        if self._logged_in and not self._url_edit_mode:\n            url_edit = False\n        user_edit = url_edit\n        if not user_edit and self._logged_in and self._username_edit_mode:\n            user_edit = True\n        return url_edit, user_edit\n\n    def _update_states_by_edit_mode(self):\n        url_edit, user_edit = self._get_url_user_edit()\n\n        self._url_preview.setVisible(not url_edit)\n        self._url_input.setVisible(url_edit)\n        self._url_edit_btn.setVisible(self._allow_logout and not url_edit)\n\n        self._login_ayon_btn.setVisible(user_edit)\n        self._login_or_sep.setVisible(user_edit)\n\n        self._username_preview.setVisible(not user_edit)\n        self._username_input.setVisible(user_edit)\n        self._username_edit_btn.setVisible(\n            self._allow_logout and not user_edit\n        )\n\n        self._api_preview.setVisible(not user_edit)\n        self._api_label.setVisible(not user_edit)\n\n        self._password_label.setVisible(user_edit)\n        self._show_password_btn.setVisible(user_edit)\n        self._password_input.setVisible(user_edit)\n\n        self._logout_btn.setVisible(self._allow_logout and self._logged_in)\n        self._login_btn.setVisible(not self._allow_logout)\n        self._confirm_btn.setVisible(self._allow_logout)\n        self._update_login_btn_state(url_edit, user_edit)\n\n    def _update_login_btn_state(self, url_edit=None, user_edit=None, url=None):\n        if url_edit is None:\n            url_edit, user_edit = self._get_url_user_edit()\n\n        if url is None:\n            url = self._url_input.text()\n\n        enabled = bool(url) and (url_edit or user_edit)\n\n        self._login_btn.setEnabled(enabled)\n        self._confirm_btn.setEnabled(enabled)\n\n    def _update_overlay_position(self):\n        if not self._overlay_visible:\n            return\n        self._overlay_frame.resize(self.size())\n\n    def _set_overlay_visible(self, visible):\n        if self._overlay_visible is visible:\n            return\n        self._overlay_visible = visible\n        self._overlay_frame.set_visible(visible)\n        self._login_bg_widget.setEnabled(not visible)\n        self._update_overlay_position()\n\n    def _on_first_show(self):\n        self.setStyleSheet(load_stylesheet())\n        msh = self.minimumSizeHint()\n        self.setMinimumWidth(max(msh.width(), 320))\n\n        self.resize(self.default_width, self.default_height)\n\n        self._center_window()\n        if self._allow_logout is None:\n            self.set_allow_logout(False)\n\n        self._update_states_by_edit_mode()\n        if not self._url_input.text():\n            widget = self._url_input\n        elif not self._username_input.text():\n            widget = self._username_input\n        else:\n            widget = self._password_input\n\n        self._set_input_focus(widget)\n\n    def _center_window(self):\n        \"\"\"Move window to center of screen.\"\"\"\n\n        if hasattr(QtWidgets.QApplication, \"desktop\"):\n            desktop = QtWidgets.QApplication.desktop()\n            screen_idx = desktop.screenNumber(self)\n            screen_geo = desktop.screenGeometry(screen_idx)\n        else:\n            screen = self.screen()\n            screen_geo = screen.geometry()\n\n        geo = self.frameGeometry()\n        geo.moveCenter(screen_geo.center())\n        if geo.y() &lt; screen_geo.y():\n            geo.setY(screen_geo.y())\n        self.move(geo.topLeft())\n\n    def _on_url_change(self, text):\n        self._update_login_btn_state(url=text)\n        self._set_url_valid(None)\n        self._set_credentials_valid(None)\n        self._url_preview.setText(text)\n\n    def _set_url_valid(self, valid):\n        if valid is self._url_is_valid:\n            return\n\n        self._url_is_valid = valid\n        self._set_input_valid_state(self._url_input, valid)\n\n    def _set_credentials_valid(self, valid):\n        if self._credentials_are_valid is valid:\n            return\n\n        self._credentials_are_valid = valid\n        self._set_input_valid_state(self._username_input, valid)\n        self._set_input_valid_state(self._password_input, valid)\n\n    def _on_url_enter_press(self):\n        if self._login_ayon_btn.isVisible():\n            self._login_with_ayon_server()\n        else:\n            self._set_input_focus(self._username_input)\n\n    def _on_user_change(self, username):\n        self._username_preview.setText(username)\n\n    def _on_username_enter_press(self):\n        self._set_input_focus(self._password_input)\n\n    def _on_password_enter_press(self):\n        self._on_login_click()\n\n    def _on_password_state_change(self, show_password):\n        if show_password:\n            placeholder_text = \"&lt; MySecret124 &gt;\"\n            echo_mode = QtWidgets.QLineEdit.Normal\n        else:\n            placeholder_text = \"&lt; *********** &gt;\"\n            echo_mode = QtWidgets.QLineEdit.Password\n\n        self._password_input.setEchoMode(echo_mode)\n        self._password_input.setPlaceholderText(placeholder_text)\n\n    def _on_username_edit_click(self):\n        self._username_edit_mode = True\n        self._update_states_by_edit_mode()\n\n    def _on_url_edit_click(self):\n        self._url_edit_mode = True\n        self._update_states_by_edit_mode()\n\n    def _on_logout_click(self):\n        dialog = LogoutConfirmDialog(self)\n        dialog.exec_()\n        if dialog.get_result():\n            self._result = (None, None, None, True)\n            self.accept()\n\n    def _on_login_click(self):\n        self._login()\n\n    def _validate_url(self):\n        \"\"\"Use url from input to connect and change window state on success.\n\n        Todos:\n            Threaded check.\n        \"\"\"\n\n        url = self._url_input.text()\n        valid_url = None\n        try:\n            valid_url = validate_url(url)\n\n        except UrlError as exc:\n            parts = [f\"&lt;b&gt;{exc.title}&lt;/b&gt;\"]\n            parts.extend(f\"- {hint}\" for hint in exc.hints)\n            self._set_message(\"&lt;br/&gt;\".join(parts))\n\n        except KeyboardInterrupt:\n            # Reraise KeyboardInterrupt error\n            raise\n\n        except BaseException:\n            self._set_unexpected_error()\n            return\n\n        if valid_url is None:\n            return False\n\n        self._url_input.setText(valid_url)\n        return True\n\n    def _login(self):\n        if (\n            not self._login_btn.isEnabled()\n            and not self._confirm_btn.isEnabled()\n        ):\n            return\n\n        if not self._url_is_valid:\n            self._set_url_valid(self._validate_url())\n\n        if not self._url_is_valid:\n            self._set_input_focus(self._url_input)\n            self._set_credentials_valid(None)\n            return\n\n        self._clear_message()\n\n        url = self._url_input.text()\n        username = self._username_input.text()\n        password = self._password_input.text()\n        try:\n            token = login_to_server(url, username, password)\n        except BaseException:\n            self._set_unexpected_error()\n            return\n\n        if token is not None:\n            self._result = (url, token, username, False)\n            self.accept()\n            return\n\n        self._set_credentials_valid(False)\n        message_lines = [\"&lt;b&gt;Invalid credentials&lt;/b&gt;\"]\n        if not username.strip():\n            message_lines.append(\"- Username is not filled\")\n\n        if not password.strip():\n            message_lines.append(\"- Password is not filled\")\n\n        if username and password:\n            message_lines.append(\"- Check your credentials\")\n\n        self._set_message(\"&lt;br/&gt;\".join(message_lines))\n        self._set_input_focus(self._username_input)\n\n    def _set_input_focus(self, widget):\n        widget.setFocus(QtCore.Qt.MouseFocusReason)\n\n    def _set_input_valid_state(self, widget, valid):\n        state = \"\"\n        if valid is True:\n            state = \"valid\"\n        elif valid is False:\n            state = \"invalid\"\n        set_style_property(widget, \"state\", state)\n\n    def _set_message(self, message):\n        self._message_label.setText(message)\n\n    def _clear_message(self):\n        self._message_label.setText(\"\")\n\n    def _set_unexpected_error(self):\n        # TODO add traceback somewhere\n        # - maybe a button to show or copy?\n        traceback.print_exc()\n        lines = [\n            \"&lt;b&gt;Unexpected error happened&lt;/b&gt;\",\n            \"- Can be caused by wrong url (leading elsewhere)\"\n        ]\n        self._set_message(\"&lt;br/&gt;\".join(lines))\n\n    def _set_api_key(self, api_key):\n        if not api_key or len(api_key) &lt; 3:\n            self._api_preview.setText(api_key or \"\")\n            return\n\n        api_key_len = len(api_key)\n        offset = 6\n        if api_key_len &lt; offset:\n            offset = api_key_len // 2\n        api_key = api_key[:offset] + \".\" * (api_key_len - offset)\n\n        self._api_preview.setText(api_key)\n\n    def _login_with_ayon_server(self):\n        if (\n            not self._login_btn.isEnabled()\n            and not self._confirm_btn.isEnabled()\n        ):\n            return\n\n        if not self._url_is_valid:\n            self._set_url_valid(self._validate_url())\n\n        if not self._url_is_valid:\n            self._set_input_focus(self._url_input)\n            self._set_credentials_valid(None)\n            return\n\n        self._clear_message()\n\n        url = self._url_input.text()\n        version = get_server_version(url)\n        if version &lt; (1, 3, 2):\n            self._set_message(\n                \"&lt;b&gt;AYON server does not support easy login&lt;/b&gt;\"\n                \"&lt;br/&gt;- Server version must be at least 1.3.2\"\n            )\n            return\n\n        self._set_overlay_visible(True)\n\n        if self._server_handler is not None:\n            self._server_handler.stop()\n            self._server_handler = None\n        self._server_handler = LoginServerListener(url)\n        redir_url = f\"http://localhost:{self._server_handler.port}\"\n        webbrowser.open_new_tab(f\"{url}/?auth_redirect={redir_url}\")\n        self._server_handler.start()\n        self._server_timer.start()\n\n    def _stop_server_handler(self):\n        server_handler, self._server_handler = self._server_handler, None\n        if server_handler is None:\n            return\n\n        server_handler.stop()\n        self._set_overlay_visible(False)\n\n    def _on_server_cancel(self):\n        self._stop_server_handler()\n\n    def _on_server_timer(self):\n        if self._server_handler is None:\n            self._server_timer.stop()\n            self._set_overlay_visible(False)\n            return\n\n        token = self._server_handler.get_token()\n        if not token:\n            return\n\n        # TODO better solution\n        # This is hack to allow server serve the page resources for a little\n        # bit longer\n        if self._server_timer_counter &lt; 3:\n            self._server_timer_counter += 1\n            return\n\n        # Stop server and timer\n        self._stop_server_handler()\n        self._server_timer.stop()\n\n        # Collect user data\n        url = self._url_input.text()\n        user = get_user(url, token)\n        username = user[\"name\"]\n        # Validate username if is forced\n        input_username = self._username_input.text()\n        if self._force_username and username != input_username:\n            # Different user was used\n            self._set_message(\n                \"&lt;b&gt;Invalid user&lt;/b&gt;\"\n                f\"&lt;br/&gt;You're logged as '{username}' in your default\"\n                f\" browser but user '{input_username}' should be used.\"\n                \"&lt;br/&gt;Please change user in your default browser, or login\"\n                \" using credentials.\"\n            )\n            return\n\n        self._result = (url, token, username, False)\n        self.accept()\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/index.html#common.ayon_common.connection.ui.ServerLoginWindow.result","title":"<code>result()</code>","text":"<p>Result url and token or login.</p> <p>Returns:</p> Type Description <p>Union[Tuple[str, str], Tuple[None, None]]: Url and token used for login if was successful otherwise are both set to None.</p> Source code in <code>common/ayon_common/connection/ui/login_window.py</code> <pre><code>def result(self):\n    \"\"\"Result url and token or login.\n\n    Returns:\n        Union[Tuple[str, str], Tuple[None, None]]: Url and token used for\n            login if was successful otherwise are both set to None.\n    \"\"\"\n    return self._result\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/index.html#common.ayon_common.connection.ui.ServerLoginWindow.set_force_username","title":"<code>set_force_username(force_username)</code>","text":"<p>Force filled username.</p> <p>User cannot change username if enabled.</p> <p>Parameters:</p> Name Type Description Default <code>force_username</code> <code>bool</code> <p>If True, username will be forced.</p> required Source code in <code>common/ayon_common/connection/ui/login_window.py</code> <pre><code>def set_force_username(self, force_username: bool):\n    \"\"\"Force filled username.\n\n    User cannot change username if enabled.\n\n    Args:\n        force_username (bool): If True, username will be forced.\n\n    \"\"\"\n    self._force_username = force_username\n    self._username_input.setEnabled(not force_username)\n    self._url_input.setEnabled(not force_username)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/index.html#common.ayon_common.connection.ui.ask_to_login","title":"<code>ask_to_login(url=None, username=None, force_username=None, always_on_top=False)</code>","text":"<p>Ask user to login using Qt dialog.</p> <p>Function creates new QApplication if is not created yet.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>Server url that will be prefilled in dialog.</p> <code>None</code> <code>username</code> <code>Optional[str]</code> <p>Username that will be prefilled in dialog.</p> <code>None</code> <code>force_username</code> <code>Optional[bool]</code> <p>If True, username passed to function will be forced.</p> <code>None</code> <code>always_on_top</code> <code>Optional[bool]</code> <p>Window will be drawn on top of other windows.</p> <code>False</code> <p>Returns:</p> Type Description <p>tuple[str, str, str]: Returns Url, user's token and username. Url can be changed during dialog lifetime that's why the url is returned.</p> Source code in <code>common/ayon_common/connection/ui/login_window.py</code> <pre><code>def ask_to_login(\n    url=None,\n    username=None,\n    force_username=None,\n    always_on_top=False\n):\n    \"\"\"Ask user to login using Qt dialog.\n\n    Function creates new QApplication if is not created yet.\n\n    Args:\n        url (Optional[str]): Server url that will be prefilled in dialog.\n        username (Optional[str]): Username that will be prefilled in dialog.\n        force_username (Optional[bool]): If True, username passed to function\n            will be forced.\n        always_on_top (Optional[bool]): Window will be drawn on top of\n            other windows.\n\n    Returns:\n        tuple[str, str, str]: Returns Url, user's token and username. Url can\n            be changed during dialog lifetime that's why the url is returned.\n    \"\"\"\n\n    app_instance = get_qt_app()\n\n    window = ServerLoginWindow()\n    if always_on_top:\n        window.setWindowFlags(\n            window.windowFlags()\n            | QtCore.Qt.WindowStaysOnTopHint\n        )\n\n    if url:\n        window.set_url(url)\n\n    if username:\n        window.set_username(username)\n\n    if force_username is None:\n        force_username = False\n    window.set_force_username(force_username)\n\n    if not app_instance.startingUp():\n        window.show()\n        window.raise_()\n        window.activateWindow()\n        window.showNormal()\n        window.exec_()\n    else:\n        window.open()\n        app_instance.exec_()\n    result = window.result()\n    out_url, out_token, out_username, _ = result\n    return out_url, out_token, out_username\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/index.html#common.ayon_common.connection.ui.change_user","title":"<code>change_user(url, username, api_key, always_on_top=False)</code>","text":"<p>Ask user to login using Qt dialog.</p> <p>Function creates new QApplication if is not created yet.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server url that will be prefilled in dialog.</p> required <code>username</code> <code>str</code> <p>Username that will be prefilled in dialog.</p> required <code>api_key</code> <code>str</code> <p>API key that will be prefilled in dialog.</p> required <code>always_on_top</code> <code>Optional[bool]</code> <p>Window will be drawn on top of other windows.</p> <code>False</code> <p>Returns:</p> Type Description <p>Tuple[str, str]: Returns Url and user's token. Url can be changed during dialog lifetime that's why the url is returned.</p> Source code in <code>common/ayon_common/connection/ui/login_window.py</code> <pre><code>def change_user(url, username, api_key, always_on_top=False):\n    \"\"\"Ask user to login using Qt dialog.\n\n    Function creates new QApplication if is not created yet.\n\n    Args:\n        url (str): Server url that will be prefilled in dialog.\n        username (str): Username that will be prefilled in dialog.\n        api_key (str): API key that will be prefilled in dialog.\n        always_on_top (Optional[bool]): Window will be drawn on top of\n            other windows.\n\n    Returns:\n        Tuple[str, str]: Returns Url and user's token. Url can be changed\n            during dialog lifetime that's why the url is returned.\n    \"\"\"\n\n    app_instance = get_qt_app()\n    window = ServerLoginWindow()\n    if always_on_top:\n        window.setWindowFlags(\n            window.windowFlags()\n            | QtCore.Qt.WindowStaysOnTopHint\n        )\n    window.set_logged_in(True, url, username, api_key)\n\n    if not app_instance.startingUp():\n        window.exec_()\n    else:\n        window.open()\n        # This can become main Qt loop. Maybe should live elsewhere\n        app_instance.exec_()\n    return window.result()\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/index.html#common.ayon_common.connection.ui.invalid_credentials","title":"<code>invalid_credentials(message, always_on_top=False)</code>","text":"<p>Tell user that his credentials are invalid.</p> <p>This functionality is used when credentials that user did use were     not received from keyring or login window.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Some information that can caller define.</p> required <code>always_on_top</code> <code>Optional[bool]</code> <p>Window will be drawn on top of other windows.</p> <code>False</code> Source code in <code>common/ayon_common/connection/ui/invalid_window.py</code> <pre><code>def invalid_credentials(message, always_on_top=False):\n    \"\"\"Tell user that his credentials are invalid.\n\n    This functionality is used when credentials that user did use were\n        not received from keyring or login window.\n\n    Args:\n        message (str): Some information that can caller define.\n        always_on_top (Optional[bool]): Window will be drawn on top of\n            other windows.\n    \"\"\"\n\n    app_instance = get_qt_app()\n    window = InvalidCredentialsWindow(message)\n    if always_on_top:\n        window.setWindowFlags(\n            window.windowFlags()\n            | QtCore.Qt.WindowStaysOnTopHint\n        )\n\n    if not app_instance.startingUp():\n        window.exec_()\n    else:\n        window.open()\n        # This can become main Qt loop. Maybe should live elsewhere\n        app_instance.exec_()\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/__main__.html","title":"__main__","text":""},{"location":"autoapi/common/ayon_common/connection/ui/invalid_window.html","title":"invalid_window","text":""},{"location":"autoapi/common/ayon_common/connection/ui/invalid_window.html#common.ayon_common.connection.ui.invalid_window.InvalidCredentialsWindow","title":"<code>InvalidCredentialsWindow</code>","text":"<p>               Bases: <code>QDialog</code></p> Source code in <code>common/ayon_common/connection/ui/invalid_window.py</code> <pre><code>class InvalidCredentialsWindow(QtWidgets.QDialog):\n    default_width = 420\n    default_height = 170\n\n    def __init__(self, message, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        icon_path = get_icon_path()\n        icon = QtGui.QIcon(icon_path)\n        self.setWindowIcon(icon)\n        self.setWindowTitle(\"Invalid credentials\")\n\n        info_widget = QtWidgets.QWidget(self)\n\n        message_label = url_cred_sep = None\n        if message:\n            # --- Custom message ---\n            message_label = QtWidgets.QLabel(message, info_widget)\n            message_label.setWordWrap(True)\n            message_label.setTextInteractionFlags(\n                QtCore.Qt.TextBrowserInteraction\n            )\n\n            # --- URL separator ---\n            url_cred_sep = QtWidgets.QFrame(info_widget)\n            url_cred_sep.setObjectName(\"Separator\")\n            url_cred_sep.setMinimumHeight(2)\n            url_cred_sep.setMaximumHeight(2)\n\n        common_label = QtWidgets.QLabel(\n            (\n                \" You are running AYON launcher in &lt;b&gt;'bypass login'&lt;/b&gt;\"\n                \" mode. Meaning your AYON connection information is\"\n                \" defined by environment variables.\"\n                \"&lt;br/&gt;&lt;br/&gt;Please contact your administrator or use valid\"\n                \" credentials.\"\n            ),\n            info_widget\n        )\n        common_label.setWordWrap(True)\n        common_label.setTextInteractionFlags(QtCore.Qt.TextBrowserInteraction)\n\n        info_layout = QtWidgets.QVBoxLayout(info_widget)\n        info_layout.setContentsMargins(0, 0, 0, 0)\n        if message_label is not None:\n            info_layout.addWidget(message_label, 0)\n            info_layout.addWidget(url_cred_sep, 0)\n        info_layout.addWidget(common_label, 0)\n\n        footer_widget = QtWidgets.QWidget(self)\n        close_btn = QtWidgets.QPushButton(\"Close\", footer_widget)\n\n        footer_layout = QtWidgets.QHBoxLayout(footer_widget)\n        footer_layout.setContentsMargins(0, 0, 0, 0)\n        footer_layout.addStretch(1)\n        footer_layout.addWidget(close_btn, 0)\n\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.addWidget(info_widget, 0)\n        main_layout.addStretch(1)\n        main_layout.addWidget(footer_widget, 0)\n\n        close_btn.clicked.connect(self._on_close_click)\n\n        self._first_show = True\n        self._message_label = message_label\n        self._common_label = common_label\n\n    def resizeEvent(self, event):\n        super().resizeEvent(event)\n        print(self.size())\n\n    def showEvent(self, event):\n        super().showEvent(event)\n        if self._first_show:\n            self._first_show = False\n            self._on_first_show()\n\n    def _on_first_show(self):\n        self.setStyleSheet(load_stylesheet())\n        self.resize(self.default_width, self.default_height)\n        self._center_window()\n\n    def _center_window(self):\n        \"\"\"Move window to center of screen.\"\"\"\n\n        if hasattr(QtWidgets.QApplication, \"desktop\"):\n            desktop = QtWidgets.QApplication.desktop()\n            screen_idx = desktop.screenNumber(self)\n            screen_geo = desktop.screenGeometry(screen_idx)\n        else:\n            screen = self.screen()\n            screen_geo = screen.geometry()\n\n        geo = self.frameGeometry()\n        geo.moveCenter(screen_geo.center())\n        if geo.y() &lt; screen_geo.y():\n            geo.setY(screen_geo.y())\n        self.move(geo.topLeft())\n\n    def _on_close_click(self):\n        self.close()\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/invalid_window.html#common.ayon_common.connection.ui.invalid_window.invalid_credentials","title":"<code>invalid_credentials(message, always_on_top=False)</code>","text":"<p>Tell user that his credentials are invalid.</p> <p>This functionality is used when credentials that user did use were     not received from keyring or login window.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Some information that can caller define.</p> required <code>always_on_top</code> <code>Optional[bool]</code> <p>Window will be drawn on top of other windows.</p> <code>False</code> Source code in <code>common/ayon_common/connection/ui/invalid_window.py</code> <pre><code>def invalid_credentials(message, always_on_top=False):\n    \"\"\"Tell user that his credentials are invalid.\n\n    This functionality is used when credentials that user did use were\n        not received from keyring or login window.\n\n    Args:\n        message (str): Some information that can caller define.\n        always_on_top (Optional[bool]): Window will be drawn on top of\n            other windows.\n    \"\"\"\n\n    app_instance = get_qt_app()\n    window = InvalidCredentialsWindow(message)\n    if always_on_top:\n        window.setWindowFlags(\n            window.windowFlags()\n            | QtCore.Qt.WindowStaysOnTopHint\n        )\n\n    if not app_instance.startingUp():\n        window.exec_()\n    else:\n        window.open()\n        # This can become main Qt loop. Maybe should live elsewhere\n        app_instance.exec_()\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/login_window.html","title":"login_window","text":""},{"location":"autoapi/common/ayon_common/connection/ui/login_window.html#common.ayon_common.connection.ui.login_window.ServerLoginWindow","title":"<code>ServerLoginWindow</code>","text":"<p>               Bases: <code>QDialog</code></p> Source code in <code>common/ayon_common/connection/ui/login_window.py</code> <pre><code>class ServerLoginWindow(QtWidgets.QDialog):\n    default_width = 410\n    default_height = 170\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        icon_path = get_icon_path()\n        icon = QtGui.QIcon(icon_path)\n        self.setWindowIcon(icon)\n        self.setWindowTitle(\"Login to server\")\n\n        edit_icon_path = get_resource_path(\"edit.png\")\n        edit_icon = QtGui.QIcon(edit_icon_path)\n\n        # --- URL page ---\n        login_bg_widget = QtWidgets.QWidget(self)\n\n        login_widget = QtWidgets.QWidget(login_bg_widget)\n\n        user_cred_widget = QtWidgets.QWidget(login_widget)\n\n        url_label = QtWidgets.QLabel(\"URL:\", user_cred_widget)\n\n        url_widget = QtWidgets.QWidget(user_cred_widget)\n\n        url_input = PlaceholderLineEdit(url_widget)\n        url_input.setPlaceholderText(\"&lt; https://ayon.server.com &gt;\")\n\n        url_preview = QtWidgets.QLineEdit(url_widget)\n        url_preview.setReadOnly(True)\n        url_preview.setObjectName(\"LikeDisabledInput\")\n\n        url_edit_btn = PressHoverButton(user_cred_widget)\n        url_edit_btn.setIcon(edit_icon)\n        url_edit_btn.setObjectName(\"PasswordBtn\")\n\n        url_layout = QtWidgets.QHBoxLayout(url_widget)\n        url_layout.setContentsMargins(0, 0, 0, 0)\n        url_layout.addWidget(url_input, 1)\n        url_layout.addWidget(url_preview, 1)\n\n        # --- URL separator ---\n        url_cred_sep = QtWidgets.QFrame(login_bg_widget)\n        url_cred_sep.setObjectName(\"Separator\")\n        url_cred_sep.setMinimumHeight(2)\n        url_cred_sep.setMaximumHeight(2)\n\n        # --- Login page ---\n        login_ayon_btn = QtWidgets.QPushButton(\n            \"Login with AYON server\", login_widget\n        )\n        login_ayon_btn.setIcon(QtGui.QIcon(get_ayon_default_icon_path()))\n        login_ayon_btn.setObjectName(\"AYONLoginButton\")\n\n        login_or_sep = OrSeparator(login_bg_widget)\n\n        username_label = QtWidgets.QLabel(\"Username:\", user_cred_widget)\n\n        username_widget = QtWidgets.QWidget(user_cred_widget)\n\n        username_input = PlaceholderLineEdit(username_widget)\n        username_input.setPlaceholderText(\"&lt; Artist &gt;\")\n\n        username_preview = QtWidgets.QLineEdit(username_widget)\n        username_preview.setReadOnly(True)\n        username_preview.setObjectName(\"LikeDisabledInput\")\n\n        username_edit_btn = PressHoverButton(user_cred_widget)\n        username_edit_btn.setIcon(edit_icon)\n        username_edit_btn.setObjectName(\"PasswordBtn\")\n\n        username_layout = QtWidgets.QHBoxLayout(username_widget)\n        username_layout.setContentsMargins(0, 0, 0, 0)\n        username_layout.addWidget(username_input, 1)\n        username_layout.addWidget(username_preview, 1)\n\n        password_label = QtWidgets.QLabel(\"Password:\", user_cred_widget)\n        password_input = PlaceholderLineEdit(user_cred_widget)\n        password_input.setPlaceholderText(\"&lt; *********** &gt;\")\n        password_input.setEchoMode(PlaceholderLineEdit.Password)\n\n        api_label = QtWidgets.QLabel(\"API key:\", user_cred_widget)\n        api_preview = QtWidgets.QLineEdit(user_cred_widget)\n        api_preview.setReadOnly(True)\n        api_preview.setObjectName(\"LikeDisabledInput\")\n\n        show_password_btn = ShowPasswordButton(user_cred_widget)\n        # Cannot be focused, user has to click with mouse\n        show_password_btn.setFocusPolicy(QtCore.Qt.NoFocus)\n\n        cred_msg_sep = QtWidgets.QFrame(login_bg_widget)\n        cred_msg_sep.setObjectName(\"Separator\")\n        cred_msg_sep.setMinimumHeight(2)\n        cred_msg_sep.setMaximumHeight(2)\n\n        # --- Credentials inputs ---\n        user_cred_layout = QtWidgets.QGridLayout(user_cred_widget)\n        user_cred_layout.setContentsMargins(0, 0, 0, 0)\n        user_cred_layout.setSpacing(6)\n        row = 0\n\n        user_cred_layout.addWidget(url_label, row, 0, 1, 1)\n        user_cred_layout.addWidget(url_widget, row, 1, 1, 1)\n        user_cred_layout.addWidget(url_edit_btn, row, 2, 1, 1)\n        row += 1\n\n        user_cred_layout.addWidget(url_cred_sep, row, 0, 1, 3)\n        row += 1\n\n        user_cred_layout.addWidget(login_ayon_btn, row, 0, 1, 3)\n        row += 1\n\n        user_cred_layout.addWidget(login_or_sep, row, 0, 1, 3)\n        row += 1\n\n        user_cred_layout.addWidget(username_label, row, 0, 1, 1)\n        user_cred_layout.addWidget(username_widget, row, 1, 1, 1)\n        user_cred_layout.addWidget(username_edit_btn, row, 2, 2, 1)\n        row += 1\n\n        user_cred_layout.addWidget(api_label, row, 0, 1, 1)\n        user_cred_layout.addWidget(api_preview, row, 1, 1, 1)\n        row += 1\n\n        user_cred_layout.addWidget(password_label, row, 0, 1, 1)\n        user_cred_layout.addWidget(password_input, row, 1, 1, 1)\n        user_cred_layout.addWidget(show_password_btn, row, 2, 1, 1)\n        row += 1\n\n        user_cred_layout.addWidget(cred_msg_sep, row, 0, 1, 3)\n        row += 1\n\n        user_cred_layout.setColumnStretch(0, 0)\n        user_cred_layout.setColumnStretch(1, 1)\n        user_cred_layout.setColumnStretch(2, 0)\n\n        login_layout = QtWidgets.QVBoxLayout(login_widget)\n        login_layout.setContentsMargins(0, 0, 0, 0)\n        login_layout.addWidget(user_cred_widget, 1)\n\n        # --- Messages ---\n        # Messages for users (e.g. invalid url etc.)\n        message_label = QtWidgets.QLabel(login_bg_widget)\n        message_label.setWordWrap(True)\n        message_label.setTextInteractionFlags(QtCore.Qt.TextBrowserInteraction)\n\n        footer_widget = QtWidgets.QWidget(login_bg_widget)\n        logout_btn = QtWidgets.QPushButton(\"Logout\", footer_widget)\n        user_message = QtWidgets.QLabel(footer_widget)\n        login_btn = QtWidgets.QPushButton(\"Login\", footer_widget)\n        confirm_btn = QtWidgets.QPushButton(\"Confirm\", footer_widget)\n\n        # Disable default button behavior\n        # - it is handled based on current input state\n        for btn in (\n            show_password_btn,\n            login_ayon_btn,\n            logout_btn,\n            login_btn,\n            confirm_btn,\n        ):\n            btn.setDefault(False)\n            btn.setAutoDefault(False)\n\n        footer_layout = QtWidgets.QHBoxLayout(footer_widget)\n        footer_layout.setContentsMargins(0, 0, 0, 0)\n        footer_layout.setSpacing(6)\n        footer_layout.addWidget(logout_btn, 0)\n        footer_layout.addWidget(user_message, 1)\n        footer_layout.addWidget(login_btn, 0)\n        footer_layout.addWidget(confirm_btn, 0)\n\n        login_bg_layout = QtWidgets.QVBoxLayout(login_bg_widget)\n        login_bg_layout.setContentsMargins(0, 0, 0, 0)\n        login_bg_layout.setSpacing(6)\n        login_bg_layout.addWidget(login_widget, 0)\n        login_bg_layout.addWidget(message_label, 0)\n        login_bg_layout.addStretch(1)\n        login_bg_layout.addWidget(footer_widget, 0)\n\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.setContentsMargins(10, 10, 10, 10)\n        main_layout.setSpacing(6)\n        main_layout.addWidget(login_bg_widget, 1)\n\n        # --- Overlay ---\n        overlay_frame = OverlayWidget(self)\n        overlay_frame.set_visible(False)\n\n        server_timer = QtCore.QTimer()\n        server_timer.setInterval(100)\n\n        server_timer.timeout.connect(self._on_server_timer)\n        overlay_frame.cancelled.connect(self._on_server_cancel)\n        url_input.textChanged.connect(self._on_url_change)\n        url_input.returnPressed.connect(self._on_url_enter_press)\n        login_ayon_btn.clicked.connect(self._login_with_ayon_server)\n        username_input.textChanged.connect(self._on_user_change)\n        username_input.returnPressed.connect(self._on_username_enter_press)\n        password_input.returnPressed.connect(self._on_password_enter_press)\n        show_password_btn.state_changed.connect(self._on_password_state_change)\n        url_edit_btn.clicked.connect(self._on_url_edit_click)\n        username_edit_btn.clicked.connect(self._on_username_edit_click)\n        logout_btn.clicked.connect(self._on_logout_click)\n        login_btn.clicked.connect(self._on_login_click)\n        confirm_btn.clicked.connect(self._on_login_click)\n\n        self._overlay_visible = False\n        self._overlay_frame = overlay_frame\n\n        self._login_bg_widget = login_bg_widget\n\n        self._login_widget = login_widget\n\n        self._login_or_sep = login_or_sep\n        self._login_ayon_btn = login_ayon_btn\n\n        self._url_widget = url_widget\n        self._url_input = url_input\n        self._url_preview = url_preview\n        self._url_edit_btn = url_edit_btn\n\n        self._user_cred_widget = user_cred_widget\n        self._username_input = username_input\n        self._username_preview = username_preview\n        self._username_edit_btn = username_edit_btn\n\n        self._password_label = password_label\n        self._password_input = password_input\n        self._show_password_btn = show_password_btn\n        self._api_label = api_label\n        self._api_preview = api_preview\n\n        self._message_label = message_label\n\n        self._logout_btn = logout_btn\n        self._user_message = user_message\n        self._login_btn = login_btn\n        self._confirm_btn = confirm_btn\n\n        self._url_is_valid = None\n        self._credentials_are_valid = None\n        self._result = (None, None, None, False)\n        self._first_show = True\n        self._force_username = False\n\n        self._allow_logout = False\n        self._logged_in = False\n        self._url_edit_mode = False\n        self._username_edit_mode = False\n\n        self._server_timer_counter = 0\n        self._server_timer = server_timer\n        self._server_handler = None\n\n    def set_allow_logout(self, allow_logout):\n        if allow_logout is self._allow_logout:\n            return\n        self._allow_logout = allow_logout\n\n        self._update_states_by_edit_mode()\n\n    def set_url(self, url):\n        self._url_preview.setText(url)\n        self._url_input.setText(url)\n        self._validate_url()\n\n    def set_username(self, username):\n        self._username_preview.setText(username)\n        self._username_input.setText(username)\n\n    def set_force_username(self, force_username: bool):\n        \"\"\"Force filled username.\n\n        User cannot change username if enabled.\n\n        Args:\n            force_username (bool): If True, username will be forced.\n\n        \"\"\"\n        self._force_username = force_username\n        self._username_input.setEnabled(not force_username)\n        self._url_input.setEnabled(not force_username)\n\n    def set_logged_in(\n        self,\n        logged_in,\n        url=None,\n        username=None,\n        api_key=None,\n        allow_logout=None\n    ):\n        if url is not None:\n            self.set_url(url)\n\n        if username is not None:\n            self.set_username(username)\n\n        if api_key:\n            self._set_api_key(api_key)\n\n        if logged_in and allow_logout is None:\n            allow_logout = True\n\n        self._set_logged_in(logged_in)\n\n        if allow_logout:\n            self.set_allow_logout(True)\n        elif allow_logout is False:\n            self.set_allow_logout(False)\n\n    def showEvent(self, event):\n        super().showEvent(event)\n        if self._first_show:\n            self._first_show = False\n            self._on_first_show()\n\n        self._update_overlay_position()\n\n    def resizeEvent(self, event):\n        super().resizeEvent(event)\n        self._update_overlay_position()\n\n    def closeEvent(self, event):\n        self._on_server_cancel()\n        super().closeEvent(event)\n\n    def result(self):\n        \"\"\"Result url and token or login.\n\n        Returns:\n            Union[Tuple[str, str], Tuple[None, None]]: Url and token used for\n                login if was successful otherwise are both set to None.\n        \"\"\"\n        return self._result\n\n    def _set_logged_in(self, logged_in):\n        if logged_in is self._logged_in:\n            return\n        self._logged_in = logged_in\n\n        self._update_states_by_edit_mode()\n\n    def _set_url_edit_mode(self, edit_mode):\n        if self._url_edit_mode is not edit_mode:\n            self._url_edit_mode = edit_mode\n            self._update_states_by_edit_mode()\n\n    def _set_username_edit_mode(self, edit_mode):\n        if self._username_edit_mode is not edit_mode:\n            self._username_edit_mode = edit_mode\n            self._update_states_by_edit_mode()\n\n    def _get_url_user_edit(self):\n        url_edit = True\n        if self._logged_in and not self._url_edit_mode:\n            url_edit = False\n        user_edit = url_edit\n        if not user_edit and self._logged_in and self._username_edit_mode:\n            user_edit = True\n        return url_edit, user_edit\n\n    def _update_states_by_edit_mode(self):\n        url_edit, user_edit = self._get_url_user_edit()\n\n        self._url_preview.setVisible(not url_edit)\n        self._url_input.setVisible(url_edit)\n        self._url_edit_btn.setVisible(self._allow_logout and not url_edit)\n\n        self._login_ayon_btn.setVisible(user_edit)\n        self._login_or_sep.setVisible(user_edit)\n\n        self._username_preview.setVisible(not user_edit)\n        self._username_input.setVisible(user_edit)\n        self._username_edit_btn.setVisible(\n            self._allow_logout and not user_edit\n        )\n\n        self._api_preview.setVisible(not user_edit)\n        self._api_label.setVisible(not user_edit)\n\n        self._password_label.setVisible(user_edit)\n        self._show_password_btn.setVisible(user_edit)\n        self._password_input.setVisible(user_edit)\n\n        self._logout_btn.setVisible(self._allow_logout and self._logged_in)\n        self._login_btn.setVisible(not self._allow_logout)\n        self._confirm_btn.setVisible(self._allow_logout)\n        self._update_login_btn_state(url_edit, user_edit)\n\n    def _update_login_btn_state(self, url_edit=None, user_edit=None, url=None):\n        if url_edit is None:\n            url_edit, user_edit = self._get_url_user_edit()\n\n        if url is None:\n            url = self._url_input.text()\n\n        enabled = bool(url) and (url_edit or user_edit)\n\n        self._login_btn.setEnabled(enabled)\n        self._confirm_btn.setEnabled(enabled)\n\n    def _update_overlay_position(self):\n        if not self._overlay_visible:\n            return\n        self._overlay_frame.resize(self.size())\n\n    def _set_overlay_visible(self, visible):\n        if self._overlay_visible is visible:\n            return\n        self._overlay_visible = visible\n        self._overlay_frame.set_visible(visible)\n        self._login_bg_widget.setEnabled(not visible)\n        self._update_overlay_position()\n\n    def _on_first_show(self):\n        self.setStyleSheet(load_stylesheet())\n        msh = self.minimumSizeHint()\n        self.setMinimumWidth(max(msh.width(), 320))\n\n        self.resize(self.default_width, self.default_height)\n\n        self._center_window()\n        if self._allow_logout is None:\n            self.set_allow_logout(False)\n\n        self._update_states_by_edit_mode()\n        if not self._url_input.text():\n            widget = self._url_input\n        elif not self._username_input.text():\n            widget = self._username_input\n        else:\n            widget = self._password_input\n\n        self._set_input_focus(widget)\n\n    def _center_window(self):\n        \"\"\"Move window to center of screen.\"\"\"\n\n        if hasattr(QtWidgets.QApplication, \"desktop\"):\n            desktop = QtWidgets.QApplication.desktop()\n            screen_idx = desktop.screenNumber(self)\n            screen_geo = desktop.screenGeometry(screen_idx)\n        else:\n            screen = self.screen()\n            screen_geo = screen.geometry()\n\n        geo = self.frameGeometry()\n        geo.moveCenter(screen_geo.center())\n        if geo.y() &lt; screen_geo.y():\n            geo.setY(screen_geo.y())\n        self.move(geo.topLeft())\n\n    def _on_url_change(self, text):\n        self._update_login_btn_state(url=text)\n        self._set_url_valid(None)\n        self._set_credentials_valid(None)\n        self._url_preview.setText(text)\n\n    def _set_url_valid(self, valid):\n        if valid is self._url_is_valid:\n            return\n\n        self._url_is_valid = valid\n        self._set_input_valid_state(self._url_input, valid)\n\n    def _set_credentials_valid(self, valid):\n        if self._credentials_are_valid is valid:\n            return\n\n        self._credentials_are_valid = valid\n        self._set_input_valid_state(self._username_input, valid)\n        self._set_input_valid_state(self._password_input, valid)\n\n    def _on_url_enter_press(self):\n        if self._login_ayon_btn.isVisible():\n            self._login_with_ayon_server()\n        else:\n            self._set_input_focus(self._username_input)\n\n    def _on_user_change(self, username):\n        self._username_preview.setText(username)\n\n    def _on_username_enter_press(self):\n        self._set_input_focus(self._password_input)\n\n    def _on_password_enter_press(self):\n        self._on_login_click()\n\n    def _on_password_state_change(self, show_password):\n        if show_password:\n            placeholder_text = \"&lt; MySecret124 &gt;\"\n            echo_mode = QtWidgets.QLineEdit.Normal\n        else:\n            placeholder_text = \"&lt; *********** &gt;\"\n            echo_mode = QtWidgets.QLineEdit.Password\n\n        self._password_input.setEchoMode(echo_mode)\n        self._password_input.setPlaceholderText(placeholder_text)\n\n    def _on_username_edit_click(self):\n        self._username_edit_mode = True\n        self._update_states_by_edit_mode()\n\n    def _on_url_edit_click(self):\n        self._url_edit_mode = True\n        self._update_states_by_edit_mode()\n\n    def _on_logout_click(self):\n        dialog = LogoutConfirmDialog(self)\n        dialog.exec_()\n        if dialog.get_result():\n            self._result = (None, None, None, True)\n            self.accept()\n\n    def _on_login_click(self):\n        self._login()\n\n    def _validate_url(self):\n        \"\"\"Use url from input to connect and change window state on success.\n\n        Todos:\n            Threaded check.\n        \"\"\"\n\n        url = self._url_input.text()\n        valid_url = None\n        try:\n            valid_url = validate_url(url)\n\n        except UrlError as exc:\n            parts = [f\"&lt;b&gt;{exc.title}&lt;/b&gt;\"]\n            parts.extend(f\"- {hint}\" for hint in exc.hints)\n            self._set_message(\"&lt;br/&gt;\".join(parts))\n\n        except KeyboardInterrupt:\n            # Reraise KeyboardInterrupt error\n            raise\n\n        except BaseException:\n            self._set_unexpected_error()\n            return\n\n        if valid_url is None:\n            return False\n\n        self._url_input.setText(valid_url)\n        return True\n\n    def _login(self):\n        if (\n            not self._login_btn.isEnabled()\n            and not self._confirm_btn.isEnabled()\n        ):\n            return\n\n        if not self._url_is_valid:\n            self._set_url_valid(self._validate_url())\n\n        if not self._url_is_valid:\n            self._set_input_focus(self._url_input)\n            self._set_credentials_valid(None)\n            return\n\n        self._clear_message()\n\n        url = self._url_input.text()\n        username = self._username_input.text()\n        password = self._password_input.text()\n        try:\n            token = login_to_server(url, username, password)\n        except BaseException:\n            self._set_unexpected_error()\n            return\n\n        if token is not None:\n            self._result = (url, token, username, False)\n            self.accept()\n            return\n\n        self._set_credentials_valid(False)\n        message_lines = [\"&lt;b&gt;Invalid credentials&lt;/b&gt;\"]\n        if not username.strip():\n            message_lines.append(\"- Username is not filled\")\n\n        if not password.strip():\n            message_lines.append(\"- Password is not filled\")\n\n        if username and password:\n            message_lines.append(\"- Check your credentials\")\n\n        self._set_message(\"&lt;br/&gt;\".join(message_lines))\n        self._set_input_focus(self._username_input)\n\n    def _set_input_focus(self, widget):\n        widget.setFocus(QtCore.Qt.MouseFocusReason)\n\n    def _set_input_valid_state(self, widget, valid):\n        state = \"\"\n        if valid is True:\n            state = \"valid\"\n        elif valid is False:\n            state = \"invalid\"\n        set_style_property(widget, \"state\", state)\n\n    def _set_message(self, message):\n        self._message_label.setText(message)\n\n    def _clear_message(self):\n        self._message_label.setText(\"\")\n\n    def _set_unexpected_error(self):\n        # TODO add traceback somewhere\n        # - maybe a button to show or copy?\n        traceback.print_exc()\n        lines = [\n            \"&lt;b&gt;Unexpected error happened&lt;/b&gt;\",\n            \"- Can be caused by wrong url (leading elsewhere)\"\n        ]\n        self._set_message(\"&lt;br/&gt;\".join(lines))\n\n    def _set_api_key(self, api_key):\n        if not api_key or len(api_key) &lt; 3:\n            self._api_preview.setText(api_key or \"\")\n            return\n\n        api_key_len = len(api_key)\n        offset = 6\n        if api_key_len &lt; offset:\n            offset = api_key_len // 2\n        api_key = api_key[:offset] + \".\" * (api_key_len - offset)\n\n        self._api_preview.setText(api_key)\n\n    def _login_with_ayon_server(self):\n        if (\n            not self._login_btn.isEnabled()\n            and not self._confirm_btn.isEnabled()\n        ):\n            return\n\n        if not self._url_is_valid:\n            self._set_url_valid(self._validate_url())\n\n        if not self._url_is_valid:\n            self._set_input_focus(self._url_input)\n            self._set_credentials_valid(None)\n            return\n\n        self._clear_message()\n\n        url = self._url_input.text()\n        version = get_server_version(url)\n        if version &lt; (1, 3, 2):\n            self._set_message(\n                \"&lt;b&gt;AYON server does not support easy login&lt;/b&gt;\"\n                \"&lt;br/&gt;- Server version must be at least 1.3.2\"\n            )\n            return\n\n        self._set_overlay_visible(True)\n\n        if self._server_handler is not None:\n            self._server_handler.stop()\n            self._server_handler = None\n        self._server_handler = LoginServerListener(url)\n        redir_url = f\"http://localhost:{self._server_handler.port}\"\n        webbrowser.open_new_tab(f\"{url}/?auth_redirect={redir_url}\")\n        self._server_handler.start()\n        self._server_timer.start()\n\n    def _stop_server_handler(self):\n        server_handler, self._server_handler = self._server_handler, None\n        if server_handler is None:\n            return\n\n        server_handler.stop()\n        self._set_overlay_visible(False)\n\n    def _on_server_cancel(self):\n        self._stop_server_handler()\n\n    def _on_server_timer(self):\n        if self._server_handler is None:\n            self._server_timer.stop()\n            self._set_overlay_visible(False)\n            return\n\n        token = self._server_handler.get_token()\n        if not token:\n            return\n\n        # TODO better solution\n        # This is hack to allow server serve the page resources for a little\n        # bit longer\n        if self._server_timer_counter &lt; 3:\n            self._server_timer_counter += 1\n            return\n\n        # Stop server and timer\n        self._stop_server_handler()\n        self._server_timer.stop()\n\n        # Collect user data\n        url = self._url_input.text()\n        user = get_user(url, token)\n        username = user[\"name\"]\n        # Validate username if is forced\n        input_username = self._username_input.text()\n        if self._force_username and username != input_username:\n            # Different user was used\n            self._set_message(\n                \"&lt;b&gt;Invalid user&lt;/b&gt;\"\n                f\"&lt;br/&gt;You're logged as '{username}' in your default\"\n                f\" browser but user '{input_username}' should be used.\"\n                \"&lt;br/&gt;Please change user in your default browser, or login\"\n                \" using credentials.\"\n            )\n            return\n\n        self._result = (url, token, username, False)\n        self.accept()\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/login_window.html#common.ayon_common.connection.ui.login_window.ServerLoginWindow.result","title":"<code>result()</code>","text":"<p>Result url and token or login.</p> <p>Returns:</p> Type Description <p>Union[Tuple[str, str], Tuple[None, None]]: Url and token used for login if was successful otherwise are both set to None.</p> Source code in <code>common/ayon_common/connection/ui/login_window.py</code> <pre><code>def result(self):\n    \"\"\"Result url and token or login.\n\n    Returns:\n        Union[Tuple[str, str], Tuple[None, None]]: Url and token used for\n            login if was successful otherwise are both set to None.\n    \"\"\"\n    return self._result\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/login_window.html#common.ayon_common.connection.ui.login_window.ServerLoginWindow.set_force_username","title":"<code>set_force_username(force_username)</code>","text":"<p>Force filled username.</p> <p>User cannot change username if enabled.</p> <p>Parameters:</p> Name Type Description Default <code>force_username</code> <code>bool</code> <p>If True, username will be forced.</p> required Source code in <code>common/ayon_common/connection/ui/login_window.py</code> <pre><code>def set_force_username(self, force_username: bool):\n    \"\"\"Force filled username.\n\n    User cannot change username if enabled.\n\n    Args:\n        force_username (bool): If True, username will be forced.\n\n    \"\"\"\n    self._force_username = force_username\n    self._username_input.setEnabled(not force_username)\n    self._url_input.setEnabled(not force_username)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/login_window.html#common.ayon_common.connection.ui.login_window.ask_to_login","title":"<code>ask_to_login(url=None, username=None, force_username=None, always_on_top=False)</code>","text":"<p>Ask user to login using Qt dialog.</p> <p>Function creates new QApplication if is not created yet.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>Server url that will be prefilled in dialog.</p> <code>None</code> <code>username</code> <code>Optional[str]</code> <p>Username that will be prefilled in dialog.</p> <code>None</code> <code>force_username</code> <code>Optional[bool]</code> <p>If True, username passed to function will be forced.</p> <code>None</code> <code>always_on_top</code> <code>Optional[bool]</code> <p>Window will be drawn on top of other windows.</p> <code>False</code> <p>Returns:</p> Type Description <p>tuple[str, str, str]: Returns Url, user's token and username. Url can be changed during dialog lifetime that's why the url is returned.</p> Source code in <code>common/ayon_common/connection/ui/login_window.py</code> <pre><code>def ask_to_login(\n    url=None,\n    username=None,\n    force_username=None,\n    always_on_top=False\n):\n    \"\"\"Ask user to login using Qt dialog.\n\n    Function creates new QApplication if is not created yet.\n\n    Args:\n        url (Optional[str]): Server url that will be prefilled in dialog.\n        username (Optional[str]): Username that will be prefilled in dialog.\n        force_username (Optional[bool]): If True, username passed to function\n            will be forced.\n        always_on_top (Optional[bool]): Window will be drawn on top of\n            other windows.\n\n    Returns:\n        tuple[str, str, str]: Returns Url, user's token and username. Url can\n            be changed during dialog lifetime that's why the url is returned.\n    \"\"\"\n\n    app_instance = get_qt_app()\n\n    window = ServerLoginWindow()\n    if always_on_top:\n        window.setWindowFlags(\n            window.windowFlags()\n            | QtCore.Qt.WindowStaysOnTopHint\n        )\n\n    if url:\n        window.set_url(url)\n\n    if username:\n        window.set_username(username)\n\n    if force_username is None:\n        force_username = False\n    window.set_force_username(force_username)\n\n    if not app_instance.startingUp():\n        window.show()\n        window.raise_()\n        window.activateWindow()\n        window.showNormal()\n        window.exec_()\n    else:\n        window.open()\n        app_instance.exec_()\n    result = window.result()\n    out_url, out_token, out_username, _ = result\n    return out_url, out_token, out_username\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/login_window.html#common.ayon_common.connection.ui.login_window.change_user","title":"<code>change_user(url, username, api_key, always_on_top=False)</code>","text":"<p>Ask user to login using Qt dialog.</p> <p>Function creates new QApplication if is not created yet.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server url that will be prefilled in dialog.</p> required <code>username</code> <code>str</code> <p>Username that will be prefilled in dialog.</p> required <code>api_key</code> <code>str</code> <p>API key that will be prefilled in dialog.</p> required <code>always_on_top</code> <code>Optional[bool]</code> <p>Window will be drawn on top of other windows.</p> <code>False</code> <p>Returns:</p> Type Description <p>Tuple[str, str]: Returns Url and user's token. Url can be changed during dialog lifetime that's why the url is returned.</p> Source code in <code>common/ayon_common/connection/ui/login_window.py</code> <pre><code>def change_user(url, username, api_key, always_on_top=False):\n    \"\"\"Ask user to login using Qt dialog.\n\n    Function creates new QApplication if is not created yet.\n\n    Args:\n        url (str): Server url that will be prefilled in dialog.\n        username (str): Username that will be prefilled in dialog.\n        api_key (str): API key that will be prefilled in dialog.\n        always_on_top (Optional[bool]): Window will be drawn on top of\n            other windows.\n\n    Returns:\n        Tuple[str, str]: Returns Url and user's token. Url can be changed\n            during dialog lifetime that's why the url is returned.\n    \"\"\"\n\n    app_instance = get_qt_app()\n    window = ServerLoginWindow()\n    if always_on_top:\n        window.setWindowFlags(\n            window.windowFlags()\n            | QtCore.Qt.WindowStaysOnTopHint\n        )\n    window.set_logged_in(True, url, username, api_key)\n\n    if not app_instance.startingUp():\n        window.exec_()\n    else:\n        window.open()\n        # This can become main Qt loop. Maybe should live elsewhere\n        app_instance.exec_()\n    return window.result()\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/server.html","title":"server","text":""},{"location":"autoapi/common/ayon_common/connection/ui/server.html#common.ayon_common.connection.ui.server.LoginServerHandler","title":"<code>LoginServerHandler</code>","text":"<p>               Bases: <code>BaseHTTPRequestHandler</code></p> <p>Login server handler.</p> Source code in <code>common/ayon_common/connection/ui/server.py</code> <pre><code>class LoginServerHandler(BaseHTTPRequestHandler):\n    \"\"\"Login server handler.\"\"\"\n\n    def do_GET(self):\n        \"\"\"Override to handle requests ourselves.\"\"\"\n        if self.path == \"/index.css\":\n            filepath = get_resource_path(\"index.css\")\n            with open(filepath, \"rb\") as stream:\n                content = stream.read()\n            content_type = \"text/css\"\n        elif self.path == \"/favicon.ico\":\n            filepath = get_resource_path(\"favicon.ico\")\n            with open(filepath, \"rb\") as stream:\n                content = stream.read()\n            content_type = \"image/x-icon\"\n        else:\n            parsed_path = urlparse(self.path)\n            query = parse_qs(parsed_path.query)\n            tokens = query.get(\"token\")\n            access_token = None\n            if tokens:\n                access_token = tokens[0]\n            self.server.set_token(access_token)\n\n            content_type = \"text/html\"\n            if access_token:\n                filepath = get_resource_path(\"success.html\")\n            else:\n                filepath = get_resource_path(\"failed.html\")\n            with open(filepath, \"rb\") as stream:\n                content = stream.read()\n\n        # Set header with content type\n        self.send_response(200)\n        self.send_header(\"Content-type\", content_type)\n        self.end_headers()\n        self.wfile.write(content)\n\n    def log_message(self, *args, **kwargs):\n        # Avoid crash in process without stderr\n        # - e.g. UI build on windows\n        if sys.stderr is not None:\n            super().log_message(*args, **kwargs)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/server.html#common.ayon_common.connection.ui.server.LoginServerHandler.do_GET","title":"<code>do_GET()</code>","text":"<p>Override to handle requests ourselves.</p> Source code in <code>common/ayon_common/connection/ui/server.py</code> <pre><code>def do_GET(self):\n    \"\"\"Override to handle requests ourselves.\"\"\"\n    if self.path == \"/index.css\":\n        filepath = get_resource_path(\"index.css\")\n        with open(filepath, \"rb\") as stream:\n            content = stream.read()\n        content_type = \"text/css\"\n    elif self.path == \"/favicon.ico\":\n        filepath = get_resource_path(\"favicon.ico\")\n        with open(filepath, \"rb\") as stream:\n            content = stream.read()\n        content_type = \"image/x-icon\"\n    else:\n        parsed_path = urlparse(self.path)\n        query = parse_qs(parsed_path.query)\n        tokens = query.get(\"token\")\n        access_token = None\n        if tokens:\n            access_token = tokens[0]\n        self.server.set_token(access_token)\n\n        content_type = \"text/html\"\n        if access_token:\n            filepath = get_resource_path(\"success.html\")\n        else:\n            filepath = get_resource_path(\"failed.html\")\n        with open(filepath, \"rb\") as stream:\n            content = stream.read()\n\n    # Set header with content type\n    self.send_response(200)\n    self.send_header(\"Content-type\", content_type)\n    self.end_headers()\n    self.wfile.write(content)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/widgets.html","title":"widgets","text":""},{"location":"autoapi/common/ayon_common/connection/ui/widgets.html#common.ayon_common.connection.ui.widgets.PlaceholderLineEdit","title":"<code>PlaceholderLineEdit</code>","text":"<p>               Bases: <code>QLineEdit</code></p> <p>Set placeholder color of QLineEdit in Qt 5.12 and higher.</p> Source code in <code>common/ayon_common/connection/ui/widgets.py</code> <pre><code>class PlaceholderLineEdit(QtWidgets.QLineEdit):\n    \"\"\"Set placeholder color of QLineEdit in Qt 5.12 and higher.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(PlaceholderLineEdit, self).__init__(*args, **kwargs)\n        # Change placeholder palette color\n        if hasattr(QtGui.QPalette, \"PlaceholderText\"):\n            filter_palette = self.palette()\n            color = QtGui.QColor(\"#D3D8DE\")\n            color.setAlpha(67)\n            filter_palette.setColor(\n                QtGui.QPalette.PlaceholderText,\n                color\n            )\n            self.setPalette(filter_palette)\n</code></pre>"},{"location":"autoapi/common/ayon_common/connection/ui/widgets.html#common.ayon_common.connection.ui.widgets.PressHoverButton","title":"<code>PressHoverButton</code>","text":"<p>               Bases: <code>QPushButton</code></p> <p>Keep track about mouse press/release and enter/leave.</p> Source code in <code>common/ayon_common/connection/ui/widgets.py</code> <pre><code>class PressHoverButton(QtWidgets.QPushButton):\n    \"\"\"Keep track about mouse press/release and enter/leave.\"\"\"\n\n    _mouse_pressed = False\n    _mouse_hovered = False\n    change_state = QtCore.Signal(bool)\n\n    def mousePressEvent(self, event):\n        self._mouse_pressed = True\n        self._mouse_hovered = True\n        self.change_state.emit(self._mouse_hovered)\n        super(PressHoverButton, self).mousePressEvent(event)\n\n    def mouseReleaseEvent(self, event):\n        self._mouse_pressed = False\n        self._mouse_hovered = False\n        self.change_state.emit(self._mouse_hovered)\n        super(PressHoverButton, self).mouseReleaseEvent(event)\n\n    def mouseMoveEvent(self, event):\n        mouse_pos = self.mapFromGlobal(QtGui.QCursor.pos())\n        under_mouse = self.rect().contains(mouse_pos)\n        if under_mouse != self._mouse_hovered:\n            self._mouse_hovered = under_mouse\n            self.change_state.emit(self._mouse_hovered)\n\n        super(PressHoverButton, self).mouseMoveEvent(event)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html","title":"distribution","text":""},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution","title":"<code>AYONDistribution</code>","text":"<p>Distribution control.</p> <p>Receive information from server what addons and dependency packages should be available locally and prepare/validate their distribution.</p> <p>Arguments are available for testing of the class.</p> <p>Parameters:</p> Name Type Description Default <code>addon_dirpath</code> <code>Optional[str]</code> <p>Where addons will be stored.</p> <code>None</code> <code>dependency_dirpath</code> <code>Optional[str]</code> <p>Where dependencies will be stored.</p> <code>None</code> <code>dist_factory</code> <code>Optional[DownloadFactory]</code> <p>Factory which cares about downloading of items based on source type.</p> <code>None</code> <code>installers_info</code> <code>Optional[list[dict[str, Any]]]</code> <p>List of prepared installers' info.</p> <code>NOT_SET</code> <code>addons_info</code> <code>Optional[list[dict[str, Any]]]</code> <p>List of prepared addons' info.</p> <code>NOT_SET</code> <code>dependency_packages_info</code> <code>Optional[list[dict[str, Any]]]</code> <p>Info about packages from server.</p> <code>NOT_SET</code> <code>bundles_info</code> <code>Optional[dict[str, Any]]</code> <p>Info about bundles.</p> <code>NOT_SET</code> <code>studio_bundle_name</code> <code>Optional[str]</code> <p>Name of studio bundle to use.</p> <code>NOT_SET</code> <code>project_bundle_name</code> <code>Optional[str]</code> <p>Name of project bundle to use.</p> <code>NOT_SET</code> <code>project_name</code> <code>Optional[str]</code> <p>Name of project for which project bundle can be auto-detected.</p> <code>NOT_SET</code> <code>use_staging</code> <code>Optional[bool]</code> <p>Use staging versions of an addon. If not passed, 'is_staging_enabled' is used as default value.</p> <code>None</code> <code>use_dev</code> <code>Optional[bool]</code> <p>Use develop versions of an addon. If not passed, 'is_dev_mode_enabled' is used as default value.</p> <code>None</code> <code>skip_installer_dist</code> <code>bool</code> <p>Skip installer distribution. This is for testing purposes and for running from code.</p> <code>False</code> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>class AYONDistribution:\n    \"\"\"Distribution control.\n\n    Receive information from server what addons and dependency packages\n    should be available locally and prepare/validate their distribution.\n\n    Arguments are available for testing of the class.\n\n    Args:\n        addon_dirpath (Optional[str]): Where addons will be stored.\n        dependency_dirpath (Optional[str]): Where dependencies will be stored.\n        dist_factory (Optional[DownloadFactory]): Factory which cares about\n            downloading of items based on source type.\n        installers_info (Optional[list[dict[str, Any]]]): List of prepared\n            installers' info.\n        addons_info (Optional[list[dict[str, Any]]]): List of prepared\n            addons' info.\n        dependency_packages_info (Optional[list[dict[str, Any]]]): Info\n            about packages from server.\n        bundles_info (Optional[dict[str, Any]]): Info about\n            bundles.\n        studio_bundle_name (Optional[str]): Name of studio bundle to use.\n        project_bundle_name (Optional[str]): Name of project bundle to use.\n        project_name (Optional[str]): Name of project for which project bundle\n            can be auto-detected.\n        use_staging (Optional[bool]): Use staging versions of an addon.\n            If not passed, 'is_staging_enabled' is used as default value.\n        use_dev (Optional[bool]): Use develop versions of an addon.\n            If not passed, 'is_dev_mode_enabled' is used as default value.\n        skip_installer_dist (bool): Skip installer distribution. This\n            is for testing purposes and for running from code.\n\n    \"\"\"\n    def __init__(\n        self,\n        addon_dirpath: Optional[str] = None,\n        dependency_dirpath: Optional[str] = None,\n        dist_factory: Optional[DownloadFactory] = None,\n        installers_info: Optional[list[dict[str, Any]]] = NOT_SET,\n        addons_info: Optional[list[dict[str, Any]]] = NOT_SET,\n        dependency_packages_info: Optional[list[dict[str, Any]]] = NOT_SET,\n        bundles_info: Optional[list[dict[str, Any]]] = NOT_SET,\n        studio_bundle_name: Optional[str] = NOT_SET,\n        project_bundle_name: Optional[str] = NOT_SET,\n        project_name: Optional[str] = NOT_SET,\n        use_staging: Optional[bool] = None,\n        use_dev: Optional[bool] = None,\n        active_user: Optional[bool] = None,\n        skip_installer_dist: bool = False,\n    ):\n        self._log = None\n\n        self._dist_started = False\n\n        self._addons_dirpath = addon_dirpath or get_addons_dir()\n        self._dependency_dirpath = dependency_dirpath or get_dependencies_dir()\n        self._dist_factory = (\n            dist_factory or get_default_download_factory()\n        )\n\n        if studio_bundle_name is NOT_SET:\n            studio_bundle_name = (\n                os.environ.get(\"AYON_STUDIO_BUNDLE_NAME\") or NOT_SET\n            )\n\n        if project_bundle_name is NOT_SET:\n            project_bundle_name = (\n                os.environ.get(\"AYON_BUNDLE_NAME\") or NOT_SET\n            )\n\n        if project_name is NOT_SET:\n            project_name = os.environ.get(\"AYON_PROJECT_NAME\") or NOT_SET\n\n        # Where addon zip files and dependency packages are downloaded\n        self._dist_download_dirs = []\n        self._dist_unzip_dirs = []\n\n        self._dist_addons_unzip_temp = os.path.join(\n            self._addons_dirpath, \".unzip_temp\"\n        )\n        self._dist_dep_packages_unzip_temp = os.path.join(\n            self._dependency_dirpath, \".unzip_temp\"\n        )\n\n        self._installers_info = installers_info\n        self._installer_items = NOT_SET\n        self._expected_installer_version = NOT_SET\n        self._installer_item = NOT_SET\n        self._installer_executable = NOT_SET\n        self._skip_installer_dist = skip_installer_dist\n        self._installer_filepath = None\n        self._installer_dist_error = None\n\n        # Raw addons data from server\n        self._addons_info = addons_info\n        # Prepared data as Addon objects\n        self._addon_items = NOT_SET\n        # Distrubtion items of addons\n        #   - only those addons and versions that should be distributed\n        self._addon_dist_items = NOT_SET\n\n        # Raw dependency packages data from server\n        self._dependency_packages_info = dependency_packages_info\n        # Prepared dependency packages as objects\n        self._dependency_packages_items = NOT_SET\n        # Dependency package item that should be used\n        self._dependency_package_item = NOT_SET\n        # Distribution item of dependency package\n        self._dependency_dist_item = NOT_SET\n\n        # Raw bundles data from server\n        self._bundles_info = bundles_info\n        # Bundles as objects\n        self._bundle_items = NOT_SET\n\n        # Bundle that should be used in production\n        self._studio_production_bundle = NOT_SET\n        # Bundle that should be used in staging\n        self._studio_staging_bundle = NOT_SET\n        # Bundle that should be used in dev\n        self._studio_dev_bundle = NOT_SET\n        # Boolean that defines if staging bundle should be used\n        self._use_staging = use_staging\n        self._use_dev = use_dev\n        self._active_user = active_user\n\n        # Specific bundle name should be used\n        self._studio_bundle_name = studio_bundle_name\n        self._project_bundle_name = project_bundle_name\n        self._project_name = project_name\n\n        # Final bundles that will be used\n        self._studio_bundle = NOT_SET\n        self._project_bundle = NOT_SET\n\n    @property\n    def active_user(self) -&gt; str:\n        if self._active_user is None:\n            user = ayon_api.get_user()\n            self._active_user = user[\"name\"]\n        return self._active_user\n\n    @property\n    def use_staging(self) -&gt; bool:\n        \"\"\"Staging version of a bundle should be used.\n\n        This value is completely ignored if specific bundle name should\n            be used.\n\n        Returns:\n            bool: True if staging version should be used.\n\n        \"\"\"\n        if self._use_staging is None:\n            self._use_staging = is_staging_enabled()\n\n        if self._use_staging and self.use_dev:\n            self._use_staging = False\n        return self._use_staging\n\n    @property\n    def use_dev(self) -&gt; bool:\n        \"\"\"Develop version of a bundle should be used.\n\n        This value is completely ignored if specific bundle name should\n            be used.\n\n        Returns:\n            bool: True if staging version should be used.\n\n        \"\"\"\n        if self._use_dev is None:\n            if self._studio_bundle_name is NOT_SET:\n                self._use_dev = is_dev_mode_enabled()\n            else:\n                bundle = next(\n                    (\n                        bundle\n                        for bundle in self.bundle_items\n                        if bundle.name == self._studio_bundle_name\n                    ),\n                    None\n                )\n                if bundle is not None:\n                    self._use_dev = bundle.is_dev\n                else:\n                    self._use_dev = False\n        return self._use_dev\n\n    @property\n    def log(self) -&gt; logging.Logger:\n        \"\"\"Helper to access logger.\n\n        Returns:\n             logging.Logger: Logger instance.\n\n        \"\"\"\n        if self._log is None:\n            self._log = logging.getLogger(self.__class__.__name__)\n        return self._log\n\n    @property\n    def bundles_info(self) -&gt; list[dict[str, Any]]:\n        \"\"\"\n\n        Returns:\n            list[dict[str, Any]]: Bundles information from server.\n\n        \"\"\"\n        if self._bundles_info is NOT_SET:\n            self._bundles_info = ayon_api.get_bundles()[\"bundles\"]\n        return self._bundles_info\n\n    @property\n    def bundle_items(self) -&gt; list[Bundle]:\n        \"\"\"\n\n        Returns:\n            list[Bundle]: List of bundles info.\n\n        \"\"\"\n        if self._bundle_items is NOT_SET:\n            self._bundle_items = [\n                Bundle.from_dict(info)\n                for info in self.bundles_info\n            ]\n        return self._bundle_items\n\n    @property\n    def studio_production_bundle(self) -&gt; Optional[Bundle]:\n        \"\"\"\n\n        Returns:\n            Optional[Bundle]: Bundle that should be used in production.\n\n        \"\"\"\n        if self._studio_production_bundle is NOT_SET:\n            self._prepare_bundles()\n        return self._studio_production_bundle\n\n    @property\n    def studio_staging_bundle(self) -&gt; Optional[Bundle]:\n        \"\"\"\n\n        Returns:\n            Optional[Bundle]: Bundle that should be used in staging.\n\n        \"\"\"\n        if self._studio_staging_bundle is NOT_SET:\n            self._prepare_bundles()\n        return self._studio_staging_bundle\n\n    @property\n    def studio_dev_bundle(self) -&gt; Optional[Bundle]:\n        \"\"\"\n\n        Returns:\n            Optional[Bundle]: Bundle that should be used in dev.\n\n        \"\"\"\n        if self._studio_dev_bundle is NOT_SET:\n            self._prepare_bundles()\n        return self._studio_dev_bundle\n\n    @property\n    def studio_bundle_to_use(self) -&gt; Optional[Bundle]:\n        \"\"\"\n\n        Returns:\n            Optional[Bundle]: Bundle that should be used in distribution.\n\n        \"\"\"\n        if self._studio_bundle is not NOT_SET:\n            return self._studio_bundle\n\n        self._prepare_bundles()\n        if self._studio_bundle_name is NOT_SET:\n            if self.use_staging:\n                self._studio_bundle = self.studio_staging_bundle\n            elif self.use_dev:\n                self._studio_bundle = self.studio_dev_bundle\n            else:\n                self._studio_bundle = self.studio_production_bundle\n            return self._studio_bundle\n\n        bundle = next(\n            (\n                bundle\n                for bundle in self.bundle_items\n                if bundle.name == self._studio_bundle_name\n            ),\n            None\n        )\n        if bundle is None:\n            raise BundleNotFoundError(self._studio_bundle_name)\n        self._studio_bundle = bundle\n        return self._studio_bundle\n\n    @property\n    def project_bundle_to_use(self) -&gt; Optional[Bundle]:\n        \"\"\"Bundle that will be used for distribution.\n\n        Bundle that should be used can be affected by 'project_bundle_name',\n            'project_name', 'studio_bundle_name' or 'use_staging'.\n\n        Returns:\n            Optional[Bundle]: Bundle that will be used for distribution\n                or None.\n\n        Raises:\n            BundleNotFoundError: When bundle name to use is defined\n                but is not available on server.\n\n        \"\"\"\n        if not self._project_bundle:\n            project_bundle = self._get_project_bundle()\n            if not project_bundle:\n                project_bundle = self.studio_bundle_to_use\n            self._project_bundle = project_bundle\n        return self._project_bundle\n\n    @property\n    def project_bundle_name_to_use(self) -&gt; Optional[str]:\n        \"\"\"Name of bundle that will be used for distribution.\n\n        Returns:\n            Optional[str]: Name of bundle that will be used for\n                distribution.\n\n        \"\"\"\n        bundle = self.project_bundle_to_use\n        return None if bundle is None else bundle.name\n\n    @property\n    def installers_info(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Installers information from server.\n\n        Returns:\n            list[dict[str, Any]]: Installers information from server.\n\n        \"\"\"\n        if self._installers_info is NOT_SET:\n            self._installers_info = ayon_api.get_installers()[\"installers\"]\n        return self._installers_info\n\n    @property\n    def installer_items(self) -&gt; list[Installer]:\n        \"\"\"Installers as objects.\n\n        Returns:\n            list[Installer]: List of installers info from server.\n\n        \"\"\"\n        if self._installer_items is NOT_SET:\n            self._installer_items = [\n                Installer.from_dict(info)\n                for info in self.installers_info\n            ]\n        return self._installer_items\n\n    @property\n    def expected_installer_version(self) -&gt; Optional[str]:\n        \"\"\"Excepted installer version.\n\n        Returns:\n            Optional[str]: Expected installer version or None defined by\n                bundle that should be used.\n\n        \"\"\"\n        if self._expected_installer_version is not NOT_SET:\n            return self._expected_installer_version\n\n        bundle = self.project_bundle_to_use\n        version = None if bundle is None else bundle.installer_version\n        self._expected_installer_version = version\n        return version\n\n    @property\n    def need_installer_change(self) -&gt; bool:\n        \"\"\"Installer should be changed.\n\n        Current installer is using different version than what is expected\n            by bundle.\n\n        Returns:\n            bool: True if installer should be changed.\n\n        \"\"\"\n        if self._skip_installer_dist:\n            return False\n\n        version = os.getenv(\"AYON_VERSION\")\n        return version != self.expected_installer_version\n\n    @property\n    def need_installer_distribution(self) -&gt; bool:\n        \"\"\"Installer distribution is needed.\n\n        Todos:\n            Add option to skip if running from code?\n\n        Returns:\n            bool: True if installer distribution is needed.\n\n        \"\"\"\n        if not self.need_installer_change:\n            return False\n\n        return self.installer_executable is None\n\n    @property\n    def installer_dist_error(self) -&gt; Optional[str]:\n        \"\"\"Installer distribution error message.\n\n        Returns:\n              Optional[str]: Error that happened during installer\n                distribution.\n\n        \"\"\"\n        return self._installer_dist_error\n\n    @property\n    def installer_filepath(self) -&gt; Optional[str]:\n        \"\"\"Path to a distribution package/installer.\n\n        This can be used as reference for user where to find downloaded\n            installer on disk and distribute it manually.\n\n        Returns:\n            Optional[str]: Path to installer.\n\n        \"\"\"\n        return self._installer_filepath\n\n    @property\n    def installer_executable(self) -&gt; Optional[str]:\n        \"\"\"Path to installer executable that should be used.\n\n        Notes:\n            The 'installer_executable' is maybe confusing naming. It might be\n                called 'ayon_executable'?\n\n        Returns:\n            Optional[str]: Path to installer executable that should be\n                used. None if executable is not found and must be distributed\n                or bundle does not have defined an installer to use.\n\n        \"\"\"\n        if self._installer_executable is not NOT_SET:\n            return self._installer_executable\n\n        path = None\n        if not self.need_installer_change:\n            self._installer_executable = sys.executable\n            return self._installer_executable\n\n        # Compare existing executable with current executable\n        current_executable = sys.executable\n        # Use 'ayon.exe' for executable lookup on Windows\n        root, filename = os.path.split(current_executable)\n        if filename == \"ayon_console.exe\":\n            current_executable = os.path.join(root, \"ayon.exe\")\n\n        # TODO look to expected target install directory too\n        executables_info = get_executables_info_by_version(\n            self.expected_installer_version)\n        for executable_info in executables_info:\n            executable_path = executable_info.get(\"executable\")\n            if (\n                not os.path.exists(executable_path)\n                or executable_path == current_executable\n            ):\n                continue\n            path = executable_path\n            break\n\n        # Make sure current executable filename is used on Windows\n        if path and filename == \"ayon_console.exe\":\n            path = os.path.join(os.path.dirname(path), filename)\n\n        if path:\n            self._installer_executable = path\n            return path\n\n        # Guess based on \"expected\" path of the version\n        # - is used if the AYON is already installed at target location but is\n        #   missing in the metadata file\n        current_version = os.environ[\"AYON_VERSION\"]\n        platform_name = platform.system().lower()\n        if platform_name in {\"windows\", \"linux\"}:\n            executable_dir, exe_name = os.path.split(sys.executable)\n            install_root, dirname = os.path.split(executable_dir)\n            if current_version in dirname:\n                new_dirname = dirname.replace(\n                    current_version,\n                    self.expected_installer_version\n                )\n                executable = os.path.join(\n                    install_root, new_dirname, exe_name\n                )\n                if os.path.exists(executable):\n                    path = executable\n\n        elif platform_name == \"darwin\":\n            app_name = f\"AYON {self.expected_installer_version}.app\"\n            excutable = f\"/Applications/{app_name}/Contents/MacOS/ayon\"\n            if os.path.exists(excutable):\n                path = excutable\n\n        self._installer_executable = path\n        return path\n\n    @property\n    def installer_item(self):\n        \"\"\"Installer item that should be used for distribution.\n\n        Returns:\n            Union[Installer, None]: Installer information item.\n\n        \"\"\"\n        if self._installer_item is not NOT_SET:\n            return self._installer_item\n\n        final_item = None\n        expected_version = self.expected_installer_version\n        if expected_version:\n            final_item = next(\n                (\n                    item\n                    for item in self.installer_items\n                    if (\n                        item.version == expected_version\n                        and item.platform_name == platform.system().lower()\n                    )\n                ),\n                None\n            )\n\n        self._installer_item = final_item\n        return final_item\n\n    def distribute_installer(self):\n        \"\"\"Distribute installer.\"\"\"\n\n        installer_item = self.installer_item\n        if installer_item is None:\n            self._installer_executable = None\n            self._installer_dist_error = (\n                f\"Bundle '{self.project_bundle_name_to_use}'\"\n                \" does not have set installer version to use.\"\n            )\n            return\n\n        downloader_data = {\n            \"type\": \"installer\",\n            \"version\": installer_item.version,\n            \"filename\": installer_item.filename,\n        }\n\n        tmp_used = False\n        downloads_dir = get_downloads_dir()\n        if not downloads_dir or not os.path.exists(downloads_dir):\n            tmp_used = True\n            downloads_dir = tempfile.mkdtemp(prefix=\"ayon_installer\")\n            change_permissions_recursive(downloads_dir)\n\n        dist_item = None\n        try:\n            dist_item = InstallerDistributionItem(\n                tmp_used,\n                downloads_dir,\n                UpdateState.OUTDATED,\n                installer_item.checksum,\n                installer_item.checksum_algorithm,\n                self._dist_factory,\n                list(installer_item.sources),\n                downloader_data,\n                f\"Installer {installer_item.version}\",\n            )\n\n            if (\n                platform.system().lower() != \"windows\"\n                and dist_item.is_missing_permissions\n            ):\n                self._installer_dist_error = (\n                    \"Your user does not have required permissions to update\"\n                    \" AYON launcher.\"\n                    \" Please contact your administrator, or use user\"\n                    \" with permissions.\"\n                )\n                return\n\n            for result in dist_item.distribute():\n                if result:\n                    break\n\n            self._installer_executable = dist_item.executable\n            if dist_item.installer_error is not None:\n                self._installer_dist_error = dist_item.installer_error\n\n            elif dist_item.state == UpdateState.MISS_SOURCE_FILES:\n                self._installer_dist_error = (\n                    \"Couldn't find valid installer source for required\"\n                    f\" AYON launcher version {installer_item.version}.\"\n                )\n\n            elif not self._installer_executable:\n                self._installer_dist_error = (\n                    \"Couldn't find installed AYON launcher.\"\n                    \" Please try to launch AYON manually.\"\n                )\n\n        except Exception:\n            self.log.warning(\n                \"Installer distribution failed do to unknown reasons.\",\n                exc_info=True\n            )\n            self._installer_dist_error = (\n                f\"Distribution of AYON launcher {installer_item.version}\"\n                \" failed with unexpected reason.\"\n            )\n\n        finally:\n            if dist_item is not None:\n                self._installer_filepath = dist_item.installer_path\n\n            if tmp_used and os.path.exists(downloads_dir):\n                shutil.rmtree(downloads_dir)\n\n    @property\n    def addons_info(self) -&gt; dict[str, dict[str, Any]]:\n        \"\"\"Server information about available addons.\n\n        Returns:\n            dict[str, dict[str, Any]]: Addon info by addon name.\n\n        \"\"\"\n        if self._addons_info is NOT_SET:\n            # Use details to get information about client.zip\n            server_info = ayon_api.get_addons_info(details=True)\n            self._addons_info = server_info[\"addons\"]\n        return self._addons_info\n\n    @property\n    def addon_items(self) -&gt; dict[str, AddonInfo]:\n        \"\"\"Information about available addons on server.\n\n        Addons may require distribution of files. For those addons will be\n        created 'DistributionItem' handling distribution itself.\n\n        Returns:\n            dict[str, AddonInfo]: Addon info object by addon name.\n\n        \"\"\"\n        if self._addon_items is NOT_SET:\n            addons_info = {}\n            for addon in self.addons_info:\n                addon_info = AddonInfo.from_dict(addon)\n                addons_info[addon_info.name] = addon_info\n            self._addon_items = addons_info\n        return self._addon_items\n\n    @property\n    def dependency_packages_info(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Server information about available dependency packages.\n\n        Notes:\n            For testing purposes it is possible to pass dependency packages\n                information to '__init__'.\n\n        Returns:\n            list[dict[str, Any]]: Dependency packages information.\n\n        \"\"\"\n        if self._dependency_packages_info is NOT_SET:\n            self._dependency_packages_info = (\n                ayon_api.get_dependency_packages())[\"packages\"]\n        return self._dependency_packages_info\n\n    @property\n    def dependency_packages_items(self) -&gt; dict[str, DependencyItem]:\n        \"\"\"Dependency packages as objects.\n\n        Returns:\n            dict[str, DependencyItem]: Dependency packages as objects by name.\n\n        \"\"\"\n        if self._dependency_packages_items is NOT_SET:\n            dependenc_package_items = {}\n            for item in self.dependency_packages_info:\n                item = DependencyItem.from_dict(item)\n                dependenc_package_items[item.filename] = item\n            self._dependency_packages_items = dependenc_package_items\n        return self._dependency_packages_items\n\n    @property\n    def dependency_package_item(self) -&gt; Optional[DependencyItem]:\n        \"\"\"Dependency package item that should be used by bundle.\n\n        Returns:\n            Optional[DependencyItem]: None if bundle does not have\n                specified dependency package.\n\n        \"\"\"\n        if self._dependency_package_item is NOT_SET:\n            dependency_package_item = None\n            bundle = self.project_bundle_to_use\n            if bundle is not None:\n                package_name = bundle.dependency_packages.get(\n                    platform.system().lower()\n                )\n                dependency_package_item = self.dependency_packages_items.get(\n                    package_name)\n            self._dependency_package_item = dependency_package_item\n        return self._dependency_package_item\n\n    def get_addon_dist_items(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Addon distribution items.\n\n        These items describe source files required by addon to be available on\n        machine. Each item may have 0-n source information from where can be\n        obtained. If file is already available it's state will be 'UPDATED'.\n\n        Example output:\n            [\n                {\n                    \"dist_item\": DistributionItem,\n                    \"addon_name\": str,\n                    \"addon_version\": str,\n                    \"addon_item\": AddonInfo,\n                    \"addon_version_item\": AddonVersionInfo\n                }, {\n                    ...\n                }\n            ]\n\n        Returns:\n             list[dict[str, Any]]: Distribution items with addon version item.\n\n        \"\"\"\n        if self._addon_dist_items is NOT_SET:\n            self._addon_dist_items = (\n                self._prepare_current_addon_dist_items())\n        return self._addon_dist_items\n\n    def get_dependency_dist_item(self) -&gt; Optional[DistributionItem]:\n        \"\"\"Dependency package distribution item.\n\n        Item describe source files required by server to be available on\n        machine. Item may have 0-n source information from where can be\n        obtained. If file is already available it's state will be 'UPDATED'.\n\n        'None' is returned if server does not have defined any dependency\n        package.\n\n        Returns:\n            Optional[DistributionItem]: Dependency item or None if server\n                does not have specified any dependency package.\n\n        \"\"\"\n        if self._dependency_dist_item is NOT_SET:\n            self._dependency_dist_item = self._prepare_dependency_progress()\n        return self._dependency_dist_item\n\n    def get_dependency_metadata_filepath(self) -&gt; str:\n        \"\"\"Path to distribution metadata file.\n\n        Metadata contain information about distributed packages, used source,\n        expected file hash and time when file was distributed.\n\n        Returns:\n            str: Path to a file where dependency package metadata are stored.\n\n        \"\"\"\n        return os.path.join(self._dependency_dirpath, \"dependency.json\")\n\n    def get_addons_metadata_filepath(self) -&gt; str:\n        \"\"\"Path to addons metadata file.\n\n        Metadata contain information about distributed addons, used sources,\n        expected file hashes and time when files were distributed.\n\n        Returns:\n            str: Path to a file where addons metadata are stored.\n\n        \"\"\"\n        return os.path.join(self._addons_dirpath, \"addons.json\")\n\n    @staticmethod\n    def read_metadata_file(\n        filepath: str,\n        default_value: Optional[Any] = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Read json file from path.\n\n        Method creates the file when does not exist with default value.\n\n        Args:\n            filepath (str): Path to json file.\n            default_value (Union[Dict[str, Any], List[Any], None]): Default\n                value if the file is not available (or valid).\n\n        Returns:\n            Union[Dict[str, Any], List[Any]]: Value from file.\n        \"\"\"\n\n        if default_value is None:\n            default_value = {}\n\n        if not os.path.exists(filepath):\n            return default_value\n\n        try:\n            with open(filepath, \"r\") as stream:\n                data = json.load(stream)\n        except ValueError:\n            data = default_value\n        return data\n\n    @staticmethod\n    def save_metadata_file(filepath: str, data: dict[str, Any]):\n        \"\"\"Store data to json file.\n\n        Method creates the file when does not exist.\n\n        Args:\n            filepath (str): Path to json file.\n            data (dict[str, Any]): Data to store into file.\n\n        \"\"\"\n        dirpath = os.path.dirname(filepath)\n        os.makedirs(dirpath, exist_ok=True)\n        with open(filepath, \"w\") as stream:\n            json.dump(data, stream, indent=4)\n        change_permissions_recursive(dirpath)\n\n    def get_dependency_metadata(self) -&gt; dict[str, Any]:\n        filepath = self.get_dependency_metadata_filepath()\n        return self.read_metadata_file(filepath, {})\n\n    def update_dependency_metadata(\n        self, package_name: str, data: dict[str, Any]\n    ):\n        dependency_metadata = self.get_dependency_metadata()\n        dependency_metadata[package_name] = data\n        filepath = self.get_dependency_metadata_filepath()\n        self.save_metadata_file(filepath, dependency_metadata)\n\n    def get_addons_metadata(self) -&gt; dict[str, Any]:\n        filepath = self.get_addons_metadata_filepath()\n        return self.read_metadata_file(filepath, {})\n\n    def update_addons_metadata(self, addons_information: dict[str, Any]):\n        if not addons_information:\n            return\n        addons_metadata = self.get_addons_metadata()\n        for addon_name, version_value in addons_information.items():\n            if addon_name not in addons_metadata:\n                addons_metadata[addon_name] = {}\n            for addon_version, version_data in version_value.items():\n                addons_metadata[addon_name][addon_version] = version_data\n\n        filepath = self.get_addons_metadata_filepath()\n        self.save_metadata_file(filepath, addons_metadata)\n\n    def finish_distribution(self):\n        \"\"\"Store metadata about distributed items.\"\"\"\n        for tmp_dir in (\n            self._dist_download_dirs + self._dist_unzip_dirs\n        ):\n            if os.path.exists(tmp_dir):\n                try:\n                    shutil.rmtree(tmp_dir)\n                except Exception:\n                    pass\n\n        stored_time = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        # TODO store dependencies info inside dependencies folder instead\n        #   of having one file\n        # - the file can be used to track progress and find out if other\n        #   process is already working on distribution\n        dependency_dist_item = self.get_dependency_dist_item()\n        if (\n            dependency_dist_item is not None\n            and dependency_dist_item.need_distribution\n            and dependency_dist_item.state == UpdateState.UPDATED\n        ):\n            package = self.dependency_package_item\n            source = dependency_dist_item.used_source\n            if source is not None:\n                data = {\n                    \"source\": source,\n                    \"checksum\": dependency_dist_item.checksum,\n                    \"checksum_algorithm\": (\n                        dependency_dist_item.checksum_algorithm),\n                    \"distributed_dt\": stored_time\n                }\n                self.update_dependency_metadata(package.filename, data)\n\n        # TODO store addon info inside addon folder instead of having one\n        #   of having one file\n        # - the file can be used to track progress and find out if other\n        #   process is already working on distribution\n        addons_info = {}\n        for item in self.get_addon_dist_items():\n            dist_item = item[\"dist_item\"]\n            if (\n                not dist_item.need_distribution\n                or dist_item.state != UpdateState.UPDATED\n            ):\n                continue\n\n            source_data = dist_item.used_source\n            if not source_data:\n                continue\n\n            addon_name = item[\"addon_name\"]\n            addon_version = item[\"addon_version\"]\n            addons_info.setdefault(addon_name, {})\n            addons_info[addon_name][addon_version] = {\n                \"source\": source_data,\n                \"checksum\": dist_item.checksum,\n                \"checksum_algorithm\": dist_item.checksum_algorithm,\n                \"distributed_dt\": stored_time\n            }\n\n        self.update_addons_metadata(addons_info)\n\n        _cleanup_dist_download_dirs()\n        _cleanup_dist_expire_dirs(self._dist_addons_unzip_temp)\n        _cleanup_dist_expire_dirs(self._dist_dep_packages_unzip_temp)\n\n    def get_all_distribution_items(self) -&gt; list[DistributionItem]:\n        \"\"\"Distribution items required by server.\n\n        Items contain dependency package item and all addons that are enabled\n        and have distribution requirements.\n\n        Items can be already available on machine.\n\n        Returns:\n            list[DistributionItem]: Distribution items required by server.\n\n        \"\"\"\n        output = [\n            item[\"dist_item\"]\n            for item in self.get_addon_dist_items()\n        ]\n        dependency_dist_item = self.get_dependency_dist_item()\n        if dependency_dist_item is not None:\n            output.insert(0, dependency_dist_item)\n\n        return output\n\n    @property\n    def need_distribution(self) -&gt; bool:\n        \"\"\"Distribution is needed.\n\n        Returns:\n            bool: True if any distribution is needed.\n\n        \"\"\"\n        if self.need_installer_change:\n            if self.need_installer_distribution:\n                return True\n            return False\n\n        for item in self.get_all_distribution_items():\n            if item.need_distribution:\n                return True\n        return False\n\n    @property\n    def is_missing_permissions(self):\n        # Do not validate installer (launcher) distribution as that is\n        #   reported with '_installer_dist_error'\n        for item in self.get_all_distribution_items():\n            if item.need_distribution and item.is_missing_permissions:\n                return True\n        return False\n\n    def distribute(self):\n        \"\"\"Distribute all missing items.\n\n        Method will try to distribute all items that are required by server.\n\n        This method does not handle failed items. To validate the result call\n        'validate_distribution' when this method finishes.\n\n        \"\"\"\n        if self._dist_started:\n            raise RuntimeError(\"Distribution already started\")\n        self._dist_started = True\n\n        if self.need_installer_change:\n            if self.need_installer_distribution:\n                self.distribute_installer()\n            return\n\n        dist_items = []\n        for dist_item in self.get_all_distribution_items():\n            if not dist_item.is_distributed():\n                dist_items.append(dist_item)\n                _create_dist_expire_file(dist_item.download_dirpath)\n\n        running_items = collections.deque()\n        for item in dist_items:\n            running_items.append(item.distribute())\n\n        if running_items:\n            running_items.append(None)\n\n        try:\n            while running_items:\n                running_item = running_items.popleft()\n                if running_item is None:\n                    if running_items:\n                        running_items.append(None)\n                        time.sleep(0.02)\n                    continue\n\n                if not next(running_item):\n                    running_items.append(running_item)\n\n        finally:\n            self.finish_distribution()\n\n    def validate_distribution(self):\n        \"\"\"Check if all required distribution items are distributed.\n\n        Raises:\n            RuntimeError: Any of items is not available.\n\n        \"\"\"\n        invalid = []\n        dependency_package = self.get_dependency_dist_item()\n        if (\n            dependency_package is not None\n            and dependency_package.state != UpdateState.UPDATED\n        ):\n            invalid.append(\"Dependency package\")\n\n        for item in self.get_addon_dist_items():\n            dist_item = item[\"dist_item\"]\n            if dist_item.state != UpdateState.UPDATED:\n                invalid.append(item[\"addon_name\"])\n\n        if not invalid:\n            return\n\n        raise RuntimeError(\"Failed to distribute {}\".format(\n            \", \".join([f'\"{item}\"' for item in invalid])\n        ))\n\n    def get_sys_paths(self) -&gt; list[str]:\n        \"\"\"Get all paths to python packages that should be added to path.\n\n        These packages will be added only to 'sys.path' and not into\n        'PYTHONPATH', so they won't be available in subprocesses.\n\n        Todos:\n            This is not yet implemented. The goal is that dependency\n                package will contain also 'build' python\n                dependencies (OpenTimelineIO, Pillow, etc.).\n\n        Returns:\n            list[str]: Paths that should be added to 'sys.path'.\n\n        \"\"\"\n        output = []\n        dependency_dist_item = self.get_dependency_dist_item()\n        if dependency_dist_item is not None:\n            runtime_dir = None\n            target_dirpath = dependency_dist_item.target_dirpath\n            if target_dirpath:\n                runtime_dir = os.path.join(target_dirpath, \"runtime\")\n\n            if runtime_dir and os.path.exists(runtime_dir):\n                output.append(runtime_dir)\n        return output\n\n    def get_python_paths(self) -&gt; list[str]:\n        \"\"\"Get all paths to python packages that should be added to python.\n\n        These paths lead to addon directories and python dependencies in\n        dependency package.\n\n        Returns:\n            List[str]: Paths that should be added to 'sys.path' and\n                'PYTHONPATH'.\n\n        \"\"\"\n        output = []\n        for item in self.get_addon_dist_items():\n            dist_item = item[\"dist_item\"]\n            if dist_item.state != UpdateState.UPDATED:\n                continue\n            target_dirpath = dist_item.target_dirpath\n            if target_dirpath and os.path.exists(target_dirpath):\n                output.append(target_dirpath)\n\n        output.extend(self._get_dev_sys_paths())\n\n        dependency_dist_item = self.get_dependency_dist_item()\n        if dependency_dist_item is not None:\n            dependencies_dir = None\n            target_dirpath = dependency_dist_item.target_dirpath\n            if target_dirpath:\n                dependencies_dir = os.path.join(target_dirpath, \"dependencies\")\n\n            if dependencies_dir and os.path.exists(dependencies_dir):\n                output.append(dependencies_dir)\n        return output\n\n    def _get_dev_sys_paths(self) -&gt; list[str]:\n        output = []\n        if not self.use_dev:\n            return output\n\n        addon_versions = {}\n        dev_addons = {}\n        bundle = self.project_bundle_to_use\n        if bundle is not None:\n            dev_addons = bundle.addons_dev_info\n            addon_versions = bundle.addon_versions\n\n        for addon_name, _ in self.addon_items.items():\n            addon_version = addon_versions.get(addon_name)\n            # Addon is not in bundle -&gt; Skip\n            if addon_version is None:\n                continue\n\n            dev_addon_info = dev_addons.get(addon_name)\n            if dev_addon_info is not None and dev_addon_info.enabled:\n                try:\n                    output.append(\n                        os.path.expandvars(dev_addon_info.path.format_map(os.environ))\n                    )\n                except (KeyError, ValueError):\n                    msg = (\n                        f\"Failed to format path '{dev_addon_info.path}'\"\n                        f\" for addon '{addon_name}'.\"\n                    )\n                    self.log.warning(msg)\n                    raise RuntimeError(msg)\n\n        return output\n\n    def _prepare_bundles(self):\n        studio_production_bundle = None\n        studio_staging_bundle = None\n        studio_dev_bundle = None\n        for bundle in self.bundle_items:\n            if bundle.is_project_bundle:\n                continue\n\n            if bundle.is_production:\n                studio_production_bundle = bundle\n            if bundle.is_staging:\n                studio_staging_bundle = bundle\n            if bundle.is_dev and bundle.active_dev_user == self.active_user:\n                studio_dev_bundle = bundle\n\n        self._studio_production_bundle = studio_production_bundle\n        self._studio_staging_bundle = studio_staging_bundle\n        self._studio_dev_bundle = studio_dev_bundle\n\n    def _prepare_current_addon_dist_items(self) -&gt; list[dict[str, Any]]:\n        addons_metadata = self.get_addons_metadata()\n        output = []\n        addon_versions = {}\n        dev_addons = {}\n        bundle = self.project_bundle_to_use\n        if bundle is not None:\n            dev_addons = bundle.addons_dev_info\n            addon_versions = bundle.addon_versions\n\n        unzip_temp = os.path.join(self._addons_dirpath, \".unzip_temp\")\n        if not os.path.exists(unzip_temp):\n            os.makedirs(unzip_temp)\n            change_permissions_recursive(unzip_temp)\n\n        for addon_name, addon_item in self.addon_items.items():\n            # Dev mode can redirect addon directory elsewhere\n            if self.use_dev:\n                dev_addon_info = dev_addons.get(addon_name)\n                if dev_addon_info is not None and dev_addon_info.enabled:\n                    continue\n\n            addon_version = addon_versions.get(addon_name)\n            # Addon is not in bundle -&gt; Skip\n            if addon_version is None:\n                continue\n\n            addon_version_item = addon_item.versions.get(addon_version)\n            # Addon version is not available in addons info\n            # - TODO handle this case (raise error, skip, store, report, ...)\n            if addon_version_item is None:\n                print(\n                    f\"Version '{addon_version}' of addon '{addon_name}'\"\n                    \" is not available on server.\"\n                )\n                continue\n\n            if not addon_version_item.require_distribution:\n                continue\n            full_name = addon_version_item.full_name\n            addon_dest = os.path.join(self._addons_dirpath, full_name)\n            self.log.debug(f\"Checking {full_name} in {addon_dest}\")\n            progress_info = _read_progress_file(addon_dest)\n            state = UpdateState.OUTDATED\n            if progress_info:\n                if progress_info.get(\"state\") == DistFileStates.done.value:\n                    state = UpdateState.UPDATED\n            else:\n                addon_in_metadata = (\n                    addon_name in addons_metadata\n                    and addon_version_item.version in (\n                        addons_metadata[addon_name]\n                    )\n                )\n                if addon_in_metadata and os.path.isdir(addon_dest):\n                    self.log.debug(\n                        f\"Addon version folder {addon_dest} already exists.\"\n                    )\n                    state = UpdateState.UPDATED\n                    # Auto-create addons dist file extracted with old versions\n                    _create_progress_file(\n                        addon_dest,\n                        uuid.uuid4().hex,\n                        addon_version_item.checksum,\n                        addon_version_item.checksum_algorithm,\n                    )\n\n            download_dir = _get_dist_download_dir(uuid.uuid4().hex)\n            unzip_dir = os.path.join(unzip_temp, uuid.uuid4().hex)\n            self._dist_download_dirs.append(download_dir)\n            self._dist_unzip_dirs.append(unzip_dir)\n            downloader_data = {\n                \"type\": \"addon\",\n                \"name\": addon_name,\n                \"version\": addon_version\n            }\n            dist_item = DistributionItem(\n                addon_dest,\n                unzip_dir,\n                download_dirpath=download_dir,\n                state=state,\n                checksum=addon_version_item.checksum,\n                checksum_algorithm=addon_version_item.checksum_algorithm,\n                factory=self._dist_factory,\n                sources=list(addon_version_item.sources),\n                downloader_data=downloader_data,\n                item_label=full_name,\n                progress_dir=addon_dest,\n                logger=self.log\n            )\n            output.append({\n                \"dist_item\": dist_item,\n                \"addon_name\": addon_name,\n                \"addon_version\": addon_version,\n                \"addon_item\": addon_item,\n                \"addon_version_item\": addon_version_item,\n            })\n        return output\n\n    def _prepare_dependency_progress(self) -&gt; Optional[DistributionItem]:\n        package = self.dependency_package_item\n        if package is None:\n            return None\n\n        metadata = self.get_dependency_metadata()\n        downloader_data = {\n            \"type\": \"dependency_package\",\n            \"name\": package.filename,\n            \"platform\": package.platform_name\n        }\n        package_dir = os.path.join(\n            self._dependency_dirpath, package.filename\n        )\n        # Future compatibility for dependency packages without .zip in dirname\n        new_basename = os.path.splitext(package.filename)[0]\n        new_package_dir = os.path.join(self._dependency_dirpath, new_basename)\n\n        download_dir = _get_dist_download_dir(uuid.uuid4().hex)\n        unzip_dir = os.path.join(self._dependency_dirpath, uuid.uuid4().hex)\n        self._dist_download_dirs.append(download_dir)\n        self._dist_unzip_dirs.append(unzip_dir)\n\n        self.log.debug(f\"Checking {package.filename} in {package_dir}\")\n        state = UpdateState.OUTDATED\n        progress_info = _read_progress_file(package_dir)\n        new_progress_info = _read_progress_file(new_package_dir)\n        if progress_info:\n            if progress_info.get(\"state\") == DistFileStates.done.value:\n                state = UpdateState.UPDATED\n\n        elif new_progress_info:\n            if new_progress_info.get(\"state\") == DistFileStates.done.value:\n                state = UpdateState.UPDATED\n                package_dir = new_package_dir\n\n        elif (\n            os.path.isdir(package_dir)\n            and package.filename in metadata\n        ):\n            state = UpdateState.UPDATED\n            # Autofix dependency packages extracted with old versions\n            _create_progress_file(\n                package_dir,\n                uuid.uuid4().hex,\n                package.checksum,\n                package.checksum_algorithm,\n            )\n\n        return DistributionItem(\n            package_dir,\n            unzip_dir,\n            download_dirpath=download_dir,\n            state=state,\n            checksum=package.checksum,\n            checksum_algorithm=package.checksum_algorithm,\n            factory=self._dist_factory,\n            sources=package.sources,\n            downloader_data=downloader_data,\n            item_label=os.path.splitext(package.filename)[0],\n            progress_dir=package_dir,\n            logger=self.log,\n        )\n\n    def _get_project_bundle(self) -&gt; Optional[Bundle]:\n        if self._project_bundle is not NOT_SET:\n            return self._project_bundle\n\n        if self.studio_bundle_to_use is None:\n            self._project_bundle = None\n            return None\n\n        # Project bundle is set and is same as studio bundle\n        studio_bundle_name = self.studio_bundle_to_use.name\n        if self._project_bundle_name == studio_bundle_name:\n            self._project_bundle = None\n            return None\n\n        if (\n            not self._project_bundle_name\n            and self._project_name is not NOT_SET\n        ):\n            project = ayon_api.get_project(self._project_name)\n            project_bundles = project[\"data\"].get(\"bundle\", {})\n            bundle_name = None\n            if self.use_staging:\n                bundle_name = project_bundles.get(\"staging\")\n            elif not self.use_dev:\n                bundle_name = project_bundles.get(\"production\")\n\n            if bundle_name:\n                self._project_bundle_name = bundle_name\n\n        if not self._project_bundle_name:\n            self._project_bundle = None\n            return None\n\n        bundle = next(\n            (\n                bundle\n                for bundle in self.bundle_items\n                if bundle.name == self._project_bundle_name\n            ),\n            None\n        )\n        if bundle is None:\n            raise BundleNotFoundError(self._project_bundle_name)\n\n        if studio_bundle_name:\n            key_values = {\n                \"summary\": \"true\",\n                \"bundle\": studio_bundle_name,\n            }\n            query = urlencode(key_values)\n            response = ayon_api.get(f\"settings?{query}\")\n            # NOTE This does modify the bundle data\n            # - should be fine as it really does fill up the project bundle\n            for addon in response.data[\"addons\"]:\n                addon_name = addon[\"name\"]\n                addon_version = addon[\"version\"]\n                bundle.addon_versions[addon_name] = addon_version\n\n        self._project_bundle = bundle\n        return bundle\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.addon_items","title":"<code>addon_items</code>  <code>property</code>","text":"<p>Information about available addons on server.</p> <p>Addons may require distribution of files. For those addons will be created 'DistributionItem' handling distribution itself.</p> <p>Returns:</p> Type Description <code>dict[str, AddonInfo]</code> <p>dict[str, AddonInfo]: Addon info object by addon name.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.addons_info","title":"<code>addons_info</code>  <code>property</code>","text":"<p>Server information about available addons.</p> <p>Returns:</p> Type Description <code>dict[str, dict[str, Any]]</code> <p>dict[str, dict[str, Any]]: Addon info by addon name.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.bundle_items","title":"<code>bundle_items</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list[Bundle]</code> <p>list[Bundle]: List of bundles info.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.bundles_info","title":"<code>bundles_info</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: Bundles information from server.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.dependency_package_item","title":"<code>dependency_package_item</code>  <code>property</code>","text":"<p>Dependency package item that should be used by bundle.</p> <p>Returns:</p> Type Description <code>Optional[DependencyItem]</code> <p>Optional[DependencyItem]: None if bundle does not have specified dependency package.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.dependency_packages_info","title":"<code>dependency_packages_info</code>  <code>property</code>","text":"<p>Server information about available dependency packages.</p> Notes <p>For testing purposes it is possible to pass dependency packages     information to 'init'.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: Dependency packages information.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.dependency_packages_items","title":"<code>dependency_packages_items</code>  <code>property</code>","text":"<p>Dependency packages as objects.</p> <p>Returns:</p> Type Description <code>dict[str, DependencyItem]</code> <p>dict[str, DependencyItem]: Dependency packages as objects by name.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.expected_installer_version","title":"<code>expected_installer_version</code>  <code>property</code>","text":"<p>Excepted installer version.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Expected installer version or None defined by bundle that should be used.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.installer_dist_error","title":"<code>installer_dist_error</code>  <code>property</code>","text":"<p>Installer distribution error message.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Error that happened during installer distribution.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.installer_executable","title":"<code>installer_executable</code>  <code>property</code>","text":"<p>Path to installer executable that should be used.</p> Notes <p>The 'installer_executable' is maybe confusing naming. It might be     called 'ayon_executable'?</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Path to installer executable that should be used. None if executable is not found and must be distributed or bundle does not have defined an installer to use.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.installer_filepath","title":"<code>installer_filepath</code>  <code>property</code>","text":"<p>Path to a distribution package/installer.</p> <p>This can be used as reference for user where to find downloaded     installer on disk and distribute it manually.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Path to installer.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.installer_item","title":"<code>installer_item</code>  <code>property</code>","text":"<p>Installer item that should be used for distribution.</p> <p>Returns:</p> Type Description <p>Union[Installer, None]: Installer information item.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.installer_items","title":"<code>installer_items</code>  <code>property</code>","text":"<p>Installers as objects.</p> <p>Returns:</p> Type Description <code>list[Installer]</code> <p>list[Installer]: List of installers info from server.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.installers_info","title":"<code>installers_info</code>  <code>property</code>","text":"<p>Installers information from server.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: Installers information from server.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.log","title":"<code>log</code>  <code>property</code>","text":"<p>Helper to access logger.</p> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: Logger instance.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.need_distribution","title":"<code>need_distribution</code>  <code>property</code>","text":"<p>Distribution is needed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if any distribution is needed.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.need_installer_change","title":"<code>need_installer_change</code>  <code>property</code>","text":"<p>Installer should be changed.</p> <p>Current installer is using different version than what is expected     by bundle.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if installer should be changed.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.need_installer_distribution","title":"<code>need_installer_distribution</code>  <code>property</code>","text":"<p>Installer distribution is needed.</p> Todos <p>Add option to skip if running from code?</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if installer distribution is needed.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.project_bundle_name_to_use","title":"<code>project_bundle_name_to_use</code>  <code>property</code>","text":"<p>Name of bundle that will be used for distribution.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Name of bundle that will be used for distribution.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.project_bundle_to_use","title":"<code>project_bundle_to_use</code>  <code>property</code>","text":"<p>Bundle that will be used for distribution.</p> <p>Bundle that should be used can be affected by 'project_bundle_name',     'project_name', 'studio_bundle_name' or 'use_staging'.</p> <p>Returns:</p> Type Description <code>Optional[Bundle]</code> <p>Optional[Bundle]: Bundle that will be used for distribution or None.</p> <p>Raises:</p> Type Description <code>BundleNotFoundError</code> <p>When bundle name to use is defined but is not available on server.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.studio_bundle_to_use","title":"<code>studio_bundle_to_use</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[Bundle]</code> <p>Optional[Bundle]: Bundle that should be used in distribution.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.studio_dev_bundle","title":"<code>studio_dev_bundle</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[Bundle]</code> <p>Optional[Bundle]: Bundle that should be used in dev.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.studio_production_bundle","title":"<code>studio_production_bundle</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[Bundle]</code> <p>Optional[Bundle]: Bundle that should be used in production.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.studio_staging_bundle","title":"<code>studio_staging_bundle</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[Bundle]</code> <p>Optional[Bundle]: Bundle that should be used in staging.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.use_dev","title":"<code>use_dev</code>  <code>property</code>","text":"<p>Develop version of a bundle should be used.</p> <p>This value is completely ignored if specific bundle name should     be used.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if staging version should be used.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.use_staging","title":"<code>use_staging</code>  <code>property</code>","text":"<p>Staging version of a bundle should be used.</p> <p>This value is completely ignored if specific bundle name should     be used.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if staging version should be used.</p>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.distribute","title":"<code>distribute()</code>","text":"<p>Distribute all missing items.</p> <p>Method will try to distribute all items that are required by server.</p> <p>This method does not handle failed items. To validate the result call 'validate_distribution' when this method finishes.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def distribute(self):\n    \"\"\"Distribute all missing items.\n\n    Method will try to distribute all items that are required by server.\n\n    This method does not handle failed items. To validate the result call\n    'validate_distribution' when this method finishes.\n\n    \"\"\"\n    if self._dist_started:\n        raise RuntimeError(\"Distribution already started\")\n    self._dist_started = True\n\n    if self.need_installer_change:\n        if self.need_installer_distribution:\n            self.distribute_installer()\n        return\n\n    dist_items = []\n    for dist_item in self.get_all_distribution_items():\n        if not dist_item.is_distributed():\n            dist_items.append(dist_item)\n            _create_dist_expire_file(dist_item.download_dirpath)\n\n    running_items = collections.deque()\n    for item in dist_items:\n        running_items.append(item.distribute())\n\n    if running_items:\n        running_items.append(None)\n\n    try:\n        while running_items:\n            running_item = running_items.popleft()\n            if running_item is None:\n                if running_items:\n                    running_items.append(None)\n                    time.sleep(0.02)\n                continue\n\n            if not next(running_item):\n                running_items.append(running_item)\n\n    finally:\n        self.finish_distribution()\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.distribute_installer","title":"<code>distribute_installer()</code>","text":"<p>Distribute installer.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def distribute_installer(self):\n    \"\"\"Distribute installer.\"\"\"\n\n    installer_item = self.installer_item\n    if installer_item is None:\n        self._installer_executable = None\n        self._installer_dist_error = (\n            f\"Bundle '{self.project_bundle_name_to_use}'\"\n            \" does not have set installer version to use.\"\n        )\n        return\n\n    downloader_data = {\n        \"type\": \"installer\",\n        \"version\": installer_item.version,\n        \"filename\": installer_item.filename,\n    }\n\n    tmp_used = False\n    downloads_dir = get_downloads_dir()\n    if not downloads_dir or not os.path.exists(downloads_dir):\n        tmp_used = True\n        downloads_dir = tempfile.mkdtemp(prefix=\"ayon_installer\")\n        change_permissions_recursive(downloads_dir)\n\n    dist_item = None\n    try:\n        dist_item = InstallerDistributionItem(\n            tmp_used,\n            downloads_dir,\n            UpdateState.OUTDATED,\n            installer_item.checksum,\n            installer_item.checksum_algorithm,\n            self._dist_factory,\n            list(installer_item.sources),\n            downloader_data,\n            f\"Installer {installer_item.version}\",\n        )\n\n        if (\n            platform.system().lower() != \"windows\"\n            and dist_item.is_missing_permissions\n        ):\n            self._installer_dist_error = (\n                \"Your user does not have required permissions to update\"\n                \" AYON launcher.\"\n                \" Please contact your administrator, or use user\"\n                \" with permissions.\"\n            )\n            return\n\n        for result in dist_item.distribute():\n            if result:\n                break\n\n        self._installer_executable = dist_item.executable\n        if dist_item.installer_error is not None:\n            self._installer_dist_error = dist_item.installer_error\n\n        elif dist_item.state == UpdateState.MISS_SOURCE_FILES:\n            self._installer_dist_error = (\n                \"Couldn't find valid installer source for required\"\n                f\" AYON launcher version {installer_item.version}.\"\n            )\n\n        elif not self._installer_executable:\n            self._installer_dist_error = (\n                \"Couldn't find installed AYON launcher.\"\n                \" Please try to launch AYON manually.\"\n            )\n\n    except Exception:\n        self.log.warning(\n            \"Installer distribution failed do to unknown reasons.\",\n            exc_info=True\n        )\n        self._installer_dist_error = (\n            f\"Distribution of AYON launcher {installer_item.version}\"\n            \" failed with unexpected reason.\"\n        )\n\n    finally:\n        if dist_item is not None:\n            self._installer_filepath = dist_item.installer_path\n\n        if tmp_used and os.path.exists(downloads_dir):\n            shutil.rmtree(downloads_dir)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.finish_distribution","title":"<code>finish_distribution()</code>","text":"<p>Store metadata about distributed items.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def finish_distribution(self):\n    \"\"\"Store metadata about distributed items.\"\"\"\n    for tmp_dir in (\n        self._dist_download_dirs + self._dist_unzip_dirs\n    ):\n        if os.path.exists(tmp_dir):\n            try:\n                shutil.rmtree(tmp_dir)\n            except Exception:\n                pass\n\n    stored_time = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    # TODO store dependencies info inside dependencies folder instead\n    #   of having one file\n    # - the file can be used to track progress and find out if other\n    #   process is already working on distribution\n    dependency_dist_item = self.get_dependency_dist_item()\n    if (\n        dependency_dist_item is not None\n        and dependency_dist_item.need_distribution\n        and dependency_dist_item.state == UpdateState.UPDATED\n    ):\n        package = self.dependency_package_item\n        source = dependency_dist_item.used_source\n        if source is not None:\n            data = {\n                \"source\": source,\n                \"checksum\": dependency_dist_item.checksum,\n                \"checksum_algorithm\": (\n                    dependency_dist_item.checksum_algorithm),\n                \"distributed_dt\": stored_time\n            }\n            self.update_dependency_metadata(package.filename, data)\n\n    # TODO store addon info inside addon folder instead of having one\n    #   of having one file\n    # - the file can be used to track progress and find out if other\n    #   process is already working on distribution\n    addons_info = {}\n    for item in self.get_addon_dist_items():\n        dist_item = item[\"dist_item\"]\n        if (\n            not dist_item.need_distribution\n            or dist_item.state != UpdateState.UPDATED\n        ):\n            continue\n\n        source_data = dist_item.used_source\n        if not source_data:\n            continue\n\n        addon_name = item[\"addon_name\"]\n        addon_version = item[\"addon_version\"]\n        addons_info.setdefault(addon_name, {})\n        addons_info[addon_name][addon_version] = {\n            \"source\": source_data,\n            \"checksum\": dist_item.checksum,\n            \"checksum_algorithm\": dist_item.checksum_algorithm,\n            \"distributed_dt\": stored_time\n        }\n\n    self.update_addons_metadata(addons_info)\n\n    _cleanup_dist_download_dirs()\n    _cleanup_dist_expire_dirs(self._dist_addons_unzip_temp)\n    _cleanup_dist_expire_dirs(self._dist_dep_packages_unzip_temp)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.get_addon_dist_items","title":"<code>get_addon_dist_items()</code>","text":"<p>Addon distribution items.</p> <p>These items describe source files required by addon to be available on machine. Each item may have 0-n source information from where can be obtained. If file is already available it's state will be 'UPDATED'.</p> Example output <p>[     {         \"dist_item\": DistributionItem,         \"addon_name\": str,         \"addon_version\": str,         \"addon_item\": AddonInfo,         \"addon_version_item\": AddonVersionInfo     }, {         ...     } ]</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: Distribution items with addon version item.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_addon_dist_items(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Addon distribution items.\n\n    These items describe source files required by addon to be available on\n    machine. Each item may have 0-n source information from where can be\n    obtained. If file is already available it's state will be 'UPDATED'.\n\n    Example output:\n        [\n            {\n                \"dist_item\": DistributionItem,\n                \"addon_name\": str,\n                \"addon_version\": str,\n                \"addon_item\": AddonInfo,\n                \"addon_version_item\": AddonVersionInfo\n            }, {\n                ...\n            }\n        ]\n\n    Returns:\n         list[dict[str, Any]]: Distribution items with addon version item.\n\n    \"\"\"\n    if self._addon_dist_items is NOT_SET:\n        self._addon_dist_items = (\n            self._prepare_current_addon_dist_items())\n    return self._addon_dist_items\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.get_addons_metadata_filepath","title":"<code>get_addons_metadata_filepath()</code>","text":"<p>Path to addons metadata file.</p> <p>Metadata contain information about distributed addons, used sources, expected file hashes and time when files were distributed.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to a file where addons metadata are stored.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_addons_metadata_filepath(self) -&gt; str:\n    \"\"\"Path to addons metadata file.\n\n    Metadata contain information about distributed addons, used sources,\n    expected file hashes and time when files were distributed.\n\n    Returns:\n        str: Path to a file where addons metadata are stored.\n\n    \"\"\"\n    return os.path.join(self._addons_dirpath, \"addons.json\")\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.get_all_distribution_items","title":"<code>get_all_distribution_items()</code>","text":"<p>Distribution items required by server.</p> <p>Items contain dependency package item and all addons that are enabled and have distribution requirements.</p> <p>Items can be already available on machine.</p> <p>Returns:</p> Type Description <code>list[DistributionItem]</code> <p>list[DistributionItem]: Distribution items required by server.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_all_distribution_items(self) -&gt; list[DistributionItem]:\n    \"\"\"Distribution items required by server.\n\n    Items contain dependency package item and all addons that are enabled\n    and have distribution requirements.\n\n    Items can be already available on machine.\n\n    Returns:\n        list[DistributionItem]: Distribution items required by server.\n\n    \"\"\"\n    output = [\n        item[\"dist_item\"]\n        for item in self.get_addon_dist_items()\n    ]\n    dependency_dist_item = self.get_dependency_dist_item()\n    if dependency_dist_item is not None:\n        output.insert(0, dependency_dist_item)\n\n    return output\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.get_dependency_dist_item","title":"<code>get_dependency_dist_item()</code>","text":"<p>Dependency package distribution item.</p> <p>Item describe source files required by server to be available on machine. Item may have 0-n source information from where can be obtained. If file is already available it's state will be 'UPDATED'.</p> <p>'None' is returned if server does not have defined any dependency package.</p> <p>Returns:</p> Type Description <code>Optional[DistributionItem]</code> <p>Optional[DistributionItem]: Dependency item or None if server does not have specified any dependency package.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_dependency_dist_item(self) -&gt; Optional[DistributionItem]:\n    \"\"\"Dependency package distribution item.\n\n    Item describe source files required by server to be available on\n    machine. Item may have 0-n source information from where can be\n    obtained. If file is already available it's state will be 'UPDATED'.\n\n    'None' is returned if server does not have defined any dependency\n    package.\n\n    Returns:\n        Optional[DistributionItem]: Dependency item or None if server\n            does not have specified any dependency package.\n\n    \"\"\"\n    if self._dependency_dist_item is NOT_SET:\n        self._dependency_dist_item = self._prepare_dependency_progress()\n    return self._dependency_dist_item\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.get_dependency_metadata_filepath","title":"<code>get_dependency_metadata_filepath()</code>","text":"<p>Path to distribution metadata file.</p> <p>Metadata contain information about distributed packages, used source, expected file hash and time when file was distributed.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to a file where dependency package metadata are stored.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_dependency_metadata_filepath(self) -&gt; str:\n    \"\"\"Path to distribution metadata file.\n\n    Metadata contain information about distributed packages, used source,\n    expected file hash and time when file was distributed.\n\n    Returns:\n        str: Path to a file where dependency package metadata are stored.\n\n    \"\"\"\n    return os.path.join(self._dependency_dirpath, \"dependency.json\")\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.get_python_paths","title":"<code>get_python_paths()</code>","text":"<p>Get all paths to python packages that should be added to python.</p> <p>These paths lead to addon directories and python dependencies in dependency package.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: Paths that should be added to 'sys.path' and 'PYTHONPATH'.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_python_paths(self) -&gt; list[str]:\n    \"\"\"Get all paths to python packages that should be added to python.\n\n    These paths lead to addon directories and python dependencies in\n    dependency package.\n\n    Returns:\n        List[str]: Paths that should be added to 'sys.path' and\n            'PYTHONPATH'.\n\n    \"\"\"\n    output = []\n    for item in self.get_addon_dist_items():\n        dist_item = item[\"dist_item\"]\n        if dist_item.state != UpdateState.UPDATED:\n            continue\n        target_dirpath = dist_item.target_dirpath\n        if target_dirpath and os.path.exists(target_dirpath):\n            output.append(target_dirpath)\n\n    output.extend(self._get_dev_sys_paths())\n\n    dependency_dist_item = self.get_dependency_dist_item()\n    if dependency_dist_item is not None:\n        dependencies_dir = None\n        target_dirpath = dependency_dist_item.target_dirpath\n        if target_dirpath:\n            dependencies_dir = os.path.join(target_dirpath, \"dependencies\")\n\n        if dependencies_dir and os.path.exists(dependencies_dir):\n            output.append(dependencies_dir)\n    return output\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.get_sys_paths","title":"<code>get_sys_paths()</code>","text":"<p>Get all paths to python packages that should be added to path.</p> <p>These packages will be added only to 'sys.path' and not into 'PYTHONPATH', so they won't be available in subprocesses.</p> Todos <p>This is not yet implemented. The goal is that dependency     package will contain also 'build' python     dependencies (OpenTimelineIO, Pillow, etc.).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Paths that should be added to 'sys.path'.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_sys_paths(self) -&gt; list[str]:\n    \"\"\"Get all paths to python packages that should be added to path.\n\n    These packages will be added only to 'sys.path' and not into\n    'PYTHONPATH', so they won't be available in subprocesses.\n\n    Todos:\n        This is not yet implemented. The goal is that dependency\n            package will contain also 'build' python\n            dependencies (OpenTimelineIO, Pillow, etc.).\n\n    Returns:\n        list[str]: Paths that should be added to 'sys.path'.\n\n    \"\"\"\n    output = []\n    dependency_dist_item = self.get_dependency_dist_item()\n    if dependency_dist_item is not None:\n        runtime_dir = None\n        target_dirpath = dependency_dist_item.target_dirpath\n        if target_dirpath:\n            runtime_dir = os.path.join(target_dirpath, \"runtime\")\n\n        if runtime_dir and os.path.exists(runtime_dir):\n            output.append(runtime_dir)\n    return output\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.read_metadata_file","title":"<code>read_metadata_file(filepath, default_value=None)</code>  <code>staticmethod</code>","text":"<p>Read json file from path.</p> <p>Method creates the file when does not exist with default value.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to json file.</p> required <code>default_value</code> <code>Union[Dict[str, Any], List[Any], None]</code> <p>Default value if the file is not available (or valid).</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Union[Dict[str, Any], List[Any]]: Value from file.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>@staticmethod\ndef read_metadata_file(\n    filepath: str,\n    default_value: Optional[Any] = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Read json file from path.\n\n    Method creates the file when does not exist with default value.\n\n    Args:\n        filepath (str): Path to json file.\n        default_value (Union[Dict[str, Any], List[Any], None]): Default\n            value if the file is not available (or valid).\n\n    Returns:\n        Union[Dict[str, Any], List[Any]]: Value from file.\n    \"\"\"\n\n    if default_value is None:\n        default_value = {}\n\n    if not os.path.exists(filepath):\n        return default_value\n\n    try:\n        with open(filepath, \"r\") as stream:\n            data = json.load(stream)\n    except ValueError:\n        data = default_value\n    return data\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.save_metadata_file","title":"<code>save_metadata_file(filepath, data)</code>  <code>staticmethod</code>","text":"<p>Store data to json file.</p> <p>Method creates the file when does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to json file.</p> required <code>data</code> <code>dict[str, Any]</code> <p>Data to store into file.</p> required Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>@staticmethod\ndef save_metadata_file(filepath: str, data: dict[str, Any]):\n    \"\"\"Store data to json file.\n\n    Method creates the file when does not exist.\n\n    Args:\n        filepath (str): Path to json file.\n        data (dict[str, Any]): Data to store into file.\n\n    \"\"\"\n    dirpath = os.path.dirname(filepath)\n    os.makedirs(dirpath, exist_ok=True)\n    with open(filepath, \"w\") as stream:\n        json.dump(data, stream, indent=4)\n    change_permissions_recursive(dirpath)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.AYONDistribution.validate_distribution","title":"<code>validate_distribution()</code>","text":"<p>Check if all required distribution items are distributed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Any of items is not available.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def validate_distribution(self):\n    \"\"\"Check if all required distribution items are distributed.\n\n    Raises:\n        RuntimeError: Any of items is not available.\n\n    \"\"\"\n    invalid = []\n    dependency_package = self.get_dependency_dist_item()\n    if (\n        dependency_package is not None\n        and dependency_package.state != UpdateState.UPDATED\n    ):\n        invalid.append(\"Dependency package\")\n\n    for item in self.get_addon_dist_items():\n        dist_item = item[\"dist_item\"]\n        if dist_item.state != UpdateState.UPDATED:\n            invalid.append(item[\"addon_name\"])\n\n    if not invalid:\n        return\n\n    raise RuntimeError(\"Failed to distribute {}\".format(\n        \", \".join([f'\"{item}\"' for item in invalid])\n    ))\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.BundleNotFoundError","title":"<code>BundleNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Bundle name is defined but is not available on server.</p> <p>Parameters:</p> Name Type Description Default <code>bundle_name</code> <code>str</code> <p>Name of bundle that was not found.</p> required Source code in <code>common/ayon_common/distribution/exceptions.py</code> <pre><code>class BundleNotFoundError(Exception):\n    \"\"\"Bundle name is defined but is not available on server.\n\n    Args:\n        bundle_name (str): Name of bundle that was not found.\n    \"\"\"\n\n    def __init__(self, bundle_name):\n        self.bundle_name = bundle_name\n        super().__init__(\n            f\"Bundle '{bundle_name}' is not available on server\"\n        )\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.show_installer_issue_information","title":"<code>show_installer_issue_information(message, installer_path=None)</code>","text":"<p>Show a message that something went wrong during installer distribution.</p> <p>This will trigger a subprocess with UI message dialog.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message with description of an issue.</p> required <code>installer_path</code> <code>Optional[str]</code> <p>Path to installer file so user can try to install it manually.</p> <code>None</code> Source code in <code>common/ayon_common/distribution/utils.py</code> <pre><code>def show_installer_issue_information(message, installer_path=None):\n    \"\"\"Show a message that something went wrong during installer distribution.\n\n    This will trigger a subprocess with UI message dialog.\n\n    Args:\n        message (str): Error message with description of an issue.\n        installer_path (Optional[str]): Path to installer file so user can\n            try to install it manually.\n\n    \"\"\"\n    sub_message = None\n    if installer_path and os.path.exists(installer_path):\n        sub_message = (\n            \"NOTE: Install file can be found here:\"\n            f\"&lt;br/&gt;&lt;b&gt;{installer_path}&lt;/b&gt;\"\n        )\n    _show_message_dialog(\n        \"AYON-launcher distribution\",\n        message,\n        sub_message,\n    )\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/index.html#common.ayon_common.distribution.show_missing_bundle_information","title":"<code>show_missing_bundle_information(url, bundle_name, username, is_project_bundle)</code>","text":"<p>Show missing bundle information window.</p> <p>This function should be called when server does not have set bundle for production or staging, or when bundle that should be used is not available on server.</p> <p>Using subprocess to show the dialog. Is blocking and is waiting until dialog is closed.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server url where bundle is not set.</p> required <code>bundle_name</code> <code>Optional[str]</code> <p>Name of bundle that was not found. Or 'None' if is missing bundle.</p> required <code>username</code> <code>Optional[str]</code> <p>Username. Is used only when dev mode is enabled.</p> required <code>is_project_bundle</code> <code>bool</code> <p>Missing bundle is project bundle.</p> required Source code in <code>common/ayon_common/distribution/utils.py</code> <pre><code>def show_missing_bundle_information(\n    url: str,\n    bundle_name: Optional[str],\n    username: Optional[str],\n    is_project_bundle: bool,\n) -&gt; None:\n    \"\"\"Show missing bundle information window.\n\n    This function should be called when server does not have set bundle for\n    production or staging, or when bundle that should be used is not available\n    on server.\n\n    Using subprocess to show the dialog. Is blocking and is waiting until\n    dialog is closed.\n\n    Args:\n        url (str): Server url where bundle is not set.\n        bundle_name (Optional[str]): Name of bundle that was not found. Or\n            'None' if is missing bundle.\n        username (Optional[str]): Username. Is used only when dev mode is\n            enabled.\n        is_project_bundle (bool): Missing bundle is project bundle.\n\n    \"\"\"\n    ui_dir = os.path.join(os.path.dirname(__file__), \"ui\")\n    script_path = os.path.join(ui_dir, \"missing_bundle_window.py\")\n    args = get_ayon_launch_args(\n        script_path,\n        \"--skip-bootstrap\",\n        \"--url\", url,\n    )\n    if bundle_name:\n        args.extend([\"--missing-bundle\", bundle_name])\n\n    if username:\n        args.extend([\"--user\", username])\n\n    if is_project_bundle:\n        args.append(\"--is-project\")\n    subprocess.call(args)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html","title":"control","text":""},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution","title":"<code>AYONDistribution</code>","text":"<p>Distribution control.</p> <p>Receive information from server what addons and dependency packages should be available locally and prepare/validate their distribution.</p> <p>Arguments are available for testing of the class.</p> <p>Parameters:</p> Name Type Description Default <code>addon_dirpath</code> <code>Optional[str]</code> <p>Where addons will be stored.</p> <code>None</code> <code>dependency_dirpath</code> <code>Optional[str]</code> <p>Where dependencies will be stored.</p> <code>None</code> <code>dist_factory</code> <code>Optional[DownloadFactory]</code> <p>Factory which cares about downloading of items based on source type.</p> <code>None</code> <code>installers_info</code> <code>Optional[list[dict[str, Any]]]</code> <p>List of prepared installers' info.</p> <code>NOT_SET</code> <code>addons_info</code> <code>Optional[list[dict[str, Any]]]</code> <p>List of prepared addons' info.</p> <code>NOT_SET</code> <code>dependency_packages_info</code> <code>Optional[list[dict[str, Any]]]</code> <p>Info about packages from server.</p> <code>NOT_SET</code> <code>bundles_info</code> <code>Optional[dict[str, Any]]</code> <p>Info about bundles.</p> <code>NOT_SET</code> <code>studio_bundle_name</code> <code>Optional[str]</code> <p>Name of studio bundle to use.</p> <code>NOT_SET</code> <code>project_bundle_name</code> <code>Optional[str]</code> <p>Name of project bundle to use.</p> <code>NOT_SET</code> <code>project_name</code> <code>Optional[str]</code> <p>Name of project for which project bundle can be auto-detected.</p> <code>NOT_SET</code> <code>use_staging</code> <code>Optional[bool]</code> <p>Use staging versions of an addon. If not passed, 'is_staging_enabled' is used as default value.</p> <code>None</code> <code>use_dev</code> <code>Optional[bool]</code> <p>Use develop versions of an addon. If not passed, 'is_dev_mode_enabled' is used as default value.</p> <code>None</code> <code>skip_installer_dist</code> <code>bool</code> <p>Skip installer distribution. This is for testing purposes and for running from code.</p> <code>False</code> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>class AYONDistribution:\n    \"\"\"Distribution control.\n\n    Receive information from server what addons and dependency packages\n    should be available locally and prepare/validate their distribution.\n\n    Arguments are available for testing of the class.\n\n    Args:\n        addon_dirpath (Optional[str]): Where addons will be stored.\n        dependency_dirpath (Optional[str]): Where dependencies will be stored.\n        dist_factory (Optional[DownloadFactory]): Factory which cares about\n            downloading of items based on source type.\n        installers_info (Optional[list[dict[str, Any]]]): List of prepared\n            installers' info.\n        addons_info (Optional[list[dict[str, Any]]]): List of prepared\n            addons' info.\n        dependency_packages_info (Optional[list[dict[str, Any]]]): Info\n            about packages from server.\n        bundles_info (Optional[dict[str, Any]]): Info about\n            bundles.\n        studio_bundle_name (Optional[str]): Name of studio bundle to use.\n        project_bundle_name (Optional[str]): Name of project bundle to use.\n        project_name (Optional[str]): Name of project for which project bundle\n            can be auto-detected.\n        use_staging (Optional[bool]): Use staging versions of an addon.\n            If not passed, 'is_staging_enabled' is used as default value.\n        use_dev (Optional[bool]): Use develop versions of an addon.\n            If not passed, 'is_dev_mode_enabled' is used as default value.\n        skip_installer_dist (bool): Skip installer distribution. This\n            is for testing purposes and for running from code.\n\n    \"\"\"\n    def __init__(\n        self,\n        addon_dirpath: Optional[str] = None,\n        dependency_dirpath: Optional[str] = None,\n        dist_factory: Optional[DownloadFactory] = None,\n        installers_info: Optional[list[dict[str, Any]]] = NOT_SET,\n        addons_info: Optional[list[dict[str, Any]]] = NOT_SET,\n        dependency_packages_info: Optional[list[dict[str, Any]]] = NOT_SET,\n        bundles_info: Optional[list[dict[str, Any]]] = NOT_SET,\n        studio_bundle_name: Optional[str] = NOT_SET,\n        project_bundle_name: Optional[str] = NOT_SET,\n        project_name: Optional[str] = NOT_SET,\n        use_staging: Optional[bool] = None,\n        use_dev: Optional[bool] = None,\n        active_user: Optional[bool] = None,\n        skip_installer_dist: bool = False,\n    ):\n        self._log = None\n\n        self._dist_started = False\n\n        self._addons_dirpath = addon_dirpath or get_addons_dir()\n        self._dependency_dirpath = dependency_dirpath or get_dependencies_dir()\n        self._dist_factory = (\n            dist_factory or get_default_download_factory()\n        )\n\n        if studio_bundle_name is NOT_SET:\n            studio_bundle_name = (\n                os.environ.get(\"AYON_STUDIO_BUNDLE_NAME\") or NOT_SET\n            )\n\n        if project_bundle_name is NOT_SET:\n            project_bundle_name = (\n                os.environ.get(\"AYON_BUNDLE_NAME\") or NOT_SET\n            )\n\n        if project_name is NOT_SET:\n            project_name = os.environ.get(\"AYON_PROJECT_NAME\") or NOT_SET\n\n        # Where addon zip files and dependency packages are downloaded\n        self._dist_download_dirs = []\n        self._dist_unzip_dirs = []\n\n        self._dist_addons_unzip_temp = os.path.join(\n            self._addons_dirpath, \".unzip_temp\"\n        )\n        self._dist_dep_packages_unzip_temp = os.path.join(\n            self._dependency_dirpath, \".unzip_temp\"\n        )\n\n        self._installers_info = installers_info\n        self._installer_items = NOT_SET\n        self._expected_installer_version = NOT_SET\n        self._installer_item = NOT_SET\n        self._installer_executable = NOT_SET\n        self._skip_installer_dist = skip_installer_dist\n        self._installer_filepath = None\n        self._installer_dist_error = None\n\n        # Raw addons data from server\n        self._addons_info = addons_info\n        # Prepared data as Addon objects\n        self._addon_items = NOT_SET\n        # Distrubtion items of addons\n        #   - only those addons and versions that should be distributed\n        self._addon_dist_items = NOT_SET\n\n        # Raw dependency packages data from server\n        self._dependency_packages_info = dependency_packages_info\n        # Prepared dependency packages as objects\n        self._dependency_packages_items = NOT_SET\n        # Dependency package item that should be used\n        self._dependency_package_item = NOT_SET\n        # Distribution item of dependency package\n        self._dependency_dist_item = NOT_SET\n\n        # Raw bundles data from server\n        self._bundles_info = bundles_info\n        # Bundles as objects\n        self._bundle_items = NOT_SET\n\n        # Bundle that should be used in production\n        self._studio_production_bundle = NOT_SET\n        # Bundle that should be used in staging\n        self._studio_staging_bundle = NOT_SET\n        # Bundle that should be used in dev\n        self._studio_dev_bundle = NOT_SET\n        # Boolean that defines if staging bundle should be used\n        self._use_staging = use_staging\n        self._use_dev = use_dev\n        self._active_user = active_user\n\n        # Specific bundle name should be used\n        self._studio_bundle_name = studio_bundle_name\n        self._project_bundle_name = project_bundle_name\n        self._project_name = project_name\n\n        # Final bundles that will be used\n        self._studio_bundle = NOT_SET\n        self._project_bundle = NOT_SET\n\n    @property\n    def active_user(self) -&gt; str:\n        if self._active_user is None:\n            user = ayon_api.get_user()\n            self._active_user = user[\"name\"]\n        return self._active_user\n\n    @property\n    def use_staging(self) -&gt; bool:\n        \"\"\"Staging version of a bundle should be used.\n\n        This value is completely ignored if specific bundle name should\n            be used.\n\n        Returns:\n            bool: True if staging version should be used.\n\n        \"\"\"\n        if self._use_staging is None:\n            self._use_staging = is_staging_enabled()\n\n        if self._use_staging and self.use_dev:\n            self._use_staging = False\n        return self._use_staging\n\n    @property\n    def use_dev(self) -&gt; bool:\n        \"\"\"Develop version of a bundle should be used.\n\n        This value is completely ignored if specific bundle name should\n            be used.\n\n        Returns:\n            bool: True if staging version should be used.\n\n        \"\"\"\n        if self._use_dev is None:\n            if self._studio_bundle_name is NOT_SET:\n                self._use_dev = is_dev_mode_enabled()\n            else:\n                bundle = next(\n                    (\n                        bundle\n                        for bundle in self.bundle_items\n                        if bundle.name == self._studio_bundle_name\n                    ),\n                    None\n                )\n                if bundle is not None:\n                    self._use_dev = bundle.is_dev\n                else:\n                    self._use_dev = False\n        return self._use_dev\n\n    @property\n    def log(self) -&gt; logging.Logger:\n        \"\"\"Helper to access logger.\n\n        Returns:\n             logging.Logger: Logger instance.\n\n        \"\"\"\n        if self._log is None:\n            self._log = logging.getLogger(self.__class__.__name__)\n        return self._log\n\n    @property\n    def bundles_info(self) -&gt; list[dict[str, Any]]:\n        \"\"\"\n\n        Returns:\n            list[dict[str, Any]]: Bundles information from server.\n\n        \"\"\"\n        if self._bundles_info is NOT_SET:\n            self._bundles_info = ayon_api.get_bundles()[\"bundles\"]\n        return self._bundles_info\n\n    @property\n    def bundle_items(self) -&gt; list[Bundle]:\n        \"\"\"\n\n        Returns:\n            list[Bundle]: List of bundles info.\n\n        \"\"\"\n        if self._bundle_items is NOT_SET:\n            self._bundle_items = [\n                Bundle.from_dict(info)\n                for info in self.bundles_info\n            ]\n        return self._bundle_items\n\n    @property\n    def studio_production_bundle(self) -&gt; Optional[Bundle]:\n        \"\"\"\n\n        Returns:\n            Optional[Bundle]: Bundle that should be used in production.\n\n        \"\"\"\n        if self._studio_production_bundle is NOT_SET:\n            self._prepare_bundles()\n        return self._studio_production_bundle\n\n    @property\n    def studio_staging_bundle(self) -&gt; Optional[Bundle]:\n        \"\"\"\n\n        Returns:\n            Optional[Bundle]: Bundle that should be used in staging.\n\n        \"\"\"\n        if self._studio_staging_bundle is NOT_SET:\n            self._prepare_bundles()\n        return self._studio_staging_bundle\n\n    @property\n    def studio_dev_bundle(self) -&gt; Optional[Bundle]:\n        \"\"\"\n\n        Returns:\n            Optional[Bundle]: Bundle that should be used in dev.\n\n        \"\"\"\n        if self._studio_dev_bundle is NOT_SET:\n            self._prepare_bundles()\n        return self._studio_dev_bundle\n\n    @property\n    def studio_bundle_to_use(self) -&gt; Optional[Bundle]:\n        \"\"\"\n\n        Returns:\n            Optional[Bundle]: Bundle that should be used in distribution.\n\n        \"\"\"\n        if self._studio_bundle is not NOT_SET:\n            return self._studio_bundle\n\n        self._prepare_bundles()\n        if self._studio_bundle_name is NOT_SET:\n            if self.use_staging:\n                self._studio_bundle = self.studio_staging_bundle\n            elif self.use_dev:\n                self._studio_bundle = self.studio_dev_bundle\n            else:\n                self._studio_bundle = self.studio_production_bundle\n            return self._studio_bundle\n\n        bundle = next(\n            (\n                bundle\n                for bundle in self.bundle_items\n                if bundle.name == self._studio_bundle_name\n            ),\n            None\n        )\n        if bundle is None:\n            raise BundleNotFoundError(self._studio_bundle_name)\n        self._studio_bundle = bundle\n        return self._studio_bundle\n\n    @property\n    def project_bundle_to_use(self) -&gt; Optional[Bundle]:\n        \"\"\"Bundle that will be used for distribution.\n\n        Bundle that should be used can be affected by 'project_bundle_name',\n            'project_name', 'studio_bundle_name' or 'use_staging'.\n\n        Returns:\n            Optional[Bundle]: Bundle that will be used for distribution\n                or None.\n\n        Raises:\n            BundleNotFoundError: When bundle name to use is defined\n                but is not available on server.\n\n        \"\"\"\n        if not self._project_bundle:\n            project_bundle = self._get_project_bundle()\n            if not project_bundle:\n                project_bundle = self.studio_bundle_to_use\n            self._project_bundle = project_bundle\n        return self._project_bundle\n\n    @property\n    def project_bundle_name_to_use(self) -&gt; Optional[str]:\n        \"\"\"Name of bundle that will be used for distribution.\n\n        Returns:\n            Optional[str]: Name of bundle that will be used for\n                distribution.\n\n        \"\"\"\n        bundle = self.project_bundle_to_use\n        return None if bundle is None else bundle.name\n\n    @property\n    def installers_info(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Installers information from server.\n\n        Returns:\n            list[dict[str, Any]]: Installers information from server.\n\n        \"\"\"\n        if self._installers_info is NOT_SET:\n            self._installers_info = ayon_api.get_installers()[\"installers\"]\n        return self._installers_info\n\n    @property\n    def installer_items(self) -&gt; list[Installer]:\n        \"\"\"Installers as objects.\n\n        Returns:\n            list[Installer]: List of installers info from server.\n\n        \"\"\"\n        if self._installer_items is NOT_SET:\n            self._installer_items = [\n                Installer.from_dict(info)\n                for info in self.installers_info\n            ]\n        return self._installer_items\n\n    @property\n    def expected_installer_version(self) -&gt; Optional[str]:\n        \"\"\"Excepted installer version.\n\n        Returns:\n            Optional[str]: Expected installer version or None defined by\n                bundle that should be used.\n\n        \"\"\"\n        if self._expected_installer_version is not NOT_SET:\n            return self._expected_installer_version\n\n        bundle = self.project_bundle_to_use\n        version = None if bundle is None else bundle.installer_version\n        self._expected_installer_version = version\n        return version\n\n    @property\n    def need_installer_change(self) -&gt; bool:\n        \"\"\"Installer should be changed.\n\n        Current installer is using different version than what is expected\n            by bundle.\n\n        Returns:\n            bool: True if installer should be changed.\n\n        \"\"\"\n        if self._skip_installer_dist:\n            return False\n\n        version = os.getenv(\"AYON_VERSION\")\n        return version != self.expected_installer_version\n\n    @property\n    def need_installer_distribution(self) -&gt; bool:\n        \"\"\"Installer distribution is needed.\n\n        Todos:\n            Add option to skip if running from code?\n\n        Returns:\n            bool: True if installer distribution is needed.\n\n        \"\"\"\n        if not self.need_installer_change:\n            return False\n\n        return self.installer_executable is None\n\n    @property\n    def installer_dist_error(self) -&gt; Optional[str]:\n        \"\"\"Installer distribution error message.\n\n        Returns:\n              Optional[str]: Error that happened during installer\n                distribution.\n\n        \"\"\"\n        return self._installer_dist_error\n\n    @property\n    def installer_filepath(self) -&gt; Optional[str]:\n        \"\"\"Path to a distribution package/installer.\n\n        This can be used as reference for user where to find downloaded\n            installer on disk and distribute it manually.\n\n        Returns:\n            Optional[str]: Path to installer.\n\n        \"\"\"\n        return self._installer_filepath\n\n    @property\n    def installer_executable(self) -&gt; Optional[str]:\n        \"\"\"Path to installer executable that should be used.\n\n        Notes:\n            The 'installer_executable' is maybe confusing naming. It might be\n                called 'ayon_executable'?\n\n        Returns:\n            Optional[str]: Path to installer executable that should be\n                used. None if executable is not found and must be distributed\n                or bundle does not have defined an installer to use.\n\n        \"\"\"\n        if self._installer_executable is not NOT_SET:\n            return self._installer_executable\n\n        path = None\n        if not self.need_installer_change:\n            self._installer_executable = sys.executable\n            return self._installer_executable\n\n        # Compare existing executable with current executable\n        current_executable = sys.executable\n        # Use 'ayon.exe' for executable lookup on Windows\n        root, filename = os.path.split(current_executable)\n        if filename == \"ayon_console.exe\":\n            current_executable = os.path.join(root, \"ayon.exe\")\n\n        # TODO look to expected target install directory too\n        executables_info = get_executables_info_by_version(\n            self.expected_installer_version)\n        for executable_info in executables_info:\n            executable_path = executable_info.get(\"executable\")\n            if (\n                not os.path.exists(executable_path)\n                or executable_path == current_executable\n            ):\n                continue\n            path = executable_path\n            break\n\n        # Make sure current executable filename is used on Windows\n        if path and filename == \"ayon_console.exe\":\n            path = os.path.join(os.path.dirname(path), filename)\n\n        if path:\n            self._installer_executable = path\n            return path\n\n        # Guess based on \"expected\" path of the version\n        # - is used if the AYON is already installed at target location but is\n        #   missing in the metadata file\n        current_version = os.environ[\"AYON_VERSION\"]\n        platform_name = platform.system().lower()\n        if platform_name in {\"windows\", \"linux\"}:\n            executable_dir, exe_name = os.path.split(sys.executable)\n            install_root, dirname = os.path.split(executable_dir)\n            if current_version in dirname:\n                new_dirname = dirname.replace(\n                    current_version,\n                    self.expected_installer_version\n                )\n                executable = os.path.join(\n                    install_root, new_dirname, exe_name\n                )\n                if os.path.exists(executable):\n                    path = executable\n\n        elif platform_name == \"darwin\":\n            app_name = f\"AYON {self.expected_installer_version}.app\"\n            excutable = f\"/Applications/{app_name}/Contents/MacOS/ayon\"\n            if os.path.exists(excutable):\n                path = excutable\n\n        self._installer_executable = path\n        return path\n\n    @property\n    def installer_item(self):\n        \"\"\"Installer item that should be used for distribution.\n\n        Returns:\n            Union[Installer, None]: Installer information item.\n\n        \"\"\"\n        if self._installer_item is not NOT_SET:\n            return self._installer_item\n\n        final_item = None\n        expected_version = self.expected_installer_version\n        if expected_version:\n            final_item = next(\n                (\n                    item\n                    for item in self.installer_items\n                    if (\n                        item.version == expected_version\n                        and item.platform_name == platform.system().lower()\n                    )\n                ),\n                None\n            )\n\n        self._installer_item = final_item\n        return final_item\n\n    def distribute_installer(self):\n        \"\"\"Distribute installer.\"\"\"\n\n        installer_item = self.installer_item\n        if installer_item is None:\n            self._installer_executable = None\n            self._installer_dist_error = (\n                f\"Bundle '{self.project_bundle_name_to_use}'\"\n                \" does not have set installer version to use.\"\n            )\n            return\n\n        downloader_data = {\n            \"type\": \"installer\",\n            \"version\": installer_item.version,\n            \"filename\": installer_item.filename,\n        }\n\n        tmp_used = False\n        downloads_dir = get_downloads_dir()\n        if not downloads_dir or not os.path.exists(downloads_dir):\n            tmp_used = True\n            downloads_dir = tempfile.mkdtemp(prefix=\"ayon_installer\")\n            change_permissions_recursive(downloads_dir)\n\n        dist_item = None\n        try:\n            dist_item = InstallerDistributionItem(\n                tmp_used,\n                downloads_dir,\n                UpdateState.OUTDATED,\n                installer_item.checksum,\n                installer_item.checksum_algorithm,\n                self._dist_factory,\n                list(installer_item.sources),\n                downloader_data,\n                f\"Installer {installer_item.version}\",\n            )\n\n            if (\n                platform.system().lower() != \"windows\"\n                and dist_item.is_missing_permissions\n            ):\n                self._installer_dist_error = (\n                    \"Your user does not have required permissions to update\"\n                    \" AYON launcher.\"\n                    \" Please contact your administrator, or use user\"\n                    \" with permissions.\"\n                )\n                return\n\n            for result in dist_item.distribute():\n                if result:\n                    break\n\n            self._installer_executable = dist_item.executable\n            if dist_item.installer_error is not None:\n                self._installer_dist_error = dist_item.installer_error\n\n            elif dist_item.state == UpdateState.MISS_SOURCE_FILES:\n                self._installer_dist_error = (\n                    \"Couldn't find valid installer source for required\"\n                    f\" AYON launcher version {installer_item.version}.\"\n                )\n\n            elif not self._installer_executable:\n                self._installer_dist_error = (\n                    \"Couldn't find installed AYON launcher.\"\n                    \" Please try to launch AYON manually.\"\n                )\n\n        except Exception:\n            self.log.warning(\n                \"Installer distribution failed do to unknown reasons.\",\n                exc_info=True\n            )\n            self._installer_dist_error = (\n                f\"Distribution of AYON launcher {installer_item.version}\"\n                \" failed with unexpected reason.\"\n            )\n\n        finally:\n            if dist_item is not None:\n                self._installer_filepath = dist_item.installer_path\n\n            if tmp_used and os.path.exists(downloads_dir):\n                shutil.rmtree(downloads_dir)\n\n    @property\n    def addons_info(self) -&gt; dict[str, dict[str, Any]]:\n        \"\"\"Server information about available addons.\n\n        Returns:\n            dict[str, dict[str, Any]]: Addon info by addon name.\n\n        \"\"\"\n        if self._addons_info is NOT_SET:\n            # Use details to get information about client.zip\n            server_info = ayon_api.get_addons_info(details=True)\n            self._addons_info = server_info[\"addons\"]\n        return self._addons_info\n\n    @property\n    def addon_items(self) -&gt; dict[str, AddonInfo]:\n        \"\"\"Information about available addons on server.\n\n        Addons may require distribution of files. For those addons will be\n        created 'DistributionItem' handling distribution itself.\n\n        Returns:\n            dict[str, AddonInfo]: Addon info object by addon name.\n\n        \"\"\"\n        if self._addon_items is NOT_SET:\n            addons_info = {}\n            for addon in self.addons_info:\n                addon_info = AddonInfo.from_dict(addon)\n                addons_info[addon_info.name] = addon_info\n            self._addon_items = addons_info\n        return self._addon_items\n\n    @property\n    def dependency_packages_info(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Server information about available dependency packages.\n\n        Notes:\n            For testing purposes it is possible to pass dependency packages\n                information to '__init__'.\n\n        Returns:\n            list[dict[str, Any]]: Dependency packages information.\n\n        \"\"\"\n        if self._dependency_packages_info is NOT_SET:\n            self._dependency_packages_info = (\n                ayon_api.get_dependency_packages())[\"packages\"]\n        return self._dependency_packages_info\n\n    @property\n    def dependency_packages_items(self) -&gt; dict[str, DependencyItem]:\n        \"\"\"Dependency packages as objects.\n\n        Returns:\n            dict[str, DependencyItem]: Dependency packages as objects by name.\n\n        \"\"\"\n        if self._dependency_packages_items is NOT_SET:\n            dependenc_package_items = {}\n            for item in self.dependency_packages_info:\n                item = DependencyItem.from_dict(item)\n                dependenc_package_items[item.filename] = item\n            self._dependency_packages_items = dependenc_package_items\n        return self._dependency_packages_items\n\n    @property\n    def dependency_package_item(self) -&gt; Optional[DependencyItem]:\n        \"\"\"Dependency package item that should be used by bundle.\n\n        Returns:\n            Optional[DependencyItem]: None if bundle does not have\n                specified dependency package.\n\n        \"\"\"\n        if self._dependency_package_item is NOT_SET:\n            dependency_package_item = None\n            bundle = self.project_bundle_to_use\n            if bundle is not None:\n                package_name = bundle.dependency_packages.get(\n                    platform.system().lower()\n                )\n                dependency_package_item = self.dependency_packages_items.get(\n                    package_name)\n            self._dependency_package_item = dependency_package_item\n        return self._dependency_package_item\n\n    def get_addon_dist_items(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Addon distribution items.\n\n        These items describe source files required by addon to be available on\n        machine. Each item may have 0-n source information from where can be\n        obtained. If file is already available it's state will be 'UPDATED'.\n\n        Example output:\n            [\n                {\n                    \"dist_item\": DistributionItem,\n                    \"addon_name\": str,\n                    \"addon_version\": str,\n                    \"addon_item\": AddonInfo,\n                    \"addon_version_item\": AddonVersionInfo\n                }, {\n                    ...\n                }\n            ]\n\n        Returns:\n             list[dict[str, Any]]: Distribution items with addon version item.\n\n        \"\"\"\n        if self._addon_dist_items is NOT_SET:\n            self._addon_dist_items = (\n                self._prepare_current_addon_dist_items())\n        return self._addon_dist_items\n\n    def get_dependency_dist_item(self) -&gt; Optional[DistributionItem]:\n        \"\"\"Dependency package distribution item.\n\n        Item describe source files required by server to be available on\n        machine. Item may have 0-n source information from where can be\n        obtained. If file is already available it's state will be 'UPDATED'.\n\n        'None' is returned if server does not have defined any dependency\n        package.\n\n        Returns:\n            Optional[DistributionItem]: Dependency item or None if server\n                does not have specified any dependency package.\n\n        \"\"\"\n        if self._dependency_dist_item is NOT_SET:\n            self._dependency_dist_item = self._prepare_dependency_progress()\n        return self._dependency_dist_item\n\n    def get_dependency_metadata_filepath(self) -&gt; str:\n        \"\"\"Path to distribution metadata file.\n\n        Metadata contain information about distributed packages, used source,\n        expected file hash and time when file was distributed.\n\n        Returns:\n            str: Path to a file where dependency package metadata are stored.\n\n        \"\"\"\n        return os.path.join(self._dependency_dirpath, \"dependency.json\")\n\n    def get_addons_metadata_filepath(self) -&gt; str:\n        \"\"\"Path to addons metadata file.\n\n        Metadata contain information about distributed addons, used sources,\n        expected file hashes and time when files were distributed.\n\n        Returns:\n            str: Path to a file where addons metadata are stored.\n\n        \"\"\"\n        return os.path.join(self._addons_dirpath, \"addons.json\")\n\n    @staticmethod\n    def read_metadata_file(\n        filepath: str,\n        default_value: Optional[Any] = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"Read json file from path.\n\n        Method creates the file when does not exist with default value.\n\n        Args:\n            filepath (str): Path to json file.\n            default_value (Union[Dict[str, Any], List[Any], None]): Default\n                value if the file is not available (or valid).\n\n        Returns:\n            Union[Dict[str, Any], List[Any]]: Value from file.\n        \"\"\"\n\n        if default_value is None:\n            default_value = {}\n\n        if not os.path.exists(filepath):\n            return default_value\n\n        try:\n            with open(filepath, \"r\") as stream:\n                data = json.load(stream)\n        except ValueError:\n            data = default_value\n        return data\n\n    @staticmethod\n    def save_metadata_file(filepath: str, data: dict[str, Any]):\n        \"\"\"Store data to json file.\n\n        Method creates the file when does not exist.\n\n        Args:\n            filepath (str): Path to json file.\n            data (dict[str, Any]): Data to store into file.\n\n        \"\"\"\n        dirpath = os.path.dirname(filepath)\n        os.makedirs(dirpath, exist_ok=True)\n        with open(filepath, \"w\") as stream:\n            json.dump(data, stream, indent=4)\n        change_permissions_recursive(dirpath)\n\n    def get_dependency_metadata(self) -&gt; dict[str, Any]:\n        filepath = self.get_dependency_metadata_filepath()\n        return self.read_metadata_file(filepath, {})\n\n    def update_dependency_metadata(\n        self, package_name: str, data: dict[str, Any]\n    ):\n        dependency_metadata = self.get_dependency_metadata()\n        dependency_metadata[package_name] = data\n        filepath = self.get_dependency_metadata_filepath()\n        self.save_metadata_file(filepath, dependency_metadata)\n\n    def get_addons_metadata(self) -&gt; dict[str, Any]:\n        filepath = self.get_addons_metadata_filepath()\n        return self.read_metadata_file(filepath, {})\n\n    def update_addons_metadata(self, addons_information: dict[str, Any]):\n        if not addons_information:\n            return\n        addons_metadata = self.get_addons_metadata()\n        for addon_name, version_value in addons_information.items():\n            if addon_name not in addons_metadata:\n                addons_metadata[addon_name] = {}\n            for addon_version, version_data in version_value.items():\n                addons_metadata[addon_name][addon_version] = version_data\n\n        filepath = self.get_addons_metadata_filepath()\n        self.save_metadata_file(filepath, addons_metadata)\n\n    def finish_distribution(self):\n        \"\"\"Store metadata about distributed items.\"\"\"\n        for tmp_dir in (\n            self._dist_download_dirs + self._dist_unzip_dirs\n        ):\n            if os.path.exists(tmp_dir):\n                try:\n                    shutil.rmtree(tmp_dir)\n                except Exception:\n                    pass\n\n        stored_time = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        # TODO store dependencies info inside dependencies folder instead\n        #   of having one file\n        # - the file can be used to track progress and find out if other\n        #   process is already working on distribution\n        dependency_dist_item = self.get_dependency_dist_item()\n        if (\n            dependency_dist_item is not None\n            and dependency_dist_item.need_distribution\n            and dependency_dist_item.state == UpdateState.UPDATED\n        ):\n            package = self.dependency_package_item\n            source = dependency_dist_item.used_source\n            if source is not None:\n                data = {\n                    \"source\": source,\n                    \"checksum\": dependency_dist_item.checksum,\n                    \"checksum_algorithm\": (\n                        dependency_dist_item.checksum_algorithm),\n                    \"distributed_dt\": stored_time\n                }\n                self.update_dependency_metadata(package.filename, data)\n\n        # TODO store addon info inside addon folder instead of having one\n        #   of having one file\n        # - the file can be used to track progress and find out if other\n        #   process is already working on distribution\n        addons_info = {}\n        for item in self.get_addon_dist_items():\n            dist_item = item[\"dist_item\"]\n            if (\n                not dist_item.need_distribution\n                or dist_item.state != UpdateState.UPDATED\n            ):\n                continue\n\n            source_data = dist_item.used_source\n            if not source_data:\n                continue\n\n            addon_name = item[\"addon_name\"]\n            addon_version = item[\"addon_version\"]\n            addons_info.setdefault(addon_name, {})\n            addons_info[addon_name][addon_version] = {\n                \"source\": source_data,\n                \"checksum\": dist_item.checksum,\n                \"checksum_algorithm\": dist_item.checksum_algorithm,\n                \"distributed_dt\": stored_time\n            }\n\n        self.update_addons_metadata(addons_info)\n\n        _cleanup_dist_download_dirs()\n        _cleanup_dist_expire_dirs(self._dist_addons_unzip_temp)\n        _cleanup_dist_expire_dirs(self._dist_dep_packages_unzip_temp)\n\n    def get_all_distribution_items(self) -&gt; list[DistributionItem]:\n        \"\"\"Distribution items required by server.\n\n        Items contain dependency package item and all addons that are enabled\n        and have distribution requirements.\n\n        Items can be already available on machine.\n\n        Returns:\n            list[DistributionItem]: Distribution items required by server.\n\n        \"\"\"\n        output = [\n            item[\"dist_item\"]\n            for item in self.get_addon_dist_items()\n        ]\n        dependency_dist_item = self.get_dependency_dist_item()\n        if dependency_dist_item is not None:\n            output.insert(0, dependency_dist_item)\n\n        return output\n\n    @property\n    def need_distribution(self) -&gt; bool:\n        \"\"\"Distribution is needed.\n\n        Returns:\n            bool: True if any distribution is needed.\n\n        \"\"\"\n        if self.need_installer_change:\n            if self.need_installer_distribution:\n                return True\n            return False\n\n        for item in self.get_all_distribution_items():\n            if item.need_distribution:\n                return True\n        return False\n\n    @property\n    def is_missing_permissions(self):\n        # Do not validate installer (launcher) distribution as that is\n        #   reported with '_installer_dist_error'\n        for item in self.get_all_distribution_items():\n            if item.need_distribution and item.is_missing_permissions:\n                return True\n        return False\n\n    def distribute(self):\n        \"\"\"Distribute all missing items.\n\n        Method will try to distribute all items that are required by server.\n\n        This method does not handle failed items. To validate the result call\n        'validate_distribution' when this method finishes.\n\n        \"\"\"\n        if self._dist_started:\n            raise RuntimeError(\"Distribution already started\")\n        self._dist_started = True\n\n        if self.need_installer_change:\n            if self.need_installer_distribution:\n                self.distribute_installer()\n            return\n\n        dist_items = []\n        for dist_item in self.get_all_distribution_items():\n            if not dist_item.is_distributed():\n                dist_items.append(dist_item)\n                _create_dist_expire_file(dist_item.download_dirpath)\n\n        running_items = collections.deque()\n        for item in dist_items:\n            running_items.append(item.distribute())\n\n        if running_items:\n            running_items.append(None)\n\n        try:\n            while running_items:\n                running_item = running_items.popleft()\n                if running_item is None:\n                    if running_items:\n                        running_items.append(None)\n                        time.sleep(0.02)\n                    continue\n\n                if not next(running_item):\n                    running_items.append(running_item)\n\n        finally:\n            self.finish_distribution()\n\n    def validate_distribution(self):\n        \"\"\"Check if all required distribution items are distributed.\n\n        Raises:\n            RuntimeError: Any of items is not available.\n\n        \"\"\"\n        invalid = []\n        dependency_package = self.get_dependency_dist_item()\n        if (\n            dependency_package is not None\n            and dependency_package.state != UpdateState.UPDATED\n        ):\n            invalid.append(\"Dependency package\")\n\n        for item in self.get_addon_dist_items():\n            dist_item = item[\"dist_item\"]\n            if dist_item.state != UpdateState.UPDATED:\n                invalid.append(item[\"addon_name\"])\n\n        if not invalid:\n            return\n\n        raise RuntimeError(\"Failed to distribute {}\".format(\n            \", \".join([f'\"{item}\"' for item in invalid])\n        ))\n\n    def get_sys_paths(self) -&gt; list[str]:\n        \"\"\"Get all paths to python packages that should be added to path.\n\n        These packages will be added only to 'sys.path' and not into\n        'PYTHONPATH', so they won't be available in subprocesses.\n\n        Todos:\n            This is not yet implemented. The goal is that dependency\n                package will contain also 'build' python\n                dependencies (OpenTimelineIO, Pillow, etc.).\n\n        Returns:\n            list[str]: Paths that should be added to 'sys.path'.\n\n        \"\"\"\n        output = []\n        dependency_dist_item = self.get_dependency_dist_item()\n        if dependency_dist_item is not None:\n            runtime_dir = None\n            target_dirpath = dependency_dist_item.target_dirpath\n            if target_dirpath:\n                runtime_dir = os.path.join(target_dirpath, \"runtime\")\n\n            if runtime_dir and os.path.exists(runtime_dir):\n                output.append(runtime_dir)\n        return output\n\n    def get_python_paths(self) -&gt; list[str]:\n        \"\"\"Get all paths to python packages that should be added to python.\n\n        These paths lead to addon directories and python dependencies in\n        dependency package.\n\n        Returns:\n            List[str]: Paths that should be added to 'sys.path' and\n                'PYTHONPATH'.\n\n        \"\"\"\n        output = []\n        for item in self.get_addon_dist_items():\n            dist_item = item[\"dist_item\"]\n            if dist_item.state != UpdateState.UPDATED:\n                continue\n            target_dirpath = dist_item.target_dirpath\n            if target_dirpath and os.path.exists(target_dirpath):\n                output.append(target_dirpath)\n\n        output.extend(self._get_dev_sys_paths())\n\n        dependency_dist_item = self.get_dependency_dist_item()\n        if dependency_dist_item is not None:\n            dependencies_dir = None\n            target_dirpath = dependency_dist_item.target_dirpath\n            if target_dirpath:\n                dependencies_dir = os.path.join(target_dirpath, \"dependencies\")\n\n            if dependencies_dir and os.path.exists(dependencies_dir):\n                output.append(dependencies_dir)\n        return output\n\n    def _get_dev_sys_paths(self) -&gt; list[str]:\n        output = []\n        if not self.use_dev:\n            return output\n\n        addon_versions = {}\n        dev_addons = {}\n        bundle = self.project_bundle_to_use\n        if bundle is not None:\n            dev_addons = bundle.addons_dev_info\n            addon_versions = bundle.addon_versions\n\n        for addon_name, _ in self.addon_items.items():\n            addon_version = addon_versions.get(addon_name)\n            # Addon is not in bundle -&gt; Skip\n            if addon_version is None:\n                continue\n\n            dev_addon_info = dev_addons.get(addon_name)\n            if dev_addon_info is not None and dev_addon_info.enabled:\n                try:\n                    output.append(\n                        os.path.expandvars(dev_addon_info.path.format_map(os.environ))\n                    )\n                except (KeyError, ValueError):\n                    msg = (\n                        f\"Failed to format path '{dev_addon_info.path}'\"\n                        f\" for addon '{addon_name}'.\"\n                    )\n                    self.log.warning(msg)\n                    raise RuntimeError(msg)\n\n        return output\n\n    def _prepare_bundles(self):\n        studio_production_bundle = None\n        studio_staging_bundle = None\n        studio_dev_bundle = None\n        for bundle in self.bundle_items:\n            if bundle.is_project_bundle:\n                continue\n\n            if bundle.is_production:\n                studio_production_bundle = bundle\n            if bundle.is_staging:\n                studio_staging_bundle = bundle\n            if bundle.is_dev and bundle.active_dev_user == self.active_user:\n                studio_dev_bundle = bundle\n\n        self._studio_production_bundle = studio_production_bundle\n        self._studio_staging_bundle = studio_staging_bundle\n        self._studio_dev_bundle = studio_dev_bundle\n\n    def _prepare_current_addon_dist_items(self) -&gt; list[dict[str, Any]]:\n        addons_metadata = self.get_addons_metadata()\n        output = []\n        addon_versions = {}\n        dev_addons = {}\n        bundle = self.project_bundle_to_use\n        if bundle is not None:\n            dev_addons = bundle.addons_dev_info\n            addon_versions = bundle.addon_versions\n\n        unzip_temp = os.path.join(self._addons_dirpath, \".unzip_temp\")\n        if not os.path.exists(unzip_temp):\n            os.makedirs(unzip_temp)\n            change_permissions_recursive(unzip_temp)\n\n        for addon_name, addon_item in self.addon_items.items():\n            # Dev mode can redirect addon directory elsewhere\n            if self.use_dev:\n                dev_addon_info = dev_addons.get(addon_name)\n                if dev_addon_info is not None and dev_addon_info.enabled:\n                    continue\n\n            addon_version = addon_versions.get(addon_name)\n            # Addon is not in bundle -&gt; Skip\n            if addon_version is None:\n                continue\n\n            addon_version_item = addon_item.versions.get(addon_version)\n            # Addon version is not available in addons info\n            # - TODO handle this case (raise error, skip, store, report, ...)\n            if addon_version_item is None:\n                print(\n                    f\"Version '{addon_version}' of addon '{addon_name}'\"\n                    \" is not available on server.\"\n                )\n                continue\n\n            if not addon_version_item.require_distribution:\n                continue\n            full_name = addon_version_item.full_name\n            addon_dest = os.path.join(self._addons_dirpath, full_name)\n            self.log.debug(f\"Checking {full_name} in {addon_dest}\")\n            progress_info = _read_progress_file(addon_dest)\n            state = UpdateState.OUTDATED\n            if progress_info:\n                if progress_info.get(\"state\") == DistFileStates.done.value:\n                    state = UpdateState.UPDATED\n            else:\n                addon_in_metadata = (\n                    addon_name in addons_metadata\n                    and addon_version_item.version in (\n                        addons_metadata[addon_name]\n                    )\n                )\n                if addon_in_metadata and os.path.isdir(addon_dest):\n                    self.log.debug(\n                        f\"Addon version folder {addon_dest} already exists.\"\n                    )\n                    state = UpdateState.UPDATED\n                    # Auto-create addons dist file extracted with old versions\n                    _create_progress_file(\n                        addon_dest,\n                        uuid.uuid4().hex,\n                        addon_version_item.checksum,\n                        addon_version_item.checksum_algorithm,\n                    )\n\n            download_dir = _get_dist_download_dir(uuid.uuid4().hex)\n            unzip_dir = os.path.join(unzip_temp, uuid.uuid4().hex)\n            self._dist_download_dirs.append(download_dir)\n            self._dist_unzip_dirs.append(unzip_dir)\n            downloader_data = {\n                \"type\": \"addon\",\n                \"name\": addon_name,\n                \"version\": addon_version\n            }\n            dist_item = DistributionItem(\n                addon_dest,\n                unzip_dir,\n                download_dirpath=download_dir,\n                state=state,\n                checksum=addon_version_item.checksum,\n                checksum_algorithm=addon_version_item.checksum_algorithm,\n                factory=self._dist_factory,\n                sources=list(addon_version_item.sources),\n                downloader_data=downloader_data,\n                item_label=full_name,\n                progress_dir=addon_dest,\n                logger=self.log\n            )\n            output.append({\n                \"dist_item\": dist_item,\n                \"addon_name\": addon_name,\n                \"addon_version\": addon_version,\n                \"addon_item\": addon_item,\n                \"addon_version_item\": addon_version_item,\n            })\n        return output\n\n    def _prepare_dependency_progress(self) -&gt; Optional[DistributionItem]:\n        package = self.dependency_package_item\n        if package is None:\n            return None\n\n        metadata = self.get_dependency_metadata()\n        downloader_data = {\n            \"type\": \"dependency_package\",\n            \"name\": package.filename,\n            \"platform\": package.platform_name\n        }\n        package_dir = os.path.join(\n            self._dependency_dirpath, package.filename\n        )\n        # Future compatibility for dependency packages without .zip in dirname\n        new_basename = os.path.splitext(package.filename)[0]\n        new_package_dir = os.path.join(self._dependency_dirpath, new_basename)\n\n        download_dir = _get_dist_download_dir(uuid.uuid4().hex)\n        unzip_dir = os.path.join(self._dependency_dirpath, uuid.uuid4().hex)\n        self._dist_download_dirs.append(download_dir)\n        self._dist_unzip_dirs.append(unzip_dir)\n\n        self.log.debug(f\"Checking {package.filename} in {package_dir}\")\n        state = UpdateState.OUTDATED\n        progress_info = _read_progress_file(package_dir)\n        new_progress_info = _read_progress_file(new_package_dir)\n        if progress_info:\n            if progress_info.get(\"state\") == DistFileStates.done.value:\n                state = UpdateState.UPDATED\n\n        elif new_progress_info:\n            if new_progress_info.get(\"state\") == DistFileStates.done.value:\n                state = UpdateState.UPDATED\n                package_dir = new_package_dir\n\n        elif (\n            os.path.isdir(package_dir)\n            and package.filename in metadata\n        ):\n            state = UpdateState.UPDATED\n            # Autofix dependency packages extracted with old versions\n            _create_progress_file(\n                package_dir,\n                uuid.uuid4().hex,\n                package.checksum,\n                package.checksum_algorithm,\n            )\n\n        return DistributionItem(\n            package_dir,\n            unzip_dir,\n            download_dirpath=download_dir,\n            state=state,\n            checksum=package.checksum,\n            checksum_algorithm=package.checksum_algorithm,\n            factory=self._dist_factory,\n            sources=package.sources,\n            downloader_data=downloader_data,\n            item_label=os.path.splitext(package.filename)[0],\n            progress_dir=package_dir,\n            logger=self.log,\n        )\n\n    def _get_project_bundle(self) -&gt; Optional[Bundle]:\n        if self._project_bundle is not NOT_SET:\n            return self._project_bundle\n\n        if self.studio_bundle_to_use is None:\n            self._project_bundle = None\n            return None\n\n        # Project bundle is set and is same as studio bundle\n        studio_bundle_name = self.studio_bundle_to_use.name\n        if self._project_bundle_name == studio_bundle_name:\n            self._project_bundle = None\n            return None\n\n        if (\n            not self._project_bundle_name\n            and self._project_name is not NOT_SET\n        ):\n            project = ayon_api.get_project(self._project_name)\n            project_bundles = project[\"data\"].get(\"bundle\", {})\n            bundle_name = None\n            if self.use_staging:\n                bundle_name = project_bundles.get(\"staging\")\n            elif not self.use_dev:\n                bundle_name = project_bundles.get(\"production\")\n\n            if bundle_name:\n                self._project_bundle_name = bundle_name\n\n        if not self._project_bundle_name:\n            self._project_bundle = None\n            return None\n\n        bundle = next(\n            (\n                bundle\n                for bundle in self.bundle_items\n                if bundle.name == self._project_bundle_name\n            ),\n            None\n        )\n        if bundle is None:\n            raise BundleNotFoundError(self._project_bundle_name)\n\n        if studio_bundle_name:\n            key_values = {\n                \"summary\": \"true\",\n                \"bundle\": studio_bundle_name,\n            }\n            query = urlencode(key_values)\n            response = ayon_api.get(f\"settings?{query}\")\n            # NOTE This does modify the bundle data\n            # - should be fine as it really does fill up the project bundle\n            for addon in response.data[\"addons\"]:\n                addon_name = addon[\"name\"]\n                addon_version = addon[\"version\"]\n                bundle.addon_versions[addon_name] = addon_version\n\n        self._project_bundle = bundle\n        return bundle\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.addon_items","title":"<code>addon_items</code>  <code>property</code>","text":"<p>Information about available addons on server.</p> <p>Addons may require distribution of files. For those addons will be created 'DistributionItem' handling distribution itself.</p> <p>Returns:</p> Type Description <code>dict[str, AddonInfo]</code> <p>dict[str, AddonInfo]: Addon info object by addon name.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.addons_info","title":"<code>addons_info</code>  <code>property</code>","text":"<p>Server information about available addons.</p> <p>Returns:</p> Type Description <code>dict[str, dict[str, Any]]</code> <p>dict[str, dict[str, Any]]: Addon info by addon name.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.bundle_items","title":"<code>bundle_items</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list[Bundle]</code> <p>list[Bundle]: List of bundles info.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.bundles_info","title":"<code>bundles_info</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: Bundles information from server.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.dependency_package_item","title":"<code>dependency_package_item</code>  <code>property</code>","text":"<p>Dependency package item that should be used by bundle.</p> <p>Returns:</p> Type Description <code>Optional[DependencyItem]</code> <p>Optional[DependencyItem]: None if bundle does not have specified dependency package.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.dependency_packages_info","title":"<code>dependency_packages_info</code>  <code>property</code>","text":"<p>Server information about available dependency packages.</p> Notes <p>For testing purposes it is possible to pass dependency packages     information to 'init'.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: Dependency packages information.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.dependency_packages_items","title":"<code>dependency_packages_items</code>  <code>property</code>","text":"<p>Dependency packages as objects.</p> <p>Returns:</p> Type Description <code>dict[str, DependencyItem]</code> <p>dict[str, DependencyItem]: Dependency packages as objects by name.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.expected_installer_version","title":"<code>expected_installer_version</code>  <code>property</code>","text":"<p>Excepted installer version.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Expected installer version or None defined by bundle that should be used.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.installer_dist_error","title":"<code>installer_dist_error</code>  <code>property</code>","text":"<p>Installer distribution error message.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Error that happened during installer distribution.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.installer_executable","title":"<code>installer_executable</code>  <code>property</code>","text":"<p>Path to installer executable that should be used.</p> Notes <p>The 'installer_executable' is maybe confusing naming. It might be     called 'ayon_executable'?</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Path to installer executable that should be used. None if executable is not found and must be distributed or bundle does not have defined an installer to use.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.installer_filepath","title":"<code>installer_filepath</code>  <code>property</code>","text":"<p>Path to a distribution package/installer.</p> <p>This can be used as reference for user where to find downloaded     installer on disk and distribute it manually.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Path to installer.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.installer_item","title":"<code>installer_item</code>  <code>property</code>","text":"<p>Installer item that should be used for distribution.</p> <p>Returns:</p> Type Description <p>Union[Installer, None]: Installer information item.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.installer_items","title":"<code>installer_items</code>  <code>property</code>","text":"<p>Installers as objects.</p> <p>Returns:</p> Type Description <code>list[Installer]</code> <p>list[Installer]: List of installers info from server.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.installers_info","title":"<code>installers_info</code>  <code>property</code>","text":"<p>Installers information from server.</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: Installers information from server.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.log","title":"<code>log</code>  <code>property</code>","text":"<p>Helper to access logger.</p> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: Logger instance.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.need_distribution","title":"<code>need_distribution</code>  <code>property</code>","text":"<p>Distribution is needed.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if any distribution is needed.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.need_installer_change","title":"<code>need_installer_change</code>  <code>property</code>","text":"<p>Installer should be changed.</p> <p>Current installer is using different version than what is expected     by bundle.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if installer should be changed.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.need_installer_distribution","title":"<code>need_installer_distribution</code>  <code>property</code>","text":"<p>Installer distribution is needed.</p> Todos <p>Add option to skip if running from code?</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if installer distribution is needed.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.project_bundle_name_to_use","title":"<code>project_bundle_name_to_use</code>  <code>property</code>","text":"<p>Name of bundle that will be used for distribution.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Name of bundle that will be used for distribution.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.project_bundle_to_use","title":"<code>project_bundle_to_use</code>  <code>property</code>","text":"<p>Bundle that will be used for distribution.</p> <p>Bundle that should be used can be affected by 'project_bundle_name',     'project_name', 'studio_bundle_name' or 'use_staging'.</p> <p>Returns:</p> Type Description <code>Optional[Bundle]</code> <p>Optional[Bundle]: Bundle that will be used for distribution or None.</p> <p>Raises:</p> Type Description <code>BundleNotFoundError</code> <p>When bundle name to use is defined but is not available on server.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.studio_bundle_to_use","title":"<code>studio_bundle_to_use</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[Bundle]</code> <p>Optional[Bundle]: Bundle that should be used in distribution.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.studio_dev_bundle","title":"<code>studio_dev_bundle</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[Bundle]</code> <p>Optional[Bundle]: Bundle that should be used in dev.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.studio_production_bundle","title":"<code>studio_production_bundle</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[Bundle]</code> <p>Optional[Bundle]: Bundle that should be used in production.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.studio_staging_bundle","title":"<code>studio_staging_bundle</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>Optional[Bundle]</code> <p>Optional[Bundle]: Bundle that should be used in staging.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.use_dev","title":"<code>use_dev</code>  <code>property</code>","text":"<p>Develop version of a bundle should be used.</p> <p>This value is completely ignored if specific bundle name should     be used.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if staging version should be used.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.use_staging","title":"<code>use_staging</code>  <code>property</code>","text":"<p>Staging version of a bundle should be used.</p> <p>This value is completely ignored if specific bundle name should     be used.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if staging version should be used.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.distribute","title":"<code>distribute()</code>","text":"<p>Distribute all missing items.</p> <p>Method will try to distribute all items that are required by server.</p> <p>This method does not handle failed items. To validate the result call 'validate_distribution' when this method finishes.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def distribute(self):\n    \"\"\"Distribute all missing items.\n\n    Method will try to distribute all items that are required by server.\n\n    This method does not handle failed items. To validate the result call\n    'validate_distribution' when this method finishes.\n\n    \"\"\"\n    if self._dist_started:\n        raise RuntimeError(\"Distribution already started\")\n    self._dist_started = True\n\n    if self.need_installer_change:\n        if self.need_installer_distribution:\n            self.distribute_installer()\n        return\n\n    dist_items = []\n    for dist_item in self.get_all_distribution_items():\n        if not dist_item.is_distributed():\n            dist_items.append(dist_item)\n            _create_dist_expire_file(dist_item.download_dirpath)\n\n    running_items = collections.deque()\n    for item in dist_items:\n        running_items.append(item.distribute())\n\n    if running_items:\n        running_items.append(None)\n\n    try:\n        while running_items:\n            running_item = running_items.popleft()\n            if running_item is None:\n                if running_items:\n                    running_items.append(None)\n                    time.sleep(0.02)\n                continue\n\n            if not next(running_item):\n                running_items.append(running_item)\n\n    finally:\n        self.finish_distribution()\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.distribute_installer","title":"<code>distribute_installer()</code>","text":"<p>Distribute installer.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def distribute_installer(self):\n    \"\"\"Distribute installer.\"\"\"\n\n    installer_item = self.installer_item\n    if installer_item is None:\n        self._installer_executable = None\n        self._installer_dist_error = (\n            f\"Bundle '{self.project_bundle_name_to_use}'\"\n            \" does not have set installer version to use.\"\n        )\n        return\n\n    downloader_data = {\n        \"type\": \"installer\",\n        \"version\": installer_item.version,\n        \"filename\": installer_item.filename,\n    }\n\n    tmp_used = False\n    downloads_dir = get_downloads_dir()\n    if not downloads_dir or not os.path.exists(downloads_dir):\n        tmp_used = True\n        downloads_dir = tempfile.mkdtemp(prefix=\"ayon_installer\")\n        change_permissions_recursive(downloads_dir)\n\n    dist_item = None\n    try:\n        dist_item = InstallerDistributionItem(\n            tmp_used,\n            downloads_dir,\n            UpdateState.OUTDATED,\n            installer_item.checksum,\n            installer_item.checksum_algorithm,\n            self._dist_factory,\n            list(installer_item.sources),\n            downloader_data,\n            f\"Installer {installer_item.version}\",\n        )\n\n        if (\n            platform.system().lower() != \"windows\"\n            and dist_item.is_missing_permissions\n        ):\n            self._installer_dist_error = (\n                \"Your user does not have required permissions to update\"\n                \" AYON launcher.\"\n                \" Please contact your administrator, or use user\"\n                \" with permissions.\"\n            )\n            return\n\n        for result in dist_item.distribute():\n            if result:\n                break\n\n        self._installer_executable = dist_item.executable\n        if dist_item.installer_error is not None:\n            self._installer_dist_error = dist_item.installer_error\n\n        elif dist_item.state == UpdateState.MISS_SOURCE_FILES:\n            self._installer_dist_error = (\n                \"Couldn't find valid installer source for required\"\n                f\" AYON launcher version {installer_item.version}.\"\n            )\n\n        elif not self._installer_executable:\n            self._installer_dist_error = (\n                \"Couldn't find installed AYON launcher.\"\n                \" Please try to launch AYON manually.\"\n            )\n\n    except Exception:\n        self.log.warning(\n            \"Installer distribution failed do to unknown reasons.\",\n            exc_info=True\n        )\n        self._installer_dist_error = (\n            f\"Distribution of AYON launcher {installer_item.version}\"\n            \" failed with unexpected reason.\"\n        )\n\n    finally:\n        if dist_item is not None:\n            self._installer_filepath = dist_item.installer_path\n\n        if tmp_used and os.path.exists(downloads_dir):\n            shutil.rmtree(downloads_dir)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.finish_distribution","title":"<code>finish_distribution()</code>","text":"<p>Store metadata about distributed items.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def finish_distribution(self):\n    \"\"\"Store metadata about distributed items.\"\"\"\n    for tmp_dir in (\n        self._dist_download_dirs + self._dist_unzip_dirs\n    ):\n        if os.path.exists(tmp_dir):\n            try:\n                shutil.rmtree(tmp_dir)\n            except Exception:\n                pass\n\n    stored_time = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    # TODO store dependencies info inside dependencies folder instead\n    #   of having one file\n    # - the file can be used to track progress and find out if other\n    #   process is already working on distribution\n    dependency_dist_item = self.get_dependency_dist_item()\n    if (\n        dependency_dist_item is not None\n        and dependency_dist_item.need_distribution\n        and dependency_dist_item.state == UpdateState.UPDATED\n    ):\n        package = self.dependency_package_item\n        source = dependency_dist_item.used_source\n        if source is not None:\n            data = {\n                \"source\": source,\n                \"checksum\": dependency_dist_item.checksum,\n                \"checksum_algorithm\": (\n                    dependency_dist_item.checksum_algorithm),\n                \"distributed_dt\": stored_time\n            }\n            self.update_dependency_metadata(package.filename, data)\n\n    # TODO store addon info inside addon folder instead of having one\n    #   of having one file\n    # - the file can be used to track progress and find out if other\n    #   process is already working on distribution\n    addons_info = {}\n    for item in self.get_addon_dist_items():\n        dist_item = item[\"dist_item\"]\n        if (\n            not dist_item.need_distribution\n            or dist_item.state != UpdateState.UPDATED\n        ):\n            continue\n\n        source_data = dist_item.used_source\n        if not source_data:\n            continue\n\n        addon_name = item[\"addon_name\"]\n        addon_version = item[\"addon_version\"]\n        addons_info.setdefault(addon_name, {})\n        addons_info[addon_name][addon_version] = {\n            \"source\": source_data,\n            \"checksum\": dist_item.checksum,\n            \"checksum_algorithm\": dist_item.checksum_algorithm,\n            \"distributed_dt\": stored_time\n        }\n\n    self.update_addons_metadata(addons_info)\n\n    _cleanup_dist_download_dirs()\n    _cleanup_dist_expire_dirs(self._dist_addons_unzip_temp)\n    _cleanup_dist_expire_dirs(self._dist_dep_packages_unzip_temp)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.get_addon_dist_items","title":"<code>get_addon_dist_items()</code>","text":"<p>Addon distribution items.</p> <p>These items describe source files required by addon to be available on machine. Each item may have 0-n source information from where can be obtained. If file is already available it's state will be 'UPDATED'.</p> Example output <p>[     {         \"dist_item\": DistributionItem,         \"addon_name\": str,         \"addon_version\": str,         \"addon_item\": AddonInfo,         \"addon_version_item\": AddonVersionInfo     }, {         ...     } ]</p> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: Distribution items with addon version item.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_addon_dist_items(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Addon distribution items.\n\n    These items describe source files required by addon to be available on\n    machine. Each item may have 0-n source information from where can be\n    obtained. If file is already available it's state will be 'UPDATED'.\n\n    Example output:\n        [\n            {\n                \"dist_item\": DistributionItem,\n                \"addon_name\": str,\n                \"addon_version\": str,\n                \"addon_item\": AddonInfo,\n                \"addon_version_item\": AddonVersionInfo\n            }, {\n                ...\n            }\n        ]\n\n    Returns:\n         list[dict[str, Any]]: Distribution items with addon version item.\n\n    \"\"\"\n    if self._addon_dist_items is NOT_SET:\n        self._addon_dist_items = (\n            self._prepare_current_addon_dist_items())\n    return self._addon_dist_items\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.get_addons_metadata_filepath","title":"<code>get_addons_metadata_filepath()</code>","text":"<p>Path to addons metadata file.</p> <p>Metadata contain information about distributed addons, used sources, expected file hashes and time when files were distributed.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to a file where addons metadata are stored.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_addons_metadata_filepath(self) -&gt; str:\n    \"\"\"Path to addons metadata file.\n\n    Metadata contain information about distributed addons, used sources,\n    expected file hashes and time when files were distributed.\n\n    Returns:\n        str: Path to a file where addons metadata are stored.\n\n    \"\"\"\n    return os.path.join(self._addons_dirpath, \"addons.json\")\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.get_all_distribution_items","title":"<code>get_all_distribution_items()</code>","text":"<p>Distribution items required by server.</p> <p>Items contain dependency package item and all addons that are enabled and have distribution requirements.</p> <p>Items can be already available on machine.</p> <p>Returns:</p> Type Description <code>list[DistributionItem]</code> <p>list[DistributionItem]: Distribution items required by server.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_all_distribution_items(self) -&gt; list[DistributionItem]:\n    \"\"\"Distribution items required by server.\n\n    Items contain dependency package item and all addons that are enabled\n    and have distribution requirements.\n\n    Items can be already available on machine.\n\n    Returns:\n        list[DistributionItem]: Distribution items required by server.\n\n    \"\"\"\n    output = [\n        item[\"dist_item\"]\n        for item in self.get_addon_dist_items()\n    ]\n    dependency_dist_item = self.get_dependency_dist_item()\n    if dependency_dist_item is not None:\n        output.insert(0, dependency_dist_item)\n\n    return output\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.get_dependency_dist_item","title":"<code>get_dependency_dist_item()</code>","text":"<p>Dependency package distribution item.</p> <p>Item describe source files required by server to be available on machine. Item may have 0-n source information from where can be obtained. If file is already available it's state will be 'UPDATED'.</p> <p>'None' is returned if server does not have defined any dependency package.</p> <p>Returns:</p> Type Description <code>Optional[DistributionItem]</code> <p>Optional[DistributionItem]: Dependency item or None if server does not have specified any dependency package.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_dependency_dist_item(self) -&gt; Optional[DistributionItem]:\n    \"\"\"Dependency package distribution item.\n\n    Item describe source files required by server to be available on\n    machine. Item may have 0-n source information from where can be\n    obtained. If file is already available it's state will be 'UPDATED'.\n\n    'None' is returned if server does not have defined any dependency\n    package.\n\n    Returns:\n        Optional[DistributionItem]: Dependency item or None if server\n            does not have specified any dependency package.\n\n    \"\"\"\n    if self._dependency_dist_item is NOT_SET:\n        self._dependency_dist_item = self._prepare_dependency_progress()\n    return self._dependency_dist_item\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.get_dependency_metadata_filepath","title":"<code>get_dependency_metadata_filepath()</code>","text":"<p>Path to distribution metadata file.</p> <p>Metadata contain information about distributed packages, used source, expected file hash and time when file was distributed.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to a file where dependency package metadata are stored.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_dependency_metadata_filepath(self) -&gt; str:\n    \"\"\"Path to distribution metadata file.\n\n    Metadata contain information about distributed packages, used source,\n    expected file hash and time when file was distributed.\n\n    Returns:\n        str: Path to a file where dependency package metadata are stored.\n\n    \"\"\"\n    return os.path.join(self._dependency_dirpath, \"dependency.json\")\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.get_python_paths","title":"<code>get_python_paths()</code>","text":"<p>Get all paths to python packages that should be added to python.</p> <p>These paths lead to addon directories and python dependencies in dependency package.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List[str]: Paths that should be added to 'sys.path' and 'PYTHONPATH'.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_python_paths(self) -&gt; list[str]:\n    \"\"\"Get all paths to python packages that should be added to python.\n\n    These paths lead to addon directories and python dependencies in\n    dependency package.\n\n    Returns:\n        List[str]: Paths that should be added to 'sys.path' and\n            'PYTHONPATH'.\n\n    \"\"\"\n    output = []\n    for item in self.get_addon_dist_items():\n        dist_item = item[\"dist_item\"]\n        if dist_item.state != UpdateState.UPDATED:\n            continue\n        target_dirpath = dist_item.target_dirpath\n        if target_dirpath and os.path.exists(target_dirpath):\n            output.append(target_dirpath)\n\n    output.extend(self._get_dev_sys_paths())\n\n    dependency_dist_item = self.get_dependency_dist_item()\n    if dependency_dist_item is not None:\n        dependencies_dir = None\n        target_dirpath = dependency_dist_item.target_dirpath\n        if target_dirpath:\n            dependencies_dir = os.path.join(target_dirpath, \"dependencies\")\n\n        if dependencies_dir and os.path.exists(dependencies_dir):\n            output.append(dependencies_dir)\n    return output\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.get_sys_paths","title":"<code>get_sys_paths()</code>","text":"<p>Get all paths to python packages that should be added to path.</p> <p>These packages will be added only to 'sys.path' and not into 'PYTHONPATH', so they won't be available in subprocesses.</p> Todos <p>This is not yet implemented. The goal is that dependency     package will contain also 'build' python     dependencies (OpenTimelineIO, Pillow, etc.).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: Paths that should be added to 'sys.path'.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def get_sys_paths(self) -&gt; list[str]:\n    \"\"\"Get all paths to python packages that should be added to path.\n\n    These packages will be added only to 'sys.path' and not into\n    'PYTHONPATH', so they won't be available in subprocesses.\n\n    Todos:\n        This is not yet implemented. The goal is that dependency\n            package will contain also 'build' python\n            dependencies (OpenTimelineIO, Pillow, etc.).\n\n    Returns:\n        list[str]: Paths that should be added to 'sys.path'.\n\n    \"\"\"\n    output = []\n    dependency_dist_item = self.get_dependency_dist_item()\n    if dependency_dist_item is not None:\n        runtime_dir = None\n        target_dirpath = dependency_dist_item.target_dirpath\n        if target_dirpath:\n            runtime_dir = os.path.join(target_dirpath, \"runtime\")\n\n        if runtime_dir and os.path.exists(runtime_dir):\n            output.append(runtime_dir)\n    return output\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.read_metadata_file","title":"<code>read_metadata_file(filepath, default_value=None)</code>  <code>staticmethod</code>","text":"<p>Read json file from path.</p> <p>Method creates the file when does not exist with default value.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to json file.</p> required <code>default_value</code> <code>Union[Dict[str, Any], List[Any], None]</code> <p>Default value if the file is not available (or valid).</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Union[Dict[str, Any], List[Any]]: Value from file.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>@staticmethod\ndef read_metadata_file(\n    filepath: str,\n    default_value: Optional[Any] = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Read json file from path.\n\n    Method creates the file when does not exist with default value.\n\n    Args:\n        filepath (str): Path to json file.\n        default_value (Union[Dict[str, Any], List[Any], None]): Default\n            value if the file is not available (or valid).\n\n    Returns:\n        Union[Dict[str, Any], List[Any]]: Value from file.\n    \"\"\"\n\n    if default_value is None:\n        default_value = {}\n\n    if not os.path.exists(filepath):\n        return default_value\n\n    try:\n        with open(filepath, \"r\") as stream:\n            data = json.load(stream)\n    except ValueError:\n        data = default_value\n    return data\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.save_metadata_file","title":"<code>save_metadata_file(filepath, data)</code>  <code>staticmethod</code>","text":"<p>Store data to json file.</p> <p>Method creates the file when does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to json file.</p> required <code>data</code> <code>dict[str, Any]</code> <p>Data to store into file.</p> required Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>@staticmethod\ndef save_metadata_file(filepath: str, data: dict[str, Any]):\n    \"\"\"Store data to json file.\n\n    Method creates the file when does not exist.\n\n    Args:\n        filepath (str): Path to json file.\n        data (dict[str, Any]): Data to store into file.\n\n    \"\"\"\n    dirpath = os.path.dirname(filepath)\n    os.makedirs(dirpath, exist_ok=True)\n    with open(filepath, \"w\") as stream:\n        json.dump(data, stream, indent=4)\n    change_permissions_recursive(dirpath)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.AYONDistribution.validate_distribution","title":"<code>validate_distribution()</code>","text":"<p>Check if all required distribution items are distributed.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Any of items is not available.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def validate_distribution(self):\n    \"\"\"Check if all required distribution items are distributed.\n\n    Raises:\n        RuntimeError: Any of items is not available.\n\n    \"\"\"\n    invalid = []\n    dependency_package = self.get_dependency_dist_item()\n    if (\n        dependency_package is not None\n        and dependency_package.state != UpdateState.UPDATED\n    ):\n        invalid.append(\"Dependency package\")\n\n    for item in self.get_addon_dist_items():\n        dist_item = item[\"dist_item\"]\n        if dist_item.state != UpdateState.UPDATED:\n            invalid.append(item[\"addon_name\"])\n\n    if not invalid:\n        return\n\n    raise RuntimeError(\"Failed to distribute {}\".format(\n        \", \".join([f'\"{item}\"' for item in invalid])\n    ))\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.BaseDistributionItem","title":"<code>BaseDistributionItem</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Distribution item with sources and target directories.</p> <p>Distribution item can be an installer, addon or dependency package. Distribution item can be already distributed and don't need any progression. The item keeps track of the progress. The reason is to be able to use the distribution items as source data for UI without implementing the same logic.</p> <p>Distribution is \"state\" based. Distribution can be 'UPDATED' or 'OUTDATED' at the initialization. If item is 'UPDATED' the distribution is skipped and 'OUTDATED' will trigger the distribution process.</p> <p>Because the distribution may have multiple sources each source has own progress item.</p> <p>Parameters:</p> Name Type Description Default <code>download_dirpath</code> <code>str</code> <p>Path to directory where file is unzipped.</p> required <code>state</code> <code>UpdateState</code> <p>Initial state (UpdateState.UPDATED or UpdateState.OUTDATED).</p> required <code>checksum</code> <code>Optional[str]</code> <p>Hash of file for validation.</p> required <code>checksum_algorithm</code> <code>Optional[str]</code> <p>Algorithm used to generate the hash.</p> required <code>factory</code> <code>DownloadFactory</code> <p>Downloaders factory object.</p> required <code>sources</code> <code>List[SourceInfo]</code> <p>Possible sources to receive the distribution item.</p> required <code>downloader_data</code> <code>Dict[str, Any]</code> <p>More information for downloaders.</p> required <code>item_label</code> <code>str</code> <p>Label used in log outputs (and in UI).</p> required <code>progress_dir</code> <code>Optional[str]</code> <p>Directory where progress is stored for other processes.</p> <code>None</code> <code>logger</code> <code>Optional[Logger]</code> <p>Logger object.</p> <code>None</code> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>class BaseDistributionItem(ABC):\n    \"\"\"Distribution item with sources and target directories.\n\n    Distribution item can be an installer, addon or dependency package.\n    Distribution item can be already distributed and don't need any\n    progression. The item keeps track of the progress. The reason is to be\n    able to use the distribution items as source data for UI without\n    implementing the same logic.\n\n    Distribution is \"state\" based. Distribution can be 'UPDATED' or 'OUTDATED'\n    at the initialization. If item is 'UPDATED' the distribution is skipped\n    and 'OUTDATED' will trigger the distribution process.\n\n    Because the distribution may have multiple sources each source has own\n    progress item.\n\n    Args:\n        download_dirpath (str): Path to directory where file is unzipped.\n        state (UpdateState): Initial state (UpdateState.UPDATED or\n            UpdateState.OUTDATED).\n        checksum (Optional[str]): Hash of file for validation.\n        checksum_algorithm (Optional[str]): Algorithm used to generate the hash.\n        factory (DownloadFactory): Downloaders factory object.\n        sources (List[SourceInfo]): Possible sources to receive the\n            distribution item.\n        downloader_data (Dict[str, Any]): More information for downloaders.\n        item_label (str): Label used in log outputs (and in UI).\n        progress_dir (Optional[str]): Directory where progress is stored for\n            other processes.\n        logger (Optional[logging.Logger]): Logger object.\n\n    \"\"\"\n    def __init__(\n        self,\n        download_dirpath: str,\n        state: UpdateState,\n        checksum: Optional[str],\n        checksum_algorithm: Optional[str],\n        factory: DownloadFactory,\n        sources: list[SourceInfo],\n        downloader_data: dict[str, Any],\n        item_label: str,\n        progress_dir: Optional[str] = None,\n        logger: Optional[logging.Logger] = None,\n    ):\n        if logger is None:\n            logger = logging.getLogger(self.__class__.__name__)\n        self.log: logging.Logger = logger\n        self.state: UpdateState = state\n        self.download_dirpath: str = download_dirpath\n        self.checksum: Optional[str] = checksum\n        self.checksum_algorithm: Optional[str] = checksum_algorithm\n        self.factory: DownloadFactory = factory\n        self.sources = self._prepare_sources(sources)\n        self.downloader_data: dict[str, Any] = downloader_data\n        self.item_label: str = item_label\n\n        self._need_distribution = state != UpdateState.UPDATED\n        self._current_source_progress = None\n        self._used_source_progress = None\n        self._used_source = None\n        self._dist_started = False\n\n        self._progress_id = uuid.uuid4().hex\n        self._progress_dir = progress_dir\n\n        self._error_msg = None\n        self._error_detail = None\n\n    @staticmethod\n    def _prepare_sources(sources: list[SourceInfo]):\n        return [\n            (source, DistributeTransferProgress())\n            for source in sources\n        ]\n\n    @property\n    def need_distribution(self) -&gt; bool:\n        \"\"\"Need distribution based on initial state.\n\n        Returns:\n            bool: Need distribution.\n\n        \"\"\"\n        return self._need_distribution\n\n    @property\n    def current_source_progress(self) -&gt; Optional[DistributeTransferProgress]:\n        \"\"\"Currently processed source progress object.\n\n        Returns:\n            Optional[DistributeTransferProgress]: Transfer progress or None.\n\n        \"\"\"\n        return self._current_source_progress\n\n    @property\n    def used_source_progress(self) -&gt; Optional[DistributeTransferProgress]:\n        \"\"\"Transfer progress that successfully distributed the item.\n\n        Returns:\n            Optional[DistributeTransferProgress]: Transfer progress or None.\n\n        \"\"\"\n        return self._used_source_progress\n\n    @property\n    def used_source(self) -&gt; Optional[dict[str, Any]]:\n        \"\"\"Data of source item.\n\n        Returns:\n            Optional[dict[str, Any]]: SourceInfo data or None.\n\n        \"\"\"\n        return self._used_source\n\n    @property\n    def error_message(self) -&gt; Optional[str]:\n        \"\"\"Reason why distribution item failed.\n\n        Returns:\n            Optional[str]: Error message.\n        \"\"\"\n\n        return self._error_msg\n\n    @property\n    def error_detail(self) -&gt; Optional[str]:\n        \"\"\"Detailed reason why distribution item failed.\n\n        Returns:\n            Optional[str]: Detailed information (maybe traceback).\n        \"\"\"\n\n        return self._error_detail\n\n    @property\n    @abstractmethod\n    def is_missing_permissions(self) -&gt; bool:\n        pass\n\n    def _pre_source_process(self):\n        if not os.path.exists(self.download_dirpath):\n            os.makedirs(self.download_dirpath, exist_ok=True)\n\n        change_permissions_recursive(self.download_dirpath)\n\n    def _receive_file(\n        self,\n        source_data: dict[str, Any],\n        source_progress: DistributeTransferProgress,\n        downloader: SourceDownloader,\n    ) -&gt; Optional[str]:\n        \"\"\"Receive source filepath using source data and downloader.\n\n        Args:\n            source_data (dict[str, Any]): Source information.\n            source_progress (DistributeTransferProgress): Object where to\n                track process of a source.\n            downloader (SourceDownloader): Downloader object which should care\n                about receiving file from source.\n\n        Returns:\n            Optional[str]: Filepath to received file from source.\n\n        \"\"\"\n        download_dirpath = self.download_dirpath\n\n        try:\n            filepath = downloader.download(\n                source_data,\n                download_dirpath,\n                self.downloader_data,\n                source_progress.transfer_progress,\n            )\n        except Exception:\n            message = \"Failed to download source\"\n            source_progress.set_failed(message)\n            self.log.warning(\n                f\"{self.item_label}: {message}\",\n                exc_info=True\n            )\n            return None\n\n        source_progress.set_hash_check_started()\n        try:\n            # WARNING This condition was added because addons don't have\n            #   information about checksum at the moment.\n            # TODO remove once addon can supply checksum.\n            if self.checksum:\n                downloader.check_hash(\n                    filepath, self.checksum, self.checksum_algorithm\n                )\n            else:\n                # Fill checksum automatically based on downloaded file\n                # - still better than nothing\n                if not self.checksum_algorithm:\n                    self.checksum_algorithm = \"sha256\"\n                self.checksum = calculate_file_checksum(\n                    filepath, self.checksum_algorithm\n                )\n\n        except Exception:\n            message = \"File hash does not match\"\n            source_progress.set_failed(message)\n            self.log.warning(\n                f\"{self.item_label}: {message}\",\n                exc_info=True\n            )\n            return None\n        source_progress.set_hash_check_finished()\n        return filepath\n\n    def _post_source_process(\n        self,\n        filepath: str,\n        source_data: dict[str, Any],\n        source_progress: DistributeTransferProgress,\n        downloader: SourceDownloader,\n    ) -&gt; Generator[Optional[bool], None, None]:\n        \"\"\"Process source after it is downloaded and validated.\n\n        Override this method if downloaded file needs more logic to do, like\n            extraction.\n\n        This part will mark source as updated and will trigger cleanup of\n        source files via downloader (e.g. to remove downloaded file).\n\n        Args:\n            filepath (str): Path to a downloaded source.\n            source_data (dict[str, Any]): Source information data.\n            source_progress (DistributeTransferProgress): Source progress.\n            downloader (SourceDownloader): Object which cared about download\n                of file.\n\n        Returns:\n            Generator[Optional[bool], None, None]: Post processing finished\n                in a way that it is not needed to process other possible\n                sources. Does not mean that it was successful. If yields None\n                then is still working.\n\n        \"\"\"\n        if filepath:\n            self.state = UpdateState.UPDATED\n            self._used_source = source_data\n\n        downloader.cleanup(\n            source_data,\n            self.download_dirpath,\n            self.downloader_data\n        )\n        yield bool(filepath)\n\n    def _process_source(\n        self,\n        source: SourceInfo,\n        source_progress: DistributeTransferProgress,\n    ) -&gt; Generator[Optional[bool], None, None]:\n        \"\"\"Process single source item.\n\n        Cares about download, validate and process source.\n\n        Args:\n            source (SourceInfo): Source information.\n            source_progress (DistributeTransferProgress): Object to keep track\n                about process of a source.\n\n        Returns:\n            Generator[Optional[bool], None, None]: Source was processed so\n                any other sources can be skipped. Does not have to be\n                successfull. Is still working if yields None.\n\n        \"\"\"\n        self._current_source_progress = source_progress\n        source_progress.set_started()\n\n        self._pre_source_process()\n        try:\n            downloader = self.factory.get_downloader(source.type)\n        except Exception:\n            message = f\"Unknown downloader {source.type}\"\n            source_progress.set_failed(message)\n            self.log.warning(message, exc_info=True)\n            yield False\n            return\n\n        try:\n            source_data = dataclasses.asdict(source)\n            filepath = self._receive_file(\n                source_data,\n                source_progress,\n                downloader\n            )\n\n            yield from self._post_source_process(\n                filepath, source_data, source_progress, downloader\n            )\n\n        except Exception:\n            message = \"Failed to process source\"\n            source_progress.set_failed(message)\n            self.log.warning(\n                f\"{self.item_label}: {message}\",\n                exc_info=True\n            )\n            yield False\n\n    def _set_progress_state(self, state: DistFileStates):\n        if not self._progress_dir:\n            return\n\n        progress_info = _read_progress_file(self._progress_dir)\n        if progress_info.get(\"progress_id\") != self._progress_id:\n            # Ignore if wanted to set 'failed' state\n            if state == DistFileStates.failed:\n                return\n            raise DistributionProgressInterupted(\n                \"Different process took over progress file.\"\n            )\n\n        progress_info[\"state\"] = state.value\n        if state == DistFileStates.done:\n            # Update checksum if it was not set from server information\n            if not progress_info[\"checksum\"] and self.checksum:\n                progress_info[\"checksum\"] = self.checksum\n                progress_info[\"checksum_algorithm\"] = self.checksum_algorithm\n            progress_info[\"dist_finished\"] = (\n                datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            )\n\n        _store_progress_file(self._progress_dir, progress_info)\n\n    def _distribute(self) -&gt; Generator[bool, None, None]:\n        if not self.sources:\n            message = (\n                f\"{self.item_label}: Don't have\"\n                \" any sources to download from.\"\n            )\n            self.log.error(message)\n            self._error_msg = message\n            self.state = UpdateState.MISS_SOURCE_FILES\n            yield True\n            return\n\n        # Progress file\n        # - Check if other process/machine already started the job\n        if self._progress_dir:\n            result = False\n            for result in _wait_for_other_process(\n                self._progress_dir,\n                self._progress_id,\n                self.log\n            ):\n                if result is not None:\n                    # Give other distribution items option to start waiting\n                    #   cycle\n                    yield False\n                    break\n                yield False\n\n            if result is True:\n                self.state = UpdateState.UPDATED\n                self.log.info(f\"{self.item_label}: Already distributed\")\n                yield True\n                return\n\n            _create_progress_file(\n                self._progress_dir,\n                self._progress_id,\n                self.checksum,\n                self.checksum_algorithm,\n            )\n\n        # Download\n        for source, source_progress in self.sources:\n            yield False\n            result = False\n            for result in self._process_source(source, source_progress):\n                if result is not None:\n                    break\n\n            if result:\n                break\n\n        last_progress = self._current_source_progress\n        self._current_source_progress = None\n        if self.state == UpdateState.UPDATED:\n            self._set_progress_state(DistFileStates.done)\n            self._used_source_progress = last_progress\n            self.log.info(f\"{self.item_label}: Distributed\")\n        else:\n            self._set_progress_state(DistFileStates.failed)\n            self.log.error(f\"{self.item_label}: Failed to distribute\")\n            self._error_msg = \"Failed to receive or install source files\"\n        yield True\n\n    def _post_distribute(self):\n        pass\n\n    def is_distributed(self):\n        if not self.need_distribution:\n            return True\n        return self.state == UpdateState.UPDATED\n\n    def distribute(self) -&gt; Generator[bool, None, None]:\n        \"\"\"Execute distribution logic.\"\"\"\n        if self.is_distributed() or self._dist_started:\n            yield True\n            return\n\n        self._dist_started = True\n        try:\n            try:\n                for result in self._distribute():\n                    if result:\n                        break\n                    yield False\n\n            except DistributionProgressInterupted:\n                wait_result = False\n                for wait_result in _wait_for_other_process(\n                    self._progress_dir, self._progress_id, self.log\n                ):\n                    if wait_result is not None:\n                        break\n                    yield False\n\n                if wait_result:\n                    self.state = UpdateState.UPDATED\n                else:\n                    self.state = UpdateState.UPDATE_FAILED\n                    self._error_msg = (\n                        \"Other process took over distribution and failed.\"\n                    )\n                    self._error_detail = (\n                        \"Please try to start AYON again and contact\"\n                        \" administrator if issue persist.\"\n                    )\n                    self.log.error(\n                        f\"{self.item_label}: {self._error_msg}\"\n                    )\n\n        except Exception as exc:\n            self.state = UpdateState.UPDATE_FAILED\n            self._error_msg = str(exc)\n            self._error_detail = \"\".join(\n                traceback.format_exception(*sys.exc_info())\n            )\n            self.log.error(\n                f\"{self.item_label}: Distibution failed\",\n                exc_info=True\n            )\n\n        finally:\n            if self.state == UpdateState.OUTDATED:\n                self.state = UpdateState.UPDATE_FAILED\n                self._error_msg = \"Distribution failed\"\n\n            self._post_distribute()\n            yield True\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.BaseDistributionItem.current_source_progress","title":"<code>current_source_progress</code>  <code>property</code>","text":"<p>Currently processed source progress object.</p> <p>Returns:</p> Type Description <code>Optional[DistributeTransferProgress]</code> <p>Optional[DistributeTransferProgress]: Transfer progress or None.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.BaseDistributionItem.error_detail","title":"<code>error_detail</code>  <code>property</code>","text":"<p>Detailed reason why distribution item failed.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Detailed information (maybe traceback).</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.BaseDistributionItem.error_message","title":"<code>error_message</code>  <code>property</code>","text":"<p>Reason why distribution item failed.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Error message.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.BaseDistributionItem.need_distribution","title":"<code>need_distribution</code>  <code>property</code>","text":"<p>Need distribution based on initial state.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Need distribution.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.BaseDistributionItem.used_source","title":"<code>used_source</code>  <code>property</code>","text":"<p>Data of source item.</p> <p>Returns:</p> Type Description <code>Optional[dict[str, Any]]</code> <p>Optional[dict[str, Any]]: SourceInfo data or None.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.BaseDistributionItem.used_source_progress","title":"<code>used_source_progress</code>  <code>property</code>","text":"<p>Transfer progress that successfully distributed the item.</p> <p>Returns:</p> Type Description <code>Optional[DistributeTransferProgress]</code> <p>Optional[DistributeTransferProgress]: Transfer progress or None.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.BaseDistributionItem.distribute","title":"<code>distribute()</code>","text":"<p>Execute distribution logic.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def distribute(self) -&gt; Generator[bool, None, None]:\n    \"\"\"Execute distribution logic.\"\"\"\n    if self.is_distributed() or self._dist_started:\n        yield True\n        return\n\n    self._dist_started = True\n    try:\n        try:\n            for result in self._distribute():\n                if result:\n                    break\n                yield False\n\n        except DistributionProgressInterupted:\n            wait_result = False\n            for wait_result in _wait_for_other_process(\n                self._progress_dir, self._progress_id, self.log\n            ):\n                if wait_result is not None:\n                    break\n                yield False\n\n            if wait_result:\n                self.state = UpdateState.UPDATED\n            else:\n                self.state = UpdateState.UPDATE_FAILED\n                self._error_msg = (\n                    \"Other process took over distribution and failed.\"\n                )\n                self._error_detail = (\n                    \"Please try to start AYON again and contact\"\n                    \" administrator if issue persist.\"\n                )\n                self.log.error(\n                    f\"{self.item_label}: {self._error_msg}\"\n                )\n\n    except Exception as exc:\n        self.state = UpdateState.UPDATE_FAILED\n        self._error_msg = str(exc)\n        self._error_detail = \"\".join(\n            traceback.format_exception(*sys.exc_info())\n        )\n        self.log.error(\n            f\"{self.item_label}: Distibution failed\",\n            exc_info=True\n        )\n\n    finally:\n        if self.state == UpdateState.OUTDATED:\n            self.state = UpdateState.UPDATE_FAILED\n            self._error_msg = \"Distribution failed\"\n\n        self._post_distribute()\n        yield True\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.DistributeTransferProgress","title":"<code>DistributeTransferProgress</code>","text":"<p>Progress of single source item in 'DistributionItem'.</p> <p>The item is to keep track of single source item.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>class DistributeTransferProgress:\n    \"\"\"Progress of single source item in 'DistributionItem'.\n\n    The item is to keep track of single source item.\n    \"\"\"\n\n    def __init__(self):\n        self._transfer_progress = ayon_api.TransferProgress()\n        self._started = False\n        self._failed = False\n        self._fail_reason = None\n        self._unzip_started = False\n        self._unzip_finished = False\n        self._hash_check_started = False\n        self._hash_check_finished = False\n\n    def set_started(self):\n        \"\"\"Call when source distribution starts.\"\"\"\n\n        self._started = True\n\n    def set_failed(self, reason: str):\n        \"\"\"Set source distribution as failed.\n\n        Args:\n            reason (str): Error message why the transfer failed.\n\n        \"\"\"\n        self._failed = True\n        self._fail_reason = reason\n\n    def set_hash_check_started(self):\n        \"\"\"Call just before hash check starts.\"\"\"\n\n        self._hash_check_started = True\n\n    def set_hash_check_finished(self):\n        \"\"\"Call just after hash check finishes.\"\"\"\n\n        self._hash_check_finished = True\n\n    def set_unzip_started(self):\n        \"\"\"Call just before unzip starts.\"\"\"\n\n        self._unzip_started = True\n\n    def set_unzip_finished(self):\n        \"\"\"Call just after unzip finishes.\"\"\"\n\n        self._unzip_finished = True\n\n    @property\n    def is_running(self) -&gt; bool:\n        \"\"\"Source distribution is in progress.\n\n        Returns:\n            bool: Transfer is in progress.\n        \"\"\"\n\n        return bool(\n            self._started\n            and not self._failed\n            and not self._hash_check_finished\n        )\n\n    @property\n    def transfer_progress(self) -&gt; ayon_api.TransferProgress:\n        \"\"\"Source file 'download' progress tracker.\n\n        Returns:\n            ayon_api.TransferProgress: Content download progress.\n\n        \"\"\"\n        return self._transfer_progress\n\n    @property\n    def started(self) -&gt; bool:\n        return self._started\n\n    @property\n    def hash_check_started(self) -&gt; bool:\n        return self._hash_check_started\n\n    @property\n    def hash_check_finished(self) -&gt; bool:\n        return self._hash_check_finished\n\n    @property\n    def unzip_started(self) -&gt; bool:\n        return self._unzip_started\n\n    @property\n    def unzip_finished(self) -&gt; bool:\n        return self._unzip_finished\n\n    @property\n    def failed(self) -&gt; bool:\n        return self._failed or self._transfer_progress.failed\n\n    @property\n    def fail_reason(self) -&gt; Optional[str]:\n        return self._fail_reason or self._transfer_progress.fail_reason\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.DistributeTransferProgress.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Source distribution is in progress.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Transfer is in progress.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.DistributeTransferProgress.transfer_progress","title":"<code>transfer_progress</code>  <code>property</code>","text":"<p>Source file 'download' progress tracker.</p> <p>Returns:</p> Type Description <code>TransferProgress</code> <p>ayon_api.TransferProgress: Content download progress.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.DistributeTransferProgress.set_failed","title":"<code>set_failed(reason)</code>","text":"<p>Set source distribution as failed.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>str</code> <p>Error message why the transfer failed.</p> required Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def set_failed(self, reason: str):\n    \"\"\"Set source distribution as failed.\n\n    Args:\n        reason (str): Error message why the transfer failed.\n\n    \"\"\"\n    self._failed = True\n    self._fail_reason = reason\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.DistributeTransferProgress.set_hash_check_finished","title":"<code>set_hash_check_finished()</code>","text":"<p>Call just after hash check finishes.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def set_hash_check_finished(self):\n    \"\"\"Call just after hash check finishes.\"\"\"\n\n    self._hash_check_finished = True\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.DistributeTransferProgress.set_hash_check_started","title":"<code>set_hash_check_started()</code>","text":"<p>Call just before hash check starts.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def set_hash_check_started(self):\n    \"\"\"Call just before hash check starts.\"\"\"\n\n    self._hash_check_started = True\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.DistributeTransferProgress.set_started","title":"<code>set_started()</code>","text":"<p>Call when source distribution starts.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def set_started(self):\n    \"\"\"Call when source distribution starts.\"\"\"\n\n    self._started = True\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.DistributeTransferProgress.set_unzip_finished","title":"<code>set_unzip_finished()</code>","text":"<p>Call just after unzip finishes.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def set_unzip_finished(self):\n    \"\"\"Call just after unzip finishes.\"\"\"\n\n    self._unzip_finished = True\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.DistributeTransferProgress.set_unzip_started","title":"<code>set_unzip_started()</code>","text":"<p>Call just before unzip starts.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>def set_unzip_started(self):\n    \"\"\"Call just before unzip starts.\"\"\"\n\n    self._unzip_started = True\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.DistributionItem","title":"<code>DistributionItem</code>","text":"<p>               Bases: <code>BaseDistributionItem</code></p> <p>Distribution item with sources and target directories.</p> <p>Distribution item for addons and dependency packages. They have defined unzip directory where the downloaded content is unzipped.</p> <p>Parameters:</p> Name Type Description Default <code>target_dirpath</code> <code>str</code> <p>Path to directory where zip is downloaded.</p> required <code>download_dirpath</code> <code>str</code> <p>Path to directory where file is unzipped.</p> required <code>state</code> <code>UpdateState</code> <p>Initial state (UpdateState.UPDATED or UpdateState.OUTDATED).</p> required <code>file_hash</code> <code>str</code> <p>Hash of file for validation.</p> required <code>factory</code> <code>DownloadFactory</code> <p>Downloaders factory object.</p> required <code>sources</code> <code>List[SourceInfo]</code> <p>Possible sources to receive the distribution item.</p> required <code>downloader_data</code> <code>Dict[str, Any]</code> <p>More information for downloaders.</p> required <code>item_label</code> <code>str</code> <p>Label used in log outputs (and in UI).</p> required <code>progress_dir</code> <code>Optional[str]</code> <p>Directory where progress is stored for other processes.</p> required <code>logger</code> <code>Logger</code> <p>Logger object.</p> required Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>class DistributionItem(BaseDistributionItem):\n    \"\"\"Distribution item with sources and target directories.\n\n    Distribution item for addons and dependency packages. They have defined\n    unzip directory where the downloaded content is unzipped.\n\n    Args:\n        target_dirpath (str): Path to directory where zip is downloaded.\n        download_dirpath (str): Path to directory where file is unzipped.\n        state (UpdateState): Initial state (UpdateState.UPDATED or\n            UpdateState.OUTDATED).\n        file_hash (str): Hash of file for validation.\n        factory (DownloadFactory): Downloaders factory object.\n        sources (List[SourceInfo]): Possible sources to receive the\n            distribution item.\n        downloader_data (Dict[str, Any]): More information for downloaders.\n        item_label (str): Label used in log outputs (and in UI).\n        progress_dir (Optional[str]): Directory where progress is stored for\n            other processes.\n        logger (logging.Logger): Logger object.\n\n    \"\"\"\n    def __init__(\n        self, target_dirpath: str, unzip_temp_dir: str, *args, **kwargs\n    ):\n        self.target_dirpath = target_dirpath\n        self.unzip_temp_dir = unzip_temp_dir\n        super().__init__(*args, **kwargs)\n\n    @property\n    def is_missing_permissions(self) -&gt; bool:\n        return not _has_write_permissions(self.target_dirpath)\n\n    def _post_source_process(\n        self,\n        filepath: str,\n        source_data: dict[str, Any],\n        source_progress: DistributeTransferProgress,\n        downloader: SourceDownloader,\n    ) -&gt; Generator[Optional[bool], None, None]:\n        source_progress.set_unzip_started()\n        result = False\n        for result in _wait_for_other_process(\n            self._progress_dir, self._progress_id, self.log\n        ):\n            if result is not None:\n                break\n            yield None\n\n        if result is True:\n            self.state = UpdateState.UPDATED\n            yield True\n            return\n\n        filename = os.path.basename(self.target_dirpath)\n        unzip_dirpath = os.path.join(self.unzip_temp_dir, filename)\n        # NOTE This is a workaround for dependency packages\n        # TODO remove when dependency packages are not stored to directory\n        #   ending with .zip\n        if filepath == unzip_dirpath:\n            filedir = os.path.dirname(filepath)\n            ext = os.path.splitext(filepath)[-1]\n            new_filepath = os.path.join(filedir, f\"{uuid.uuid4().hex}{ext}\")\n            os.rename(filepath, new_filepath)\n            filepath = new_filepath\n\n        # Create directory\n        os.makedirs(unzip_dirpath, exist_ok=True)\n        change_permissions_recursive(unzip_dirpath)\n\n        try:\n            downloader.unzip(filepath, unzip_dirpath)\n        except Exception:\n            message = \"Couldn't unzip source file\"\n            source_progress.set_failed(message)\n            self.log.warning(\n                f\"{self.item_label}: {message}\",\n                exc_info=True\n            )\n            yield False\n            return\n\n        source_progress.set_unzip_finished()\n\n        yield None\n\n        result = False\n        for result in _wait_for_other_process(\n            self._progress_dir, self._progress_id, self.log\n        ):\n            if result is not None:\n                break\n            yield None\n\n        if result is True:\n            self.state = UpdateState.UPDATED\n            yield True\n            return\n\n        failed = False\n        renamed_mapping = []\n\n        # Target directory can contain only distribution metadata file\n        #   anything else is temporarily moved to different directory\n        #   - next to target directory\n        # NOTE: We might validate if the content is exactly same?\n        tmp_subfolder = os.path.join(\n            os.path.dirname(self.target_dirpath), uuid.uuid4().hex\n        )\n        if not os.path.exists(self.target_dirpath):\n            os.makedirs(self.target_dirpath, exist_ok=True)\n            change_permissions_recursive(self.target_dirpath)\n\n        for name in os.listdir(self.target_dirpath):\n            if name == DIST_PROGRESS_FILENAME:\n                continue\n            if not os.path.exists(tmp_subfolder):\n                os.makedirs(tmp_subfolder, exist_ok=True)\n                change_permissions_recursive(tmp_subfolder)\n\n            current_path = os.path.join(self.target_dirpath, name)\n            new_path = os.path.join(tmp_subfolder, name)\n            try:\n                os.rename(current_path, new_path)\n            except Exception:\n                message = (\n                    \"Target files already exist and can't be renamed.\"\n                )\n                source_progress.set_failed(message)\n                self.log.warning(\n                    f\"{self.item_label}: {message}\",\n                    exc_info=True\n                )\n                failed = True\n                break\n            renamed_mapping.append((current_path, new_path))\n\n        if failed:\n            # Rollback renamed files\n            for src_path, renamed_path in renamed_mapping:\n                os.rename(renamed_path, src_path)\n            yield False\n            return\n\n        yield None\n\n        # Move unzipped content to target directory\n        moved_paths = []\n        rename_attemps = 5\n        for subname in os.listdir(unzip_dirpath):\n            target_path = os.path.join(self.target_dirpath, subname)\n            src_path = os.path.join(unzip_dirpath, subname)\n            dst_path = os.path.join(self.target_dirpath, subname)\n            self.log.debug(\"Copying %s to %s\", src_path, dst_path)\n            # Sometimes 'os.rename' crashes because of permissions issue\n            #   even though it can be done in a future attempt (probably some\n            #   service traversing through files blocking it?)\n            for attempt in range(rename_attemps):\n                try:\n                    os.rename(src_path, dst_path)\n                    break\n                except Exception:\n                    if attempt &lt; (rename_attemps - 1):\n                        yield None\n                        continue\n                    message = (\n                        \"Failed to move unzipped content to target directory.\"\n                    )\n                    source_progress.set_failed(message)\n                    self.log.warning(\n                        f\"{self.item_label}: {message}\",\n                        exc_info=True\n                    )\n                    failed = True\n\n            if failed:\n                break\n\n            moved_paths.append(target_path)\n\n        # Handle failed movement\n        if failed:\n            # Remove moved files\n            for path in moved_paths:\n                if os.path.isfile(path):\n                    os.remove(path)\n                else:\n                    shutil.rmtree(path)\n\n            # Rename renamed files back to original\n            for src_path, renamed_path in renamed_mapping:\n                os.rename(renamed_path, src_path)\n\n        # Remove temp subfolder used for renaming\n        if os.path.exists(tmp_subfolder):\n            shutil.rmtree(tmp_subfolder)\n\n        if failed:\n            yield False\n            return\n\n        yield from super()._post_source_process(\n            filepath, source_data, source_progress, downloader\n        )\n\n    def _post_distribute(self):\n        if (\n            self.state != UpdateState.UPDATED\n            and self.target_dirpath\n            and os.path.isdir(self.target_dirpath)\n        ):\n            self.log.debug(f\"Cleaning {self.target_dirpath}\")\n            # TODO use '_clean_dist_dir' when backwards compatibility with\n            #   previous versions of AYON launchers is not needed.\n            # _clean_dist_dir(self.target_dirpath)\n            shutil.rmtree(self.target_dirpath)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.InstallerDistributionItem","title":"<code>InstallerDistributionItem</code>","text":"<p>               Bases: <code>BaseDistributionItem</code></p> <p>Distribution of new version of AYON launcher/Installer.</p> Source code in <code>common/ayon_common/distribution/control.py</code> <pre><code>class InstallerDistributionItem(BaseDistributionItem):\n    \"\"\"Distribution of new version of AYON launcher/Installer.\"\"\"\n\n    def __init__(self, cleanup_on_fail: bool, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._cleanup_on_fail = cleanup_on_fail\n        self._executable = None\n        self._installer_path = None\n        self._installer_error = None\n\n    @property\n    def executable(self) -&gt; Optional[str]:\n        \"\"\"Path to distributed ayon executable.\n\n        Returns:\n            Optional[str]: Path to executable path which was distributed.\n\n        \"\"\"\n        return self._executable\n\n    @property\n    def installer_path(self) -&gt; Optional[str]:\n        \"\"\"Path to a distribution package/installer.\n\n        This can be used as reference for user where to find downloaded\n            installer on disk and distribute it manually.\n\n        Returns:\n            Optional[str]: Path to installer.\n\n        \"\"\"\n        return self._installer_path\n\n    @property\n    def installer_error(self) -&gt; Optional[str]:\n        \"\"\"Known installer error that happened during distribution.\n\n        Returns:\n            Optional[str]: Message that will be shown to user and logged\n                out.\n\n        \"\"\"\n        return self._installer_error\n\n    @property\n    def is_missing_permissions(self) -&gt; bool:\n        return not _has_write_permissions(\n            os.path.dirname(os.path.dirname(sys.executable))\n        )\n\n    def _find_windows_executable(self, log_output: str):\n        \"\"\"Find executable path in log output.\n\n        Setup exe should print out log output to a file where are described\n        steps that happened during installation.\n\n        Todos:\n            Find a better way how to find out where AYON launcher was\n                installed.\n\n        Args:\n            log_output (str): Output from installer log.\n\n        \"\"\"\n        exe_name = \"ayon.exe\"\n        for line in log_output.splitlines():\n            idx = line.find(exe_name)\n            if idx &lt; 0:\n                continue\n\n            line = line[:idx + len(exe_name)]\n            parts = line.split(\"\\\\\")\n            if len(parts) &lt; 2:\n                parts = line.replace(\"/\", \"\\\\\").split(\"\\\\\")\n\n            last_part = parts.pop(-1)\n            found_valid = False\n            final_parts = []\n            for part in parts:\n                if found_valid:\n                    final_parts.append(part)\n                    continue\n                part = part + \"\\\\\"\n                while part:\n                    if os.path.exists(part):\n                        break\n                    part = part[1:]\n\n                if part:\n                    found_valid = True\n                    final_parts.append(part[:-1])\n            final_parts.append(last_part)\n            executable_path = \"\\\\\".join(final_parts)\n            if os.path.exists(executable_path):\n                return executable_path\n\n    def _install_windows(self, filepath: str):\n        \"\"\"Install windows AYON launcher.\n\n        Args:\n            filepath (str): Path to setup.exe file.\n\n        \"\"\"\n        install_root = os.path.dirname(os.path.dirname(sys.executable))\n\n        # A file where installer may store log output\n        log_file = create_tmp_file(suffix=\"ayon_install\")\n        # A file where installer may store output directory\n        install_exe_tmp = create_tmp_file(suffix=\"ayon_install_dir\")\n        user_arg = \"/CURRENTUSER\"\n        # Ask for admin permissions if user is not admin and\n        if not _has_write_permissions(install_root):\n            if HEADLESS_MODE_ENABLED:\n                raise InstallerDistributionError((\n                    \"Installation requires administration permissions, which\"\n                    \" cannot be granted in headless mode.\"\n                ))\n            user_arg = \"/ALLUSERS\"\n        args = [\n            filepath,\n            user_arg,\n            \"/NOCANCEL\",\n            f\"/LOG={log_file}\",\n            f\"/INSTALLROOT={install_root}\"\n        ]\n        if not HEADLESS_MODE_ENABLED:\n            args.append(\"/SILENT\")\n        else:\n            args.append(\"/VERYSILENT\")\n\n        env = dict(os.environ.items())\n        env[\"AYON_INSTALL_EXE_OUTPUT\"] = install_exe_tmp\n\n        code = subprocess.call(args, env=env)\n        with open(log_file, \"r\") as stream:\n            log_output = stream.read()\n        with open(install_exe_tmp, \"r\") as stream:\n            install_exe_path = stream.read()\n        os.remove(log_file)\n        os.remove(install_exe_tmp)\n        if code != 0:\n            self.log.error(log_output)\n            raise InstallerDistributionError(\n                \"Install process failed without known reason.\"\n                \" Try to install AYON manually.\"\n            )\n\n        executable = install_exe_path.strip() or None\n        if not executable or not os.path.exists(executable):\n            executable = self._find_windows_executable(log_output)\n\n        self._executable = executable\n\n    def _install_linux(self, filepath: str):\n        \"\"\"Install linux AYON launcher.\n\n        Linux installations are just an archive file, so we attempt to unzip\n            the new installation one level up of the one being run.\n\n        Args:\n            filepath (str): Path to a .tar.gz file.\n\n        \"\"\"\n        install_root = os.path.dirname(os.path.dirname(sys.executable))\n\n        self.log.info(\n            f\"Installing AYON launcher {filepath} into:\\n{install_root}\"\n        )\n\n        if not os.path.exists(install_root):\n            os.makedirs(install_root, exist_ok=True)\n\n        try:\n            extract_archive_file(filepath, install_root)\n        except Exception as e:\n            self.log.error(e)\n            raise InstallerDistributionError(\n                \"Install process failed without known reason.\"\n                \" Try to install AYON manually.\"\n            )\n\n        installer_dir = os.path.basename(filepath).replace(\".tar.gz\", \"\")\n        executable = os.path.join(install_root, installer_dir, \"ayon\")\n        self.log.info(f\"Setting executable to {executable}\")\n        self._executable = executable\n\n    def _install_macos(self, filepath: str):\n        \"\"\"Install macOS AYON launcher.\n\n        Args:\n            filepath (str): Path to a .dmg file.\n\n        \"\"\"\n        import plistlib\n\n        # Attach dmg file and read plist output (bytes)\n        stdout = subprocess.check_output([\n            \"hdiutil\", \"attach\", filepath, \"-plist\", \"-nobrowse\"\n        ])\n        mounted_volumes = []\n        try:\n            # Parse plist output and find mounted volume\n            attach_info = plistlib.loads(stdout)\n            for entity in attach_info[\"system-entities\"]:\n                mounted_volume = entity.get(\"mount-point\")\n                if mounted_volume:\n                    mounted_volumes.append(mounted_volume)\n\n            # We do expect there is only one .app in .dmg file\n            src_path = None\n            src_filename = None\n            for mounted_volume in mounted_volumes:\n                for filename in os.listdir(mounted_volume):\n                    if filename.endswith(\".app\"):\n                        src_filename = filename\n                        src_path = os.path.join(mounted_volume, src_filename)\n                        break\n\n            if src_path is not None:\n                # Copy the .app file to /Applications\n                dst_dir = \"/Applications\"\n                dst_path = os.path.join(dst_dir, src_filename)\n                subprocess.run([\"cp\", \"-rf\", src_path, dst_dir])\n\n        finally:\n            # Detach mounted volume\n            for mounted_volume in mounted_volumes:\n                subprocess.run([\"hdiutil\", \"detach\", mounted_volume])\n\n        # Find executable inside .app file and return its path\n        contents_dir = os.path.join(dst_path, \"Contents\")\n        # Load plist file and check for bundle executable\n        plist_filepath = os.path.join(contents_dir, \"Info.plist\")\n        if hasattr(plistlib, \"load\"):\n            with open(plist_filepath, \"rb\") as stream:\n                parsed_plist = plistlib.load(stream)\n        else:\n            parsed_plist = plistlib.readPlist(plist_filepath)\n        executable_filename = parsed_plist.get(\"CFBundleExecutable\")\n        self._executable = os.path.join(\n            contents_dir, \"MacOS\", executable_filename\n        )\n\n    def _install_file(self, filepath):\n        \"\"\"Trigger installation installer file based on platform.\"\"\"\n\n        # TODO consider using platform name in target folder\n        #  - for windows and linux\n        platform_name = platform.system().lower()\n        if platform_name == \"windows\":\n            self._install_windows(filepath)\n        elif platform_name == \"linux\":\n            self._install_linux(filepath)\n        elif platform_name == \"darwin\":\n            self._install_macos(filepath)\n        else:\n            raise InstallerDistributionError(\n                f\"Unsupported platform: {platform_name}\"\n            )\n\n    def _post_source_process(\n        self,\n        filepath: str,\n        source_data: dict[str, Any],\n        source_progress: DistributeTransferProgress,\n        downloader: SourceDownloader,\n    ) -&gt; Generator[Optional[bool], None, None]:\n        self._installer_path = filepath\n        success = False\n        try:\n            if filepath:\n                self._install_file(filepath)\n                success = True\n            else:\n                message = \"File was not downloaded\"\n                source_progress.set_failed(message)\n\n        except Exception as exc:\n            message = \"Installation failed\"\n            source_progress.set_failed(message)\n            if isinstance(exc, InstallerDistributionError):\n                self._installer_error = str(exc)\n            else:\n                self.log.warning(\n                    f\"{self.item_label}: {message}\",\n                    exc_info=True\n                )\n                self._installer_error = (\n                    \"Distribution of AYON launcher\"\n                    \" failed with unexpected reason.\"\n                )\n\n        self.state = (\n            UpdateState.UPDATED if success else UpdateState.UPDATE_FAILED\n        )\n\n        self._used_source = source_data\n        if success or self._cleanup_on_fail:\n            downloader.cleanup(\n                source_data,\n                self.download_dirpath,\n                self.downloader_data\n            )\n\n        yield True\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.InstallerDistributionItem.executable","title":"<code>executable</code>  <code>property</code>","text":"<p>Path to distributed ayon executable.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Path to executable path which was distributed.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.InstallerDistributionItem.installer_error","title":"<code>installer_error</code>  <code>property</code>","text":"<p>Known installer error that happened during distribution.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Message that will be shown to user and logged out.</p>"},{"location":"autoapi/common/ayon_common/distribution/control.html#common.ayon_common.distribution.control.InstallerDistributionItem.installer_path","title":"<code>installer_path</code>  <code>property</code>","text":"<p>Path to a distribution package/installer.</p> <p>This can be used as reference for user where to find downloaded     installer on disk and distribute it manually.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: Path to installer.</p>"},{"location":"autoapi/common/ayon_common/distribution/data_structures.html","title":"data_structures","text":""},{"location":"autoapi/common/ayon_common/distribution/data_structures.html#common.ayon_common.distribution.data_structures.AddonInfo","title":"<code>AddonInfo</code>  <code>dataclass</code>","text":"<p>Object matching json payload from Server</p> Source code in <code>common/ayon_common/distribution/data_structures.py</code> <pre><code>@dataclass\nclass AddonInfo:\n    \"\"\"Object matching json payload from Server\"\"\"\n    name: str\n    title: str\n    versions: dict[str, AddonVersionInfo]\n    description: Union[str, None] = None\n    license: Union[str, None] = None\n    authors: Union[str, None] = None\n\n    @classmethod\n    def from_dict(cls, data: dict[str, Any]) -&gt; \"AddonInfo\":\n        \"\"\"Addon info by available versions.\n\n        Args:\n            data (dict[str, Any]): Addon information from server. Should\n                contain information about every version under 'versions'.\n\n        Returns:\n            AddonInfo: Addon info with available versions.\n\n        \"\"\"\n        # server payload contains info about all versions\n        addon_name = data[\"name\"]\n        title = data.get(\"title\") or addon_name\n\n        src_versions = data.get(\"versions\") or {}\n        dst_versions = {\n            addon_version: AddonVersionInfo.from_dict(\n                addon_name, title, addon_version, version_data\n            )\n            for addon_version, version_data in src_versions.items()\n        }\n        return cls(\n            name=addon_name,\n            title=title,\n            versions=dst_versions,\n            description=data.get(\"description\"),\n            license=data.get(\"license\"),\n            authors=data.get(\"authors\")\n        )\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/data_structures.html#common.ayon_common.distribution.data_structures.AddonInfo.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Addon info by available versions.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Addon information from server. Should contain information about every version under 'versions'.</p> required <p>Returns:</p> Name Type Description <code>AddonInfo</code> <code>AddonInfo</code> <p>Addon info with available versions.</p> Source code in <code>common/ayon_common/distribution/data_structures.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict[str, Any]) -&gt; \"AddonInfo\":\n    \"\"\"Addon info by available versions.\n\n    Args:\n        data (dict[str, Any]): Addon information from server. Should\n            contain information about every version under 'versions'.\n\n    Returns:\n        AddonInfo: Addon info with available versions.\n\n    \"\"\"\n    # server payload contains info about all versions\n    addon_name = data[\"name\"]\n    title = data.get(\"title\") or addon_name\n\n    src_versions = data.get(\"versions\") or {}\n    dst_versions = {\n        addon_version: AddonVersionInfo.from_dict(\n            addon_name, title, addon_version, version_data\n        )\n        for addon_version, version_data in src_versions.items()\n    }\n    return cls(\n        name=addon_name,\n        title=title,\n        versions=dst_versions,\n        description=data.get(\"description\"),\n        license=data.get(\"license\"),\n        authors=data.get(\"authors\")\n    )\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/data_structures.html#common.ayon_common.distribution.data_structures.AddonVersionInfo","title":"<code>AddonVersionInfo</code>  <code>dataclass</code>","text":"Source code in <code>common/ayon_common/distribution/data_structures.py</code> <pre><code>@dataclass\nclass AddonVersionInfo:\n    version: str\n    full_name: str\n    title: str = None\n    require_distribution: bool = False\n    sources: list[SourceInfo] = field(default_factory=list)\n    unknown_sources: list[dict[str, Any]] = field(default_factory=list)\n    checksum: Union[str, None] = None\n    checksum_algorithm: Union[str, None] = None\n\n    @classmethod\n    def from_dict(\n        cls,\n        addon_name: str,\n        addon_title: str,\n        addon_version: str,\n        version_data: dict[str, Any],\n    ) -&gt; \"AddonVersionInfo\":\n        \"\"\"Addon version info.\n\n        Args:\n            addon_name (str): Name of addon.\n            addon_title (str): Title of addon.\n            addon_version (str): Version of addon.\n            version_data (dict[str, Any]): Addon version information from\n                server.\n\n        Returns:\n            AddonVersionInfo: Addon version info.\n\n        \"\"\"\n        full_name = f\"{addon_name}_{addon_version}\"\n        title = f\"{addon_title} {addon_version}\"\n\n        source_info = version_data.get(\"clientSourceInfo\")\n        require_distribution = source_info is not None\n        sources, unknown_sources = prepare_sources(\n            source_info, f\"Addon: '{title}'\")\n        checksum = version_data.get(\"checksum\")\n        if checksum is None:\n            checksum = version_data.get(\"hash\")\n\n        return cls(\n            version=addon_version,\n            full_name=full_name,\n            require_distribution=require_distribution,\n            sources=sources,\n            unknown_sources=unknown_sources,\n            checksum=checksum,\n            checksum_algorithm=version_data.get(\"checksumAlgorithm\", \"sha256\"),\n            title=title,\n        )\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/data_structures.html#common.ayon_common.distribution.data_structures.AddonVersionInfo.from_dict","title":"<code>from_dict(addon_name, addon_title, addon_version, version_data)</code>  <code>classmethod</code>","text":"<p>Addon version info.</p> <p>Parameters:</p> Name Type Description Default <code>addon_name</code> <code>str</code> <p>Name of addon.</p> required <code>addon_title</code> <code>str</code> <p>Title of addon.</p> required <code>addon_version</code> <code>str</code> <p>Version of addon.</p> required <code>version_data</code> <code>dict[str, Any]</code> <p>Addon version information from server.</p> required <p>Returns:</p> Name Type Description <code>AddonVersionInfo</code> <code>AddonVersionInfo</code> <p>Addon version info.</p> Source code in <code>common/ayon_common/distribution/data_structures.py</code> <pre><code>@classmethod\ndef from_dict(\n    cls,\n    addon_name: str,\n    addon_title: str,\n    addon_version: str,\n    version_data: dict[str, Any],\n) -&gt; \"AddonVersionInfo\":\n    \"\"\"Addon version info.\n\n    Args:\n        addon_name (str): Name of addon.\n        addon_title (str): Title of addon.\n        addon_version (str): Version of addon.\n        version_data (dict[str, Any]): Addon version information from\n            server.\n\n    Returns:\n        AddonVersionInfo: Addon version info.\n\n    \"\"\"\n    full_name = f\"{addon_name}_{addon_version}\"\n    title = f\"{addon_title} {addon_version}\"\n\n    source_info = version_data.get(\"clientSourceInfo\")\n    require_distribution = source_info is not None\n    sources, unknown_sources = prepare_sources(\n        source_info, f\"Addon: '{title}'\")\n    checksum = version_data.get(\"checksum\")\n    if checksum is None:\n        checksum = version_data.get(\"hash\")\n\n    return cls(\n        version=addon_version,\n        full_name=full_name,\n        require_distribution=require_distribution,\n        sources=sources,\n        unknown_sources=unknown_sources,\n        checksum=checksum,\n        checksum_algorithm=version_data.get(\"checksumAlgorithm\", \"sha256\"),\n        title=title,\n    )\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/data_structures.html#common.ayon_common.distribution.data_structures.Bundle","title":"<code>Bundle</code>  <code>dataclass</code>","text":"<p>Class representing bundle information.</p> Source code in <code>common/ayon_common/distribution/data_structures.py</code> <pre><code>@dataclass\nclass Bundle:\n    \"\"\"Class representing bundle information.\"\"\"\n\n    name: str\n    installer_version: Union[str, None]\n    addon_versions: dict[str, str]\n    dependency_packages: dict[PlatformName, Union[str, None]]\n    is_production: bool\n    is_staging: bool\n    is_dev: bool\n    active_dev_user: Union[str, None]\n    addons_dev_info: dict[str, AddonDevInfo]\n    is_project_bundle: Union[bool, None] = None\n\n    @classmethod\n    def from_dict(cls, data):\n        addons_dev_info = {\n            addon_name: AddonDevInfo(info[\"enabled\"], info[\"path\"])\n            for addon_name, info in data.get(\"addonDevelopment\", {}).items()\n        }\n        return cls(\n            name=data[\"name\"],\n            installer_version=data.get(\"installerVersion\"),\n            addon_versions=data.get(\"addons\", {}),\n            dependency_packages=data.get(\"dependencyPackages\", {}),\n            is_production=data[\"isProduction\"],\n            is_staging=data[\"isStaging\"],\n            is_dev=data.get(\"isDev\", False),\n            is_project_bundle=data.get(\"isProject\"),\n            active_dev_user=data.get(\"activeUser\"),\n            addons_dev_info=addons_dev_info,\n        )\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/data_structures.html#common.ayon_common.distribution.data_structures.DependencyItem","title":"<code>DependencyItem</code>  <code>dataclass</code>","text":"<p>Object matching payload from Server about single dependency package</p> Source code in <code>common/ayon_common/distribution/data_structures.py</code> <pre><code>@dataclass\nclass DependencyItem:\n    \"\"\"Object matching payload from Server about single dependency package\"\"\"\n    filename: str\n    platform_name: str\n    checksum: str\n    checksum_algorithm: str\n    sources: list[SourceInfo]\n    unknown_sources: list[dict[str, Any]]\n    source_addons: dict[str, str]\n    python_modules: dict[str, str]\n\n    @classmethod\n    def from_dict(cls, package: dict[str, Any]) -&gt; \"DependencyItem\":\n        filename = package[\"filename\"]\n        src_sources = package.get(\"sources\") or []\n        for source in src_sources:\n            if source.get(\"type\") == \"server\" and not source.get(\"filename\"):\n                source[\"filename\"] = filename\n\n        sources, unknown_sources = prepare_sources(\n            src_sources, f\"Dependency package '{filename}'\")\n\n        return cls(\n            filename=filename,\n            platform_name=package[\"platform\"],\n            sources=sources,\n            unknown_sources=unknown_sources,\n            checksum=package[\"checksum\"],\n            # Backwards compatibility\n            checksum_algorithm=package.get(\"checksumAlgorithm\", \"sha256\"),\n            source_addons=package[\"sourceAddons\"],\n            python_modules=package[\"pythonModules\"]\n        )\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/data_structures.html#common.ayon_common.distribution.data_structures.convert_source","title":"<code>convert_source(source)</code>","text":"<p>Create source object from data information.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Dict[str, any]</code> <p>Information about source.</p> required <p>Returns:</p> Type Description <code>Optional[SourceInfo]</code> <p>Optional[SourceInfo]: Object with source information if type is known.</p> Source code in <code>common/ayon_common/distribution/data_structures.py</code> <pre><code>def convert_source(source: dict[str, Any]) -&gt; Optional[SourceInfo]:\n    \"\"\"Create source object from data information.\n\n    Args:\n        source (Dict[str, any]): Information about source.\n\n    Returns:\n        Optional[SourceInfo]: Object with source information if type is\n            known.\n\n    \"\"\"\n    source_type = source.get(\"type\")\n    if not source_type:\n        return None\n\n    if source_type == UrlType.FILESYSTEM.value:\n        return LocalSourceInfo(\n            type=source_type,\n            path=MultiPlatformValue(**source[\"path\"])\n        )\n\n    if source_type == UrlType.HTTP.value:\n        return WebSourceInfo(\n            type=source_type,\n            url=source[\"url\"],\n            headers=source.get(\"headers\"),\n            filename=source.get(\"filename\")\n        )\n\n    if source_type == UrlType.SERVER.value:\n        return ServerSourceInfo(\n            type=source_type,\n            filename=source.get(\"filename\"),\n            path=source.get(\"path\")\n        )\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/downloaders.html","title":"downloaders","text":""},{"location":"autoapi/common/ayon_common/distribution/downloaders.html#common.ayon_common.distribution.downloaders.AyonServerDownloader","title":"<code>AyonServerDownloader</code>","text":"<p>               Bases: <code>SourceDownloader</code></p> <p>Downloads static resource file from AYON Server.</p> <p>Expects filled env var AYON_SERVER_URL.</p> Source code in <code>common/ayon_common/distribution/downloaders.py</code> <pre><code>class AyonServerDownloader(SourceDownloader):\n    \"\"\"Downloads static resource file from AYON Server.\n\n    Expects filled env var AYON_SERVER_URL.\n    \"\"\"\n\n    CHUNK_SIZE = 8192\n\n    @classmethod\n    def download(cls, source, destination_dir, data, transfer_progress):\n        path = source[\"path\"]\n        filename = source[\"filename\"]\n        if path and not filename:\n            filename = path.split(\"/\")[-1]\n\n        cls.log.debug(f\"Downloading {filename} to {destination_dir}\")\n\n        if path:\n            filepath = os.path.join(destination_dir, filename)\n            return ayon_api.download_file(\n                path,\n                filepath,\n                chunk_size=cls.CHUNK_SIZE,\n                progress=transfer_progress\n            )\n\n        # dst_filepath = os.path.join(destination_dir, filename)\n        if data[\"type\"] == \"dependency_package\":\n            return ayon_api.download_dependency_package(\n                data[\"name\"],\n                destination_dir,\n                filename,\n                chunk_size=cls.CHUNK_SIZE,\n                progress=transfer_progress\n            )\n\n        if data[\"type\"] == \"addon\":\n            return ayon_api.download_addon_private_file(\n                data[\"name\"],\n                data[\"version\"],\n                filename,\n                destination_dir,\n                chunk_size=cls.CHUNK_SIZE,\n                progress=transfer_progress\n            )\n\n        if data[\"type\"] == \"installer\":\n            filepath = os.path.join(destination_dir, filename)\n            ayon_api.download_installer(\n                filename,\n                filepath,\n                chunk_size=cls.CHUNK_SIZE,\n                progress=transfer_progress\n            )\n            return filepath\n\n        raise ValueError(f\"Unknown type to download \\\"{data['type']}\\\"\")\n\n    @classmethod\n    def cleanup(cls, source, destination_dir, data):\n        filename = source[\"filename\"]\n        filepath = os.path.join(destination_dir, filename)\n        if os.path.exists(filepath) and os.path.isfile(filepath):\n            os.remove(filepath)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/downloaders.html#common.ayon_common.distribution.downloaders.DownloadFactory","title":"<code>DownloadFactory</code>","text":"<p>Factory for downloaders.</p> Source code in <code>common/ayon_common/distribution/downloaders.py</code> <pre><code>class DownloadFactory:\n    \"\"\"Factory for downloaders.\"\"\"\n\n    def __init__(self):\n        self._downloaders = {}\n\n    def register_format(self, downloader_type, downloader):\n        \"\"\"Register downloader for download type.\n\n        Args:\n            downloader_type (UrlType): Type of source.\n            downloader (SourceDownloader): Downloader which cares about\n                download, hash check and unzipping.\n        \"\"\"\n\n        self._downloaders[downloader_type.value] = downloader\n\n    def get_downloader(self, downloader_type):\n        \"\"\"Registered downloader for type.\n\n        Args:\n            downloader_type (UrlType): Type of source.\n\n        Returns:\n            SourceDownloader: Downloader object which should care about file\n                distribution.\n\n        Raises:\n            ValueError: If type does not have registered downloader.\n        \"\"\"\n\n        if downloader := self._downloaders.get(downloader_type):\n            return downloader()\n        raise ValueError(f\"{downloader_type} not implemented\")\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/downloaders.html#common.ayon_common.distribution.downloaders.DownloadFactory.get_downloader","title":"<code>get_downloader(downloader_type)</code>","text":"<p>Registered downloader for type.</p> <p>Parameters:</p> Name Type Description Default <code>downloader_type</code> <code>UrlType</code> <p>Type of source.</p> required <p>Returns:</p> Name Type Description <code>SourceDownloader</code> <p>Downloader object which should care about file distribution.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If type does not have registered downloader.</p> Source code in <code>common/ayon_common/distribution/downloaders.py</code> <pre><code>def get_downloader(self, downloader_type):\n    \"\"\"Registered downloader for type.\n\n    Args:\n        downloader_type (UrlType): Type of source.\n\n    Returns:\n        SourceDownloader: Downloader object which should care about file\n            distribution.\n\n    Raises:\n        ValueError: If type does not have registered downloader.\n    \"\"\"\n\n    if downloader := self._downloaders.get(downloader_type):\n        return downloader()\n    raise ValueError(f\"{downloader_type} not implemented\")\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/downloaders.html#common.ayon_common.distribution.downloaders.DownloadFactory.register_format","title":"<code>register_format(downloader_type, downloader)</code>","text":"<p>Register downloader for download type.</p> <p>Parameters:</p> Name Type Description Default <code>downloader_type</code> <code>UrlType</code> <p>Type of source.</p> required <code>downloader</code> <code>SourceDownloader</code> <p>Downloader which cares about download, hash check and unzipping.</p> required Source code in <code>common/ayon_common/distribution/downloaders.py</code> <pre><code>def register_format(self, downloader_type, downloader):\n    \"\"\"Register downloader for download type.\n\n    Args:\n        downloader_type (UrlType): Type of source.\n        downloader (SourceDownloader): Downloader which cares about\n            download, hash check and unzipping.\n    \"\"\"\n\n    self._downloaders[downloader_type.value] = downloader\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/downloaders.html#common.ayon_common.distribution.downloaders.HTTPDownloader","title":"<code>HTTPDownloader</code>","text":"<p>               Bases: <code>SourceDownloader</code></p> <p>Downloader using http or https protocol.</p> Source code in <code>common/ayon_common/distribution/downloaders.py</code> <pre><code>class HTTPDownloader(SourceDownloader):\n    \"\"\"Downloader using http or https protocol.\"\"\"\n\n    CHUNK_SIZE = 100000\n\n    @staticmethod\n    def get_filename(source):\n        source_url = source[\"url\"]\n        filename = source.get(\"filename\")\n        if not filename:\n            filename = os.path.basename(source_url)\n        return filename\n\n    @classmethod\n    def download(cls, source, destination_dir, data, transfer_progress):\n        source_url = source[\"url\"]\n        cls.log.debug(f\"Downloading {source_url} to {destination_dir}\")\n        headers = source.get(\"headers\")\n        filename = cls.get_filename(source)\n\n        # TODO use transfer progress\n        RemoteFileHandler.download_url(\n            source_url,\n            destination_dir,\n            filename,\n            headers=headers\n        )\n\n        return os.path.join(destination_dir, filename)\n\n    @classmethod\n    def cleanup(cls, source, destination_dir, data):\n        filename = cls.get_filename(source)\n        filepath = os.path.join(destination_dir, filename)\n        if os.path.exists(filepath) and os.path.isfile(filepath):\n            os.remove(filepath)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/downloaders.html#common.ayon_common.distribution.downloaders.OSDownloader","title":"<code>OSDownloader</code>","text":"<p>               Bases: <code>SourceDownloader</code></p> <p>Downloader using files from file drive.</p> Source code in <code>common/ayon_common/distribution/downloaders.py</code> <pre><code>class OSDownloader(SourceDownloader):\n    \"\"\"Downloader using files from file drive.\"\"\"\n\n    @classmethod\n    def download(cls, source, destination_dir, data, transfer_progress):\n        # OS doesn't need to download, unzip directly\n        addon_url = source[\"path\"].get(platform.system().lower())\n        if not os.path.exists(addon_url):\n            raise ValueError(f\"{addon_url} is not accessible\")\n        return addon_url\n\n    @classmethod\n    def cleanup(cls, source, destination_dir, data):\n        # Nothing to do - download does not copy anything\n        pass\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/downloaders.html#common.ayon_common.distribution.downloaders.SourceDownloader","title":"<code>SourceDownloader</code>","text":"<p>Abstract class for source downloader.</p> Source code in <code>common/ayon_common/distribution/downloaders.py</code> <pre><code>class SourceDownloader(metaclass=ABCMeta):\n    \"\"\"Abstract class for source downloader.\"\"\"\n\n    log = logging.getLogger(__name__)\n\n    @classmethod\n    @abstractmethod\n    def download(\n        cls,\n        source: dict[str, Any],\n        destination_dir: str,\n        data: dict[str, Any],\n        transfer_progress: ayon_api.TransferProgress,\n    ):\n        \"\"\"Returns url of downloaded addon zip file.\n\n        Tranfer progress can be ignored, in that case file transfer won't\n        be shown as 0-100% but as 'running'. First step should be to set\n        destination content size and then add transferred chunk sizes.\n\n        Args:\n            source (dict): {type:\"http\", \"url\":\"https://} ...}\n            destination_dir (str): local folder to unzip\n            data (dict): More information about download content. Always have\n                'type' key in.\n            transfer_progress (ayon_api.TransferProgress): Progress of\n                transferred (copy/download) content.\n\n        Returns:\n            (str) local path to addon zip file\n        \"\"\"\n\n        pass\n\n    @classmethod\n    @abstractmethod\n    def cleanup(\n        cls,\n        source: dict[str, Any],\n        destination_dir: str,\n        data: dict[str, Any]\n    ):\n        \"\"\"Cleanup files when distribution finishes or crashes.\n\n        Cleanup e.g. temporary files (downloaded zip) or other related stuff\n        to downloader.\n        \"\"\"\n\n        pass\n\n    @classmethod\n    def check_hash(\n        cls,\n        filepath: str,\n        checksum: str,\n        checksum_algorithm: str=\"sha256\",\n    ):\n        \"\"\"Compares 'hash' of downloaded 'addon_url' file.\n\n        Args:\n            filepath (str): Local path to addon file.\n            checksum (str): Hash of downloaded file.\n            checksum_algorithm (str): Type of hash.\n\n        Raises:\n            ValueError if hashes doesn't match\n        \"\"\"\n\n        if not validate_file_checksum(filepath, checksum, checksum_algorithm):\n            raise ValueError(f\"{filepath} doesn't match expected hash.\")\n\n    @classmethod\n    def unzip(cls, filepath: str, destination_dir: str):\n        \"\"\"Unzips local 'addon_zip_path' to 'destination'.\n\n        Args:\n            filepath (str): local path to addon zip file\n            destination_dir (str): local folder to unzip\n        \"\"\"\n\n        extract_archive_file(filepath, destination_dir)\n        os.remove(filepath)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/downloaders.html#common.ayon_common.distribution.downloaders.SourceDownloader.check_hash","title":"<code>check_hash(filepath, checksum, checksum_algorithm='sha256')</code>  <code>classmethod</code>","text":"<p>Compares 'hash' of downloaded 'addon_url' file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Local path to addon file.</p> required <code>checksum</code> <code>str</code> <p>Hash of downloaded file.</p> required <code>checksum_algorithm</code> <code>str</code> <p>Type of hash.</p> <code>'sha256'</code> Source code in <code>common/ayon_common/distribution/downloaders.py</code> <pre><code>@classmethod\ndef check_hash(\n    cls,\n    filepath: str,\n    checksum: str,\n    checksum_algorithm: str=\"sha256\",\n):\n    \"\"\"Compares 'hash' of downloaded 'addon_url' file.\n\n    Args:\n        filepath (str): Local path to addon file.\n        checksum (str): Hash of downloaded file.\n        checksum_algorithm (str): Type of hash.\n\n    Raises:\n        ValueError if hashes doesn't match\n    \"\"\"\n\n    if not validate_file_checksum(filepath, checksum, checksum_algorithm):\n        raise ValueError(f\"{filepath} doesn't match expected hash.\")\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/downloaders.html#common.ayon_common.distribution.downloaders.SourceDownloader.cleanup","title":"<code>cleanup(source, destination_dir, data)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Cleanup files when distribution finishes or crashes.</p> <p>Cleanup e.g. temporary files (downloaded zip) or other related stuff to downloader.</p> Source code in <code>common/ayon_common/distribution/downloaders.py</code> <pre><code>@classmethod\n@abstractmethod\ndef cleanup(\n    cls,\n    source: dict[str, Any],\n    destination_dir: str,\n    data: dict[str, Any]\n):\n    \"\"\"Cleanup files when distribution finishes or crashes.\n\n    Cleanup e.g. temporary files (downloaded zip) or other related stuff\n    to downloader.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/downloaders.html#common.ayon_common.distribution.downloaders.SourceDownloader.download","title":"<code>download(source, destination_dir, data, transfer_progress)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Returns url of downloaded addon zip file.</p> <p>Tranfer progress can be ignored, in that case file transfer won't be shown as 0-100% but as 'running'. First step should be to set destination content size and then add transferred chunk sizes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>dict</code> <p>{type:\"http\", \"url\":\"https://} ...}</p> required <code>destination_dir</code> <code>str</code> <p>local folder to unzip</p> required <code>data</code> <code>dict</code> <p>More information about download content. Always have 'type' key in.</p> required <code>transfer_progress</code> <code>TransferProgress</code> <p>Progress of transferred (copy/download) content.</p> required <p>Returns:</p> Type Description <p>(str) local path to addon zip file</p> Source code in <code>common/ayon_common/distribution/downloaders.py</code> <pre><code>@classmethod\n@abstractmethod\ndef download(\n    cls,\n    source: dict[str, Any],\n    destination_dir: str,\n    data: dict[str, Any],\n    transfer_progress: ayon_api.TransferProgress,\n):\n    \"\"\"Returns url of downloaded addon zip file.\n\n    Tranfer progress can be ignored, in that case file transfer won't\n    be shown as 0-100% but as 'running'. First step should be to set\n    destination content size and then add transferred chunk sizes.\n\n    Args:\n        source (dict): {type:\"http\", \"url\":\"https://} ...}\n        destination_dir (str): local folder to unzip\n        data (dict): More information about download content. Always have\n            'type' key in.\n        transfer_progress (ayon_api.TransferProgress): Progress of\n            transferred (copy/download) content.\n\n    Returns:\n        (str) local path to addon zip file\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/downloaders.html#common.ayon_common.distribution.downloaders.SourceDownloader.unzip","title":"<code>unzip(filepath, destination_dir)</code>  <code>classmethod</code>","text":"<p>Unzips local 'addon_zip_path' to 'destination'.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>local path to addon zip file</p> required <code>destination_dir</code> <code>str</code> <p>local folder to unzip</p> required Source code in <code>common/ayon_common/distribution/downloaders.py</code> <pre><code>@classmethod\ndef unzip(cls, filepath: str, destination_dir: str):\n    \"\"\"Unzips local 'addon_zip_path' to 'destination'.\n\n    Args:\n        filepath (str): local path to addon zip file\n        destination_dir (str): local folder to unzip\n    \"\"\"\n\n    extract_archive_file(filepath, destination_dir)\n    os.remove(filepath)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/exceptions.html","title":"exceptions","text":""},{"location":"autoapi/common/ayon_common/distribution/exceptions.html#common.ayon_common.distribution.exceptions.BundleNotFoundError","title":"<code>BundleNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Bundle name is defined but is not available on server.</p> <p>Parameters:</p> Name Type Description Default <code>bundle_name</code> <code>str</code> <p>Name of bundle that was not found.</p> required Source code in <code>common/ayon_common/distribution/exceptions.py</code> <pre><code>class BundleNotFoundError(Exception):\n    \"\"\"Bundle name is defined but is not available on server.\n\n    Args:\n        bundle_name (str): Name of bundle that was not found.\n    \"\"\"\n\n    def __init__(self, bundle_name):\n        self.bundle_name = bundle_name\n        super().__init__(\n            f\"Bundle '{bundle_name}' is not available on server\"\n        )\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/file_handler.html","title":"file_handler","text":""},{"location":"autoapi/common/ayon_common/distribution/file_handler.html#common.ayon_common.distribution.file_handler.RemoteFileHandler","title":"<code>RemoteFileHandler</code>","text":"<p>Download file from url, might be GDrive shareable link</p> Source code in <code>common/ayon_common/distribution/file_handler.py</code> <pre><code>class RemoteFileHandler:\n    \"\"\"Download file from url, might be GDrive shareable link\"\"\"\n\n    @staticmethod\n    def download_url(\n        url: str,\n        root: str,\n        filename: Optional[str] = None,\n        max_redirect_hops: int = 3,\n        headers: Optional[dict[str, str]] = None,\n    ):\n        \"\"\"Download a file from url and place it in root.\n\n        Args:\n            url (str): URL to download file from\n            root (str): Directory to place downloaded file in\n            filename (str, optional): Name to save the file under.\n                If None, use the basename of the URL\n            max_redirect_hops (Optional[int]): Maximum number of redirect\n                hops allowed\n            headers (Optional[dict[str, str]]): Additional required headers\n                - Authentication etc..\n\n        \"\"\"\n        root = os.path.expanduser(root)\n        if not filename:\n            filename = os.path.basename(url)\n        fpath = os.path.join(root, filename)\n\n        if not os.path.exists(root):\n            os.makedirs(root, exist_ok=True)\n\n        # expand redirect chain if needed\n        url = RemoteFileHandler._get_redirect_url(\n            url, max_hops=max_redirect_hops, headers=headers)\n\n        # check if file is located on Google Drive\n        file_id = RemoteFileHandler._get_google_drive_file_id(url)\n        if file_id is not None:\n            return RemoteFileHandler.download_file_from_google_drive(\n                file_id, root, filename)\n\n        # download the file\n        try:\n            print(f\"Downloading {url} to {fpath}\")\n            RemoteFileHandler._urlretrieve(url, fpath, headers=headers)\n        except (urllib.error.URLError, IOError) as exc:\n            if url[:5] != \"https\":\n                raise exc\n\n            url = url.replace(\"https:\", \"http:\")\n            print((\n                \"Failed download. Trying https -&gt; http instead.\"\n                f\" Downloading {url} to {fpath}\"\n            ))\n            RemoteFileHandler._urlretrieve(url, fpath, headers=headers)\n\n    @staticmethod\n    def download_file_from_google_drive(\n        file_id: str,\n        root: str,\n        filename: Optional[str] = None,\n    ):\n        \"\"\"Download a Google Drive file from  and place it in root.\n        Args:\n            file_id (str): id of file to be downloaded\n            root (str): Directory to place downloaded file in\n            filename (Optional[str]): Name to save the file under.\n                If None, use the id of the file.\n\n        \"\"\"\n        # Based on https://stackoverflow.com/questions/38511444/python-download-files-from-google-drive-using-url # noqa\n\n        url = \"https://docs.google.com/uc?export=download\"\n\n        root = os.path.expanduser(root)\n        if not filename:\n            filename = file_id\n        fpath = os.path.join(root, filename)\n\n        if not os.path.exists(root):\n            os.makedirs(root, exist_ok=True)\n\n        # TODO validate checksum of existing file and download\n        #   only if incomplete.\n        if os.path.isfile(fpath):\n            os.remove(fpath)\n\n        session = requests.Session()\n\n        response = session.get(url, params={\"id\": file_id}, stream=True)\n        token = RemoteFileHandler._get_confirm_token(response)\n\n        if token:\n            params = {\"id\": file_id, \"confirm\": token}\n            response = session.get(url, params=params, stream=True)\n\n        response_content_generator = response.iter_content(32768)\n        first_chunk = None\n        while not first_chunk:  # filter out keep-alive new chunks\n            first_chunk = next(response_content_generator)\n\n        if RemoteFileHandler._quota_exceeded(first_chunk):\n            msg = (\n                f\"The daily quota of the file {filename} is exceeded and \"\n                f\"it can't be downloaded. This is a limitation of \"\n                f\"Google Drive and can only be overcome by trying \"\n                f\"again later.\"\n            )\n            raise RuntimeError(msg)\n\n        RemoteFileHandler._save_response_content(\n            itertools.chain(\n                (first_chunk, ), response_content_generator\n            ),\n            fpath\n        )\n        response.close()\n\n    @staticmethod\n    def _urlretrieve(url, filename, chunk_size=None, headers=None):\n        final_headers = {\"User-Agent\": USER_AGENT}\n        if headers:\n            final_headers.update(headers)\n\n        chunk_size = chunk_size or 8192\n        with open(filename, \"wb\") as fh:\n            with urllib.request.urlopen(\n                urllib.request.Request(url, headers=final_headers)\n            ) as response:\n                for chunk in iter(lambda: response.read(chunk_size), \"\"):\n                    if not chunk:\n                        break\n                    fh.write(chunk)\n\n    @staticmethod\n    def _get_redirect_url(url, max_hops, headers=None):\n        initial_url = url\n        final_headers = {\"Method\": \"HEAD\", \"User-Agent\": USER_AGENT}\n        if headers:\n            final_headers.update(headers)\n        for _ in range(max_hops + 1):\n            with urllib.request.urlopen(\n                urllib.request.Request(url, headers=final_headers)\n            ) as response:\n                if response.url == url or response.url is None:\n                    return url\n\n                return response.url\n        else:\n            raise RecursionError(\n                f\"Request to {initial_url} exceeded {max_hops} redirects. \"\n                f\"The last redirect points to {url}.\"\n            )\n\n    @staticmethod\n    def _get_confirm_token(response):\n        for key, value in response.cookies.items():\n            if key.startswith(\"download_warning\"):\n                return value\n\n        # handle antivirus warning for big zips\n        found = re.search(\"(confirm=)([^&amp;.+])\", response.text)\n        if found:\n            return found.groups()[1]\n\n        return None\n\n    @staticmethod\n    def _save_response_content(\n        response_gen, destination,\n    ):\n        with open(destination, \"wb\") as f:\n            for chunk in response_gen:\n                if chunk:  # filter out keep-alive new chunks\n                    f.write(chunk)\n\n    @staticmethod\n    def _quota_exceeded(first_chunk):\n        try:\n            return \"Google Drive - Quota exceeded\" in first_chunk.decode()\n        except UnicodeDecodeError:\n            return False\n\n    @staticmethod\n    def _get_google_drive_file_id(url):\n        parts = urlparse(url)\n\n        if re.match(r\"(drive|docs)[.]google[.]com\", parts.netloc) is None:\n            return None\n\n        match = re.match(r\"/file/d/(?P&lt;id&gt;[^/]*)\", parts.path)\n        if match is None:\n            return None\n\n        return match.group(\"id\")\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/file_handler.html#common.ayon_common.distribution.file_handler.RemoteFileHandler.download_file_from_google_drive","title":"<code>download_file_from_google_drive(file_id, root, filename=None)</code>  <code>staticmethod</code>","text":"<p>Download a Google Drive file from  and place it in root. Args:     file_id (str): id of file to be downloaded     root (str): Directory to place downloaded file in     filename (Optional[str]): Name to save the file under.         If None, use the id of the file.</p> Source code in <code>common/ayon_common/distribution/file_handler.py</code> <pre><code>@staticmethod\ndef download_file_from_google_drive(\n    file_id: str,\n    root: str,\n    filename: Optional[str] = None,\n):\n    \"\"\"Download a Google Drive file from  and place it in root.\n    Args:\n        file_id (str): id of file to be downloaded\n        root (str): Directory to place downloaded file in\n        filename (Optional[str]): Name to save the file under.\n            If None, use the id of the file.\n\n    \"\"\"\n    # Based on https://stackoverflow.com/questions/38511444/python-download-files-from-google-drive-using-url # noqa\n\n    url = \"https://docs.google.com/uc?export=download\"\n\n    root = os.path.expanduser(root)\n    if not filename:\n        filename = file_id\n    fpath = os.path.join(root, filename)\n\n    if not os.path.exists(root):\n        os.makedirs(root, exist_ok=True)\n\n    # TODO validate checksum of existing file and download\n    #   only if incomplete.\n    if os.path.isfile(fpath):\n        os.remove(fpath)\n\n    session = requests.Session()\n\n    response = session.get(url, params={\"id\": file_id}, stream=True)\n    token = RemoteFileHandler._get_confirm_token(response)\n\n    if token:\n        params = {\"id\": file_id, \"confirm\": token}\n        response = session.get(url, params=params, stream=True)\n\n    response_content_generator = response.iter_content(32768)\n    first_chunk = None\n    while not first_chunk:  # filter out keep-alive new chunks\n        first_chunk = next(response_content_generator)\n\n    if RemoteFileHandler._quota_exceeded(first_chunk):\n        msg = (\n            f\"The daily quota of the file {filename} is exceeded and \"\n            f\"it can't be downloaded. This is a limitation of \"\n            f\"Google Drive and can only be overcome by trying \"\n            f\"again later.\"\n        )\n        raise RuntimeError(msg)\n\n    RemoteFileHandler._save_response_content(\n        itertools.chain(\n            (first_chunk, ), response_content_generator\n        ),\n        fpath\n    )\n    response.close()\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/file_handler.html#common.ayon_common.distribution.file_handler.RemoteFileHandler.download_url","title":"<code>download_url(url, root, filename=None, max_redirect_hops=3, headers=None)</code>  <code>staticmethod</code>","text":"<p>Download a file from url and place it in root.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to download file from</p> required <code>root</code> <code>str</code> <p>Directory to place downloaded file in</p> required <code>filename</code> <code>str</code> <p>Name to save the file under. If None, use the basename of the URL</p> <code>None</code> <code>max_redirect_hops</code> <code>Optional[int]</code> <p>Maximum number of redirect hops allowed</p> <code>3</code> <code>headers</code> <code>Optional[dict[str, str]]</code> <p>Additional required headers - Authentication etc..</p> <code>None</code> Source code in <code>common/ayon_common/distribution/file_handler.py</code> <pre><code>@staticmethod\ndef download_url(\n    url: str,\n    root: str,\n    filename: Optional[str] = None,\n    max_redirect_hops: int = 3,\n    headers: Optional[dict[str, str]] = None,\n):\n    \"\"\"Download a file from url and place it in root.\n\n    Args:\n        url (str): URL to download file from\n        root (str): Directory to place downloaded file in\n        filename (str, optional): Name to save the file under.\n            If None, use the basename of the URL\n        max_redirect_hops (Optional[int]): Maximum number of redirect\n            hops allowed\n        headers (Optional[dict[str, str]]): Additional required headers\n            - Authentication etc..\n\n    \"\"\"\n    root = os.path.expanduser(root)\n    if not filename:\n        filename = os.path.basename(url)\n    fpath = os.path.join(root, filename)\n\n    if not os.path.exists(root):\n        os.makedirs(root, exist_ok=True)\n\n    # expand redirect chain if needed\n    url = RemoteFileHandler._get_redirect_url(\n        url, max_hops=max_redirect_hops, headers=headers)\n\n    # check if file is located on Google Drive\n    file_id = RemoteFileHandler._get_google_drive_file_id(url)\n    if file_id is not None:\n        return RemoteFileHandler.download_file_from_google_drive(\n            file_id, root, filename)\n\n    # download the file\n    try:\n        print(f\"Downloading {url} to {fpath}\")\n        RemoteFileHandler._urlretrieve(url, fpath, headers=headers)\n    except (urllib.error.URLError, IOError) as exc:\n        if url[:5] != \"https\":\n            raise exc\n\n        url = url.replace(\"https:\", \"http:\")\n        print((\n            \"Failed download. Trying https -&gt; http instead.\"\n            f\" Downloading {url} to {fpath}\"\n        ))\n        RemoteFileHandler._urlretrieve(url, fpath, headers=headers)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/utils.html","title":"utils","text":""},{"location":"autoapi/common/ayon_common/distribution/utils.html#common.ayon_common.distribution.utils.get_addons_dir","title":"<code>get_addons_dir()</code>","text":"<p>Directory where addon packages are stored.</p> <p>Path to addons is defined using python module 'appdirs' which</p> <p>The path is stored into environment variable 'AYON_ADDONS_DIR'. Value of environment variable can be overriden, but we highly recommended to use that option only for development purposes.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Path to directory where addons should be downloaded.</p> Source code in <code>common/ayon_common/distribution/utils.py</code> <pre><code>def get_addons_dir():\n    \"\"\"Directory where addon packages are stored.\n\n    Path to addons is defined using python module 'appdirs' which\n\n    The path is stored into environment variable 'AYON_ADDONS_DIR'.\n    Value of environment variable can be overriden, but we highly recommended\n    to use that option only for development purposes.\n\n    Returns:\n        str: Path to directory where addons should be downloaded.\n    \"\"\"\n\n    addons_dir = os.environ.get(\"AYON_ADDONS_DIR\")\n    if not addons_dir:\n        addons_dir = get_launcher_storage_dir(\n            \"addons\", create=True\n        )\n        os.environ[\"AYON_ADDONS_DIR\"] = addons_dir\n    return addons_dir\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/utils.html#common.ayon_common.distribution.utils.get_dependencies_dir","title":"<code>get_dependencies_dir()</code>","text":"<p>Directory where dependency packages are stored.</p> <p>Path to addons is defined using python module 'appdirs' which</p> <p>The path is stored into environment variable 'AYON_DEPENDENCIES_DIR'. Value of environment variable can be overriden, but we highly recommended to use that option only for development purposes.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Path to directory where dependency packages should be downloaded.</p> Source code in <code>common/ayon_common/distribution/utils.py</code> <pre><code>def get_dependencies_dir():\n    \"\"\"Directory where dependency packages are stored.\n\n    Path to addons is defined using python module 'appdirs' which\n\n    The path is stored into environment variable 'AYON_DEPENDENCIES_DIR'.\n    Value of environment variable can be overriden, but we highly recommended\n    to use that option only for development purposes.\n\n    Returns:\n        str: Path to directory where dependency packages should be downloaded.\n    \"\"\"\n\n    dependencies_dir = os.environ.get(\"AYON_DEPENDENCIES_DIR\")\n    if not dependencies_dir:\n        dependencies_dir = get_launcher_storage_dir(\n            \"dependency_packages\", create=True\n        )\n        os.environ[\"AYON_DEPENDENCIES_DIR\"] = dependencies_dir\n    return dependencies_dir\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/utils.html#common.ayon_common.distribution.utils.show_installer_issue_information","title":"<code>show_installer_issue_information(message, installer_path=None)</code>","text":"<p>Show a message that something went wrong during installer distribution.</p> <p>This will trigger a subprocess with UI message dialog.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message with description of an issue.</p> required <code>installer_path</code> <code>Optional[str]</code> <p>Path to installer file so user can try to install it manually.</p> <code>None</code> Source code in <code>common/ayon_common/distribution/utils.py</code> <pre><code>def show_installer_issue_information(message, installer_path=None):\n    \"\"\"Show a message that something went wrong during installer distribution.\n\n    This will trigger a subprocess with UI message dialog.\n\n    Args:\n        message (str): Error message with description of an issue.\n        installer_path (Optional[str]): Path to installer file so user can\n            try to install it manually.\n\n    \"\"\"\n    sub_message = None\n    if installer_path and os.path.exists(installer_path):\n        sub_message = (\n            \"NOTE: Install file can be found here:\"\n            f\"&lt;br/&gt;&lt;b&gt;{installer_path}&lt;/b&gt;\"\n        )\n    _show_message_dialog(\n        \"AYON-launcher distribution\",\n        message,\n        sub_message,\n    )\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/utils.html#common.ayon_common.distribution.utils.show_missing_bundle_information","title":"<code>show_missing_bundle_information(url, bundle_name, username, is_project_bundle)</code>","text":"<p>Show missing bundle information window.</p> <p>This function should be called when server does not have set bundle for production or staging, or when bundle that should be used is not available on server.</p> <p>Using subprocess to show the dialog. Is blocking and is waiting until dialog is closed.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Server url where bundle is not set.</p> required <code>bundle_name</code> <code>Optional[str]</code> <p>Name of bundle that was not found. Or 'None' if is missing bundle.</p> required <code>username</code> <code>Optional[str]</code> <p>Username. Is used only when dev mode is enabled.</p> required <code>is_project_bundle</code> <code>bool</code> <p>Missing bundle is project bundle.</p> required Source code in <code>common/ayon_common/distribution/utils.py</code> <pre><code>def show_missing_bundle_information(\n    url: str,\n    bundle_name: Optional[str],\n    username: Optional[str],\n    is_project_bundle: bool,\n) -&gt; None:\n    \"\"\"Show missing bundle information window.\n\n    This function should be called when server does not have set bundle for\n    production or staging, or when bundle that should be used is not available\n    on server.\n\n    Using subprocess to show the dialog. Is blocking and is waiting until\n    dialog is closed.\n\n    Args:\n        url (str): Server url where bundle is not set.\n        bundle_name (Optional[str]): Name of bundle that was not found. Or\n            'None' if is missing bundle.\n        username (Optional[str]): Username. Is used only when dev mode is\n            enabled.\n        is_project_bundle (bool): Missing bundle is project bundle.\n\n    \"\"\"\n    ui_dir = os.path.join(os.path.dirname(__file__), \"ui\")\n    script_path = os.path.join(ui_dir, \"missing_bundle_window.py\")\n    args = get_ayon_launch_args(\n        script_path,\n        \"--skip-bootstrap\",\n        \"--url\", url,\n    )\n    if bundle_name:\n        args.extend([\"--missing-bundle\", bundle_name])\n\n    if username:\n        args.extend([\"--user\", username])\n\n    if is_project_bundle:\n        args.append(\"--is-project\")\n    subprocess.call(args)\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/ui/index.html","title":"ui","text":""},{"location":"autoapi/common/ayon_common/distribution/ui/distribution_error.html","title":"distribution_error","text":""},{"location":"autoapi/common/ayon_common/distribution/ui/distribution_error.html#common.ayon_common.distribution.ui.distribution_error.main","title":"<code>main()</code>","text":"<p>Show message that server does not have set bundle to use.</p> <p>It is possible to pass url as argument to show it in the message. To use     this feature, pass <code>--url &lt;url&gt;</code> as argument to this script.</p> Source code in <code>common/ayon_common/distribution/ui/distribution_error.py</code> <pre><code>def main():\n    \"\"\"Show message that server does not have set bundle to use.\n\n    It is possible to pass url as argument to show it in the message. To use\n        this feature, pass `--url &lt;url&gt;` as argument to this script.\n    \"\"\"\n\n    filepath = sys.argv[-1]\n    with open(filepath, \"r\") as stream:\n        data = json.load(stream)\n\n    app = get_qt_app()\n    window = MessageWindow(\n        data[\"title\"],\n        data[\"message\"],\n        data[\"sub_message\"],\n    )\n    window.show()\n    app.exec_()\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/ui/missing_bundle_window.html","title":"missing_bundle_window","text":""},{"location":"autoapi/common/ayon_common/distribution/ui/missing_bundle_window.html#common.ayon_common.distribution.ui.missing_bundle_window.main","title":"<code>main()</code>","text":"<p>Show message that server does not have set bundle to use.</p> <p>It is possible to pass url as argument to show it in the message. To use     this feature, pass <code>--url &lt;url&gt;</code> as argument to this script.</p> <p>The function expects that 'is_dev_mode_enabled' will return value     for the bundle name passed in.</p> Source code in <code>common/ayon_common/distribution/ui/missing_bundle_window.py</code> <pre><code>def main():\n    \"\"\"Show message that server does not have set bundle to use.\n\n    It is possible to pass url as argument to show it in the message. To use\n        this feature, pass `--url &lt;url&gt;` as argument to this script.\n\n    The function expects that 'is_dev_mode_enabled' will return value\n        for the bundle name passed in.\n    \"\"\"\n    url = None\n    bundle_name = None\n    username = None\n    if \"--url\" in sys.argv:\n        url_index = sys.argv.index(\"--url\") + 1\n        if url_index &lt; len(sys.argv):\n            url = sys.argv[url_index]\n\n    if \"--missing-bundle\" in sys.argv:\n        bundle_index = sys.argv.index(\"--missing-bundle\") + 1\n        if bundle_index &lt; len(sys.argv):\n            bundle_name = sys.argv[bundle_index]\n\n    if \"--user\" in sys.argv:\n        user_index = sys.argv.index(\"--user\") + 1\n        if user_index &lt; len(sys.argv):\n            username = sys.argv[user_index]\n\n    is_project_bundle = \"--is-project\" in sys.argv\n\n    use_staging = is_staging_enabled()\n    use_dev = is_dev_mode_enabled()\n    app = get_qt_app()\n    window = MissingBundleWindow(\n        url, bundle_name, username, is_project_bundle, use_staging, use_dev\n    )\n    window.show()\n    app.exec_()\n</code></pre>"},{"location":"autoapi/common/ayon_common/distribution/ui/update_window.html","title":"update_window","text":""},{"location":"autoapi/common/ayon_common/resources/index.html","title":"resources","text":""},{"location":"autoapi/common/ayon_common/startup/index.html","title":"startup","text":"<p>Helpers for startup script.</p>"},{"location":"autoapi/common/ayon_common/startup/index.html#common.ayon_common.startup.show_startup_error","title":"<code>show_startup_error(title, message, detail=None)</code>","text":"<p>Show startup error message.</p> <p>This will trigger a subprocess with UI message dialog.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Message title.</p> required <code>message</code> <code>str</code> <p>Message content.</p> required Source code in <code>common/ayon_common/startup/__init__.py</code> <pre><code>def show_startup_error(title, message, detail=None):\n    \"\"\"Show startup error message.\n\n    This will trigger a subprocess with UI message dialog.\n\n    Args:\n        title (str): Message title.\n        message (str): Message content.\n    \"\"\"\n\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    ui_dir = os.path.join(current_dir, \"ui\")\n    script_path = os.path.join(ui_dir, \"startup_error.py\")\n    with tempfile.NamedTemporaryFile(\n        suffix=\".json\", delete=False\n    ) as tmp:\n        filepath = tmp.name\n\n    with open(filepath, \"w\") as stream:\n        json.dump(\n            {\n                \"title\": title,\n                \"message\": message,\n                \"detail\": detail,\n            },\n            stream\n        )\n\n    args = get_ayon_launch_args(\n        script_path, \"--skip-bootstrap\", filepath\n    )\n    try:\n        subprocess.call(args)\n    finally:\n        os.remove(filepath)\n</code></pre>"},{"location":"autoapi/common/ayon_common/startup/ui/index.html","title":"ui","text":""},{"location":"autoapi/common/ayon_common/startup/ui/startup_error.html","title":"startup_error","text":""},{"location":"autoapi/common/ayon_common/startup/ui/startup_error.html#common.ayon_common.startup.ui.startup_error.main","title":"<code>main()</code>","text":"<p>Show message that server does not have set bundle to use.</p> <p>It is possible to pass url as argument to show it in the message. To use     this feature, pass <code>--url &lt;url&gt;</code> as argument to this script.</p> Source code in <code>common/ayon_common/startup/ui/startup_error.py</code> <pre><code>def main():\n    \"\"\"Show message that server does not have set bundle to use.\n\n    It is possible to pass url as argument to show it in the message. To use\n        this feature, pass `--url &lt;url&gt;` as argument to this script.\n    \"\"\"\n\n    filepath = sys.argv[-1]\n    with open(filepath, \"r\") as stream:\n        data = json.load(stream)\n\n    app = get_qt_app()\n    window = MessageWindow(data[\"title\"], data[\"message\"], data[\"detail\"])\n    window.show()\n    app.exec_()\n</code></pre>"},{"location":"autoapi/shim/macos_start.html","title":"macos_start","text":""},{"location":"autoapi/shim/setup.html","title":"setup","text":"<p>Setup info for building AYON Desktop application.</p>"},{"location":"autoapi/shim/shim_start.html","title":"shim_start","text":""},{"location":"autoapi/shim/shim_start.html#shim.shim_start.get_ayon_appdirs","title":"<code>get_ayon_appdirs(*args)</code>","text":"<p>Local app data directory of AYON launcher.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Iterable[str]</code> <p>Subdirectories/files in local app data dir.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>str</code> <p>Path to directory/file in local app data dir.</p> Source code in <code>shim/shim_start.py</code> <pre><code>def get_ayon_appdirs(*args):\n    \"\"\"Local app data directory of AYON launcher.\n\n    Args:\n        *args (Iterable[str]): Subdirectories/files in local app data dir.\n\n    Returns:\n        str: Path to directory/file in local app data dir.\n    \"\"\"\n\n    return os.path.join(\n        platformdirs.user_data_dir(\"AYON\", \"Ynput\"),\n        *args\n    )\n</code></pre>"},{"location":"autoapi/shim/shim_start.html#shim.shim_start.get_executables_info_filepath","title":"<code>get_executables_info_filepath()</code>","text":"<p>Get path to file where information about executables is stored.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>Path to json file where executables info are stored.</p> Source code in <code>shim/shim_start.py</code> <pre><code>def get_executables_info_filepath():\n    \"\"\"Get path to file where information about executables is stored.\n\n    Returns:\n        str: Path to json file where executables info are stored.\n    \"\"\"\n\n    return get_launcher_local_dir(\"executables.json\")\n</code></pre>"},{"location":"autoapi/shim/shim_start.html#shim.shim_start.get_launcher_local_dir","title":"<code>get_launcher_local_dir(*subdirs)</code>","text":"<p>Get local directory for launcher.</p> <p>Local directory is used for storing machine or user specific data.</p> <p>The location is user specific.</p> Note <p>This function should be called at least once on bootstrap.</p> <p>Parameters:</p> Name Type Description Default <code>*subdirs</code> <code>str</code> <p>Subdirectories relative to local dir.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to local directory.</p> Source code in <code>shim/shim_start.py</code> <pre><code>def get_launcher_local_dir(*subdirs: str) -&gt; str:\n    \"\"\"Get local directory for launcher.\n\n    Local directory is used for storing machine or user specific data.\n\n    The location is user specific.\n\n    Note:\n        This function should be called at least once on bootstrap.\n\n    Args:\n        *subdirs (str): Subdirectories relative to local dir.\n\n    Returns:\n        str: Path to local directory.\n\n    \"\"\"\n    storage_dir = os.getenv(\"AYON_LAUNCHER_LOCAL_DIR\")\n    if not storage_dir:\n        storage_dir = get_ayon_appdirs()\n        os.environ[\"AYON_LAUNCHER_LOCAL_DIR\"] = storage_dir\n\n    return os.path.join(storage_dir, *subdirs)\n</code></pre>"},{"location":"autoapi/shim/shim_start.html#shim.shim_start.load_executable_version","title":"<code>load_executable_version(executable)</code>","text":"<p>Get version of executable.</p> <p>Parameters:</p> Name Type Description Default <code>executable</code> <code>str</code> <p>Path to executable.</p> required <p>Returns:</p> Type Description <p>Union[str, None]: Version of executable.</p> Source code in <code>shim/shim_start.py</code> <pre><code>def load_executable_version(executable):\n    \"\"\"Get version of executable.\n\n    Args:\n        executable (str): Path to executable.\n\n    Returns:\n        Union[str, None]: Version of executable.\n    \"\"\"\n\n    if not executable:\n        return None\n    return load_version_from_root(os.path.dirname(executable))\n</code></pre>"},{"location":"autoapi/shim/shim_start.html#shim.shim_start.load_version_from_file","title":"<code>load_version_from_file(filepath)</code>","text":"<p>Execute python file and return 'version' variable.</p> Source code in <code>shim/shim_start.py</code> <pre><code>def load_version_from_file(filepath):\n    \"\"\"Execute python file and return '__version__' variable.\"\"\"\n\n    with open(filepath, \"r\") as stream:\n        version_content = stream.read()\n    version_globals = {}\n    exec(version_content, version_globals)\n    return version_globals[\"__version__\"]\n</code></pre>"},{"location":"autoapi/shim/shim_start.html#shim.shim_start.load_version_from_root","title":"<code>load_version_from_root(root)</code>","text":"<p>Get version of executable.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>str</code> <p>Path to executable.</p> required <p>Returns:</p> Type Description <p>Union[str, None]: Version of executable.</p> Source code in <code>shim/shim_start.py</code> <pre><code>def load_version_from_root(root):\n    \"\"\"Get version of executable.\n\n    Args:\n        root (str): Path to executable.\n\n    Returns:\n        Union[str, None]: Version of executable.\n    \"\"\"\n\n    version = None\n    if not root or not os.path.exists(root):\n        return version\n\n    version_filepath = os.path.join(root, \"version.py\")\n    if os.path.exists(version_filepath):\n        try:\n            version = load_version_from_file(version_filepath)\n        except Exception as exc:\n            print(\"Failed lo load version file {}. {}\".format(\n                version_filepath, exc))\n\n    return version\n</code></pre>"},{"location":"build_guides/linux.html","title":"Build AYON launcher on Linux","text":"<p>WARNING: Linux needs distribution specific steps.</p> <p>We highly recommend to use prepared docker build options for Linux. If you want to build AYON on your local machine, the following steps may not be fully working for every case.</p>"},{"location":"build_guides/linux.html#requirements","title":"Requirements","text":"<p>To build AYON you will need some tools and libraries. We do not provide any of these tools. You have to install them yourself. - bash - curl on systems that doesn't have one preinstalled - git - Python 3.9 or higher - CMake</p> <p>Python 3.9.0 is not supported because of this bug.</p> <p>It is recommended to use pyenv for python version control.</p> <p>To build Python related stuff, you need Python header files installed (<code>python3-dev</code> on Ubuntu for example).</p>"},{"location":"build_guides/linux.html#prepare-requirements","title":"Prepare requirements","text":"Details for Ubuntu Install git, cmake and curl   <pre><code>sudo apt install build-essential checkinstall\nsudo apt install git cmake curl\n</code></pre>  #### Note: In case you run in error about `xcb` when running AYON, you'll need also additional libraries for Qt5:   <pre><code>sudo apt install qt6-default\n</code></pre>  or if you are on Ubuntu &gt; 20.04, there is no `qt6-default` packages so you need to install its content individually:   <pre><code>sudo apt-get install qtbase6-dev qtchooser qt6-qmake qtbase6-dev-tools\n</code></pre> Details for Centos 7 Note that centos 7 is old OS and some of the packages are not available so there might be used older versions. For example still uses PySide2 instead of PySide6. Install git, cmake and curl   <pre><code>sudo yum install qit cmake\n</code></pre>   #### Note: In case you run in error about `xcb` when running AYON, you'll need also additional libraries for Qt5:   <pre><code>sudo yum install qt5-qtbase-devel\n</code></pre> Use pyenv to install Python version for AYON build  You will need **bzip2**, **readline**, **sqlite3** and other libraries.  For more details about Python build environments see:  https://github.com/pyenv/pyenv/wiki#suggested-build-environment  **For Ubuntu:**  <pre><code>sudo apt-get update; sudo apt-get install --no-install-recommends make build-essential libssl-dev zlib1g-dev libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev\n</code></pre>   **For Centos:**  <pre><code>yum install gcc zlib-devel bzip2 bzip2-devel readline-devel sqlite sqlite-devel openssl-devel tk-devel libffi-devel\n</code></pre>   **install pyenv**  <pre><code>curl https://pyenv.run | bash\n\n# you can add those to ~/.bashrc\nexport PATH=\"$HOME/.pyenv/bin:$PATH\"\neval \"$(pyenv init -)\"\neval \"$(pyenv virtualenv-init -)\"\n\n# reload shell\nexec $SHELL\n\n# install Python 3.9.x\npyenv install -v 3.9.13\n\n# change path to repository\ncd /path/to/ayon-launcher\n\n# set local python version\npyenv local 3.9.13\n\n</code></pre>"},{"location":"build_guides/linux.html#build","title":"Build","text":""},{"location":"build_guides/linux.html#clone-repository","title":"Clone repository","text":"<pre><code>git clone --recurse-submodules git@github.com:ynput/ayon-launcher.git\n</code></pre>"},{"location":"build_guides/linux.html#prepare-environment","title":"Prepare environment","text":"<p>Create virtual environment in <code>./.venv</code> and install python runtime dependencies like PySide, Pillow..</p> <p>For Centos: Centos does not support default version of PySide6. We've prepared last supported version, all you need to do is to set environment variable <code>QT_BINDING</code> to <code>centos7</code>.</p> <pre><code>./tools/make.sh create-env\n./tools/make.sh install-runtime-dependencies\n</code></pre>"},{"location":"build_guides/linux.html#build-ayon-desktop","title":"Build AYON Desktop","text":"<p>Build AYON in <code>./build/</code>.</p> <pre><code>./tools/make.sh build\n</code></pre> <p>Build should create <code>./build/AYON {version}.app</code> file.</p>"},{"location":"build_guides/linux.html#create-installer","title":"Create installer","text":"<p>Create installer that can be distributed to server and workstations.</p> <pre><code>./tools/make.sh make-installer\n</code></pre> <p>Output installer is in <code>./build/installer/</code> directory. You should find <code>.dmg</code> and <code>.json</code> file. JSON file contains metadata required for server.</p>"},{"location":"build_guides/macos.html","title":"Build AYON launcher on macOS","text":"<p>[!WARNING] macOS is not fully supported. The build process may not work on some machines. We try to upload pre-build installer in each release.</p>"},{"location":"build_guides/macos.html#requirements","title":"Requirements","text":"<p>[!IMPORTANT] If you're on M1 or newer mac, you also have to enable Rosetta virtualization on Terminal application. That has to be done before you start the build process or install dependencies. You might have to reinstall dependencies if you've already had installed them.</p> <p>To build AYON you will need some tools and libraries. We do not provide any of these tools. You have to install them yourself. - Terminal - Homebrew - git - Python 3.9 or higher - CMake - XCode Command Line Tools (or some other build system).</p> <p>Python 3.9.0 is not supported because of this bug.</p> <p>[!TIP] It is recommended to use pyenv for python version control.</p>"},{"location":"build_guides/macos.html#prepare-requirements","title":"Prepare requirements","text":"<p>Easy way of installing everything necessary is to use Homebrew.</p> <p>1) Install Homebrew:    <code>sh    /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"</code></p> <p>2) Install cmake and create-dmg:    <code>sh    brew install cmake create-dmg</code></p> <p>3) Install pyenv:    <code>sh    brew install pyenv    echo 'eval \"$(pyenv init -)\"' &gt;&gt; ~/.zshrc    pyenv init    exec \"$SHELL\"    PATH=$(pyenv root)/shims:$PATH</code></p> <p>4) Pull in required Python version 3.9.x:    ```sh    # install Python build dependences    brew install openssl readline sqlite3 xz zlib</p> <p># replace with up-to-date 3.9.x version    pyenv install 3.9.13    ```</p> <p>5) Set local Python version:    <code>sh    # switch to AYON source directory    pyenv local 3.9.13</code></p>"},{"location":"build_guides/macos.html#build","title":"Build","text":""},{"location":"build_guides/macos.html#clone-repository","title":"Clone repository","text":"<pre><code>git clone --recurse-submodules git@github.com:ynput/ayon-launcher.git\n</code></pre>"},{"location":"build_guides/macos.html#prepare-environment","title":"Prepare environment","text":"<p>Create virtual environment in <code>./.venv</code> and install python runtime dependencies like PySide, Pillow..</p> <pre><code>./tools/make.sh create-env\n./tools/make.sh install-runtime-dependencies\n</code></pre>"},{"location":"build_guides/macos.html#build-ayon-desktop","title":"Build AYON Desktop","text":"<p>Build AYON in <code>./build/</code>.</p> <pre><code>./tools/make.sh build\n</code></pre> <p>Build should create <code>./build/AYON {version}.app</code> file.</p>"},{"location":"build_guides/macos.html#create-installer","title":"Create installer","text":"<p>Create installer that can be distributed to server and workstations.</p> <pre><code>./tools/make.sh make-installer\n</code></pre> <p>Output installer is in <code>./build/installer/</code> directory. You should find <code>.dmg</code> and <code>.json</code> file. JSON file contains metadata required for server.</p>"},{"location":"build_guides/windows.html","title":"Build AYON launcher on Windows","text":""},{"location":"build_guides/windows.html#requirements","title":"Requirements","text":"<p>To build AYON you will need some tools and libraries. We do not provide any of these tools. You have to install them yourself. - PowerShell 5.0+ GitHub repository - git - Python 3.9 or higher - Inno Setup for installer</p> <p>Python 3.9.0 is not supported because of this bug.</p> <p>It is recommended to use pyenv for python version control.</p>"},{"location":"build_guides/windows.html#more-tools-might-be-needed-for-installing-python-dependencies","title":"More tools might be needed for installing python dependencies","text":"<ul> <li>CMake</li> <li>Visual Studio</li> </ul>"},{"location":"build_guides/windows.html#build","title":"Build","text":"<p>Open PowerShell and change directory where you want to clone repository.</p>"},{"location":"build_guides/windows.html#clone-repository","title":"Clone repository","text":"<pre><code>git clone --recurse-submodules git@github.com:ynput/ayon-launcher.git\n</code></pre>"},{"location":"build_guides/windows.html#prepare-environment","title":"Prepare environment","text":"<p>Create virtual environment in <code>./.venv</code> and install python runtime dependencies like PySide, Pillow..</p> <pre><code>./tools/manage.ps1 create-env\n./tools/manage.ps1 install-runtime-dependencies\n</code></pre>"},{"location":"build_guides/windows.html#build-ayon-desktop","title":"Build AYON Desktop","text":"<p>Build AYON executables in <code>./build/output/</code>.</p> <pre><code>./tools/manage.ps1 build\n</code></pre>"},{"location":"build_guides/windows.html#create-installer","title":"Create installer","text":"<p>Create installer that can be distributed to server and workstations.</p> <pre><code>./tools/manage.ps1 make-installer\n</code></pre> <p>Output files are in <code>./build/installer/</code> directory. You should find <code>.exe</code> and <code>.json</code> file. JSON file contains metadata required for server.</p>"}]}